/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/latex-parser.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@unified-latex/unified-latex-builder/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-builder/index.js ***!
  \********************************************************************/
/*! exports provided: SP, arg, args, env, m, s */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SP\", function() { return SP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arg\", function() { return arg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"args\", function() { return args; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"env\", function() { return env; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return m; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return s; });\n// libs/builders.ts\nfunction normalizeNode(node) {\n  if (typeof node === \"string\") {\n    return s(node);\n  }\n  return node;\n}\nfunction normalizeArgument(arg2, openMark = \"{\", closeMark = \"}\") {\n  if (typeof arg2 === \"string\") {\n    return {\n      type: \"argument\",\n      openMark,\n      closeMark,\n      content: [s(arg2)]\n    };\n  }\n  if (arg2.type === \"argument\") {\n    return arg2;\n  }\n  return { type: \"argument\", openMark, closeMark, content: [arg2] };\n}\nfunction normalizeArgumentsList(args2, openMark = \"{\", closeMark = \"}\") {\n  if (args2 == null) {\n    return [];\n  }\n  if (Array.isArray(args2)) {\n    return args2.map((arg2) => normalizeArgument(arg2, openMark, closeMark));\n  }\n  return [normalizeArgument(args2, openMark, closeMark)];\n}\nvar BRACES_MAP = {\n  \"*\": { openMark: \"\", closeMark: \"\" },\n  \"{\": { openMark: \"{\", closeMark: \"}\" },\n  \"[\": { openMark: \"[\", closeMark: \"]\" },\n  \"(\": { openMark: \"(\", closeMark: \")\" }\n};\nvar CLOSE_BRACES = new Set(Object.values(BRACES_MAP).map((x) => x.closeMark).filter((x) => x));\nfunction bracesToOpenAndCloseMarks(braces) {\n  const ret = [];\n  for (const char of braces.split(\"\")) {\n    if (CLOSE_BRACES.has(char)) {\n      continue;\n    }\n    const braces2 = BRACES_MAP[char];\n    if (braces2 == null) {\n      throw new Error(`Unknown open/close mark type \"${char}\"`);\n    }\n    braces2;\n    ret.push(braces2);\n  }\n  return ret;\n}\nfunction args(args2, special) {\n  if (!Array.isArray(args2)) {\n    args2 = [args2];\n  }\n  if (special == null ? void 0 : special.braces) {\n    const braces = bracesToOpenAndCloseMarks(special.braces);\n    if (braces.length !== args2.length) {\n      throw new Error(`There is a difference between the number of supplied braces and the number of supplied arguments. ${args2.length} supplied with braces signature ${special.braces}`);\n    }\n    return args2.map((arg2, i) => normalizeArgument(arg2, braces[i].openMark, braces[i].closeMark));\n  }\n  let openMark = (special == null ? void 0 : special.defaultOpenMark);// ?? \"{\";\n  if(openMark == null) openMark = \"{\";\n  let closeMark = (special == null ? void 0 : special.defaultCloseMark);// ?? \"}\";\n  if(closeMark == null) closeMark = \"}\";\n  \n  return normalizeArgumentsList(args2, openMark, closeMark);\n}\nfunction arg(args2, special) {\n  if (typeof args2 === \"string\") {\n    args2 = s(args2);\n  }\n  if (!Array.isArray(args2) && args2.type === \"argument\") {\n    return args2;\n  }\n  let openMark = (special == null ? void 0 : special.openMark); //?? \"{\";\n  if(openMark == null) openMark = \"{\";\n  let closeMark = (special == null ? void 0 : special.closeMark); //?? \"}\";\n  if(closeMark == null) closeMark = \"}\";\n  if (special == null ? void 0 : special.braces) {\n    const braces = bracesToOpenAndCloseMarks(special.braces);\n    if (braces[0]) {\n      openMark = braces[0].openMark;\n      closeMark = braces[0].closeMark;\n    }\n  }\n  if (!Array.isArray(args2)) {\n    args2 = [args2];\n  }\n  return { type: \"argument\", content: args2, openMark, closeMark };\n}\nfunction m(name, marcoArgs, special) {\n  const args2 = normalizeArgumentsList(marcoArgs);\n  const escapeToken = special == null ? void 0 : special.escapeToken;\n  const ret = { type: \"macro\", content: name };\n  if (args2.length > 0) {\n    ret.args = args2;\n  }\n  if (escapeToken != null) {\n    ret.escapeToken = escapeToken;\n  }\n  return ret;\n}\nfunction s(value) {\n  if (typeof value === \"string\") {\n    return { type: \"string\", content: value };\n  }\n  return value;\n}\nfunction env(name, body, envArgs, special) {\n  if (!Array.isArray(body)) {\n    body = [body];\n  }\n  const args2 = normalizeArgumentsList(envArgs, \"[\", \"]\");\n  const ret = {\n    type: \"environment\",\n    env: name,\n    content: body.map(normalizeNode)\n  };\n  if (args2.length > 0) {\n    ret.args = args2;\n  }\n  return ret;\n}\nvar SP = { type: \"whitespace\" };\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-builder/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-ctan/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-ctan/index.js ***!
  \*****************************************************************/
/*! exports provided: environmentInfo, macroInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"environmentInfo\", function() { return environmentInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"macroInfo\", function() { return macroInfo; });\n/* harmony import */ var _unified_latex_unified_latex_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @unified-latex/unified-latex-builder */ \"./node_modules/@unified-latex/unified-latex-builder/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @unified-latex/unified-latex-util-match */ \"./node_modules/@unified-latex/unified-latex-util-match/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_render_info__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @unified-latex/unified-latex-util-render-info */ \"./node_modules/@unified-latex/unified-latex-util-render-info/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @unified-latex/unified-latex-util-visit */ \"./node_modules/@unified-latex/unified-latex-util-visit/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @unified-latex/unified-latex-util-trim */ \"./node_modules/@unified-latex/unified-latex-util-trim/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_split__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @unified-latex/unified-latex-util-split */ \"./node_modules/@unified-latex/unified-latex-util-split/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_pegjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @unified-latex/unified-latex-util-pegjs */ \"./node_modules/@unified-latex/unified-latex-util-pegjs/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @unified-latex/unified-latex-util-print-raw */ \"./node_modules/@unified-latex/unified-latex-util-print-raw/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_comments__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @unified-latex/unified-latex-util-comments */ \"./node_modules/@unified-latex/unified-latex-util-comments/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_arguments__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @unified-latex/unified-latex-util-arguments */ \"./node_modules/@unified-latex/unified-latex-util-arguments/index.js\");\n/* harmony import */ var color__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! color */ \"./node_modules/color/index.js\");\n/* harmony import */ var color__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(color__WEBPACK_IMPORTED_MODULE_10__);\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\n\n// package/cleveref/provides.ts\nvar macros = {\n  cref: { signature: \"s m\" },\n  Cref: { signature: \"s m\" },\n  crefrange: { signature: \"s m m\" },\n  Crefrange: { signature: \"s m m\" },\n  cpageref: { signature: \"s m\" },\n  Cpageref: { signature: \"s m\" },\n  ref: { signature: \"m\" },\n  pageref: { signature: \"m\" },\n  namecref: { signature: \"m\" },\n  nameCref: { signature: \"m\" },\n  lcnamecref: { signature: \"m\" },\n  namecrefs: { signature: \"m\" },\n  nameCrefs: { signature: \"m\" },\n  lcnamecrefs: { signature: \"m\" },\n  labelcref: { signature: \"m\" },\n  labelcpageref: { signature: \"m\" },\n  crefalias: { signature: \"m m\" },\n  crefname: { signature: \"m m m\" },\n  crefdefaultlabelformat: { signature: \"m\" },\n  crefrangeconjunction: { signature: \"m\" }\n};\nvar environments = {};\n\n// utils/enumerate.ts\n\n\n\n\n// ../unified-latex-util-replace/dist/index.js\n\n\n\n\n\n\n\n\n\n\n\n\nfunction lastSignificantNodeIndex(nodes, parbreaksAreInsignificant) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    const node = nodes[i];\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespace(node) || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].comment(node) || parbreaksAreInsignificant && _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].parbreak(node)) {\n      continue;\n    }\n    return i;\n  }\n  return void 0;\n}\n\n// utils/enumerate.ts\n\n\nfunction cleanEnumerateBody(ast, itemName = \"item\") {\n  let { segments, macros: macros13 } = Object(_unified_latex_unified_latex_util_split__WEBPACK_IMPORTED_MODULE_5__[\"splitOnMacro\"])(ast, itemName);\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    if (i === 0) {\n      Object(_unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_4__[\"trimEnd\"])(segment);\n    } else {\n      Object(_unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_4__[\"trim\"])(segment);\n    }\n    if (segment.length > 0 && i > 0) {\n      segment.unshift({ type: \"whitespace\" });\n    }\n  }\n  let insertParbreakBefore = /* @__PURE__ */ new WeakSet();\n  let body = macros13.flatMap((node, i) => {\n    var _a;\n    const segment = segments[i + 1];\n    const trailingComments = popTrailingComments(segment);\n    node.args = node.args || [];\n    node.args.push(Object(_unified_latex_unified_latex_builder__WEBPACK_IMPORTED_MODULE_0__[\"arg\"])(segment, { openMark: \"\", closeMark: \"\" }));\n    Object(_unified_latex_unified_latex_util_render_info__WEBPACK_IMPORTED_MODULE_2__[\"updateRenderInfo\"])(node, { inParMode: true });\n    if (i > 0 || ((_a = segments[0]) == null ? void 0 : _a.length) > 0) {\n      insertParbreakBefore.add(node);\n    }\n    return [node, ...trailingComments];\n  });\n  body = body.flatMap((node) => insertParbreakBefore.has(node) ? [{ type: \"parbreak\" }, node] : node);\n  body.unshift(...segments[0]);\n  for (let i = 0; i < body.length - 1; i++) {\n    const node = body[i];\n    const nextNode = body[i + 1];\n    if (!_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].parbreak(nextNode)) {\n      continue;\n    }\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].comment(node)) {\n      node.suffixParbreak = true;\n    }\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].macro(node) && node.args && node.args[node.args.length - 1].closeMark === \"\") {\n      const args = node.args[node.args.length - 1].content;\n      const lastArg = args[args.length - 1];\n      if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].comment(lastArg)) {\n        lastArg.suffixParbreak = true;\n      }\n    }\n  }\n  return body;\n}\nfunction popTrailingComments(nodes) {\n  let lastNodeIndex = lastSignificantNodeIndex(nodes, true);\n  if (lastNodeIndex === nodes.length - 1 || lastNodeIndex == null && nodes.length === 0) {\n    return [];\n  }\n  if (lastNodeIndex == null) {\n    lastNodeIndex = -1;\n  }\n  return nodes.splice(lastNodeIndex + 1);\n}\n\n// package/exam/provides.ts\nvar macros2 = {\n  answerline: { signature: \"o\" },\n  fillin: { signature: \"o o\" },\n  fullwidth: { signature: \"m\" },\n  fillwidthlines: { signature: \"m\" },\n  fillwidthdottedlines: { signature: \"m\" },\n  fillwidthgrid: { signature: \"m\" },\n  makeemptybox: { signature: \"m\" },\n  CorrectChoiceEmphasis: {\n    signature: \"m\",\n    renderInfo: { breakAround: true }\n  },\n  SolutionEmphasis: { signature: \"m\", renderInfo: { breakAround: true } },\n  uplevel: { signature: \"m\", renderInfo: { breakAround: true } },\n  checkboxchar: { signature: \"m\", renderInfo: { breakAround: true } },\n  checkedchar: { signature: \"m\", renderInfo: { breakAround: true } },\n  pointname: { signature: \"m\", renderInfo: { breakAround: true } },\n  marginpointname: { signature: \"m\", renderInfo: { breakAround: true } },\n  extrawidth: { signature: \"m\", renderInfo: { breakAround: true } },\n  pointformat: { signature: \"m\", renderInfo: { breakAround: true } },\n  bonuspointformat: { signature: \"m\", renderInfo: { breakAround: true } },\n  totalformat: { signature: \"m\", renderInfo: { breakAround: true } },\n  qformat: { signature: \"m\", renderInfo: { breakAround: true } },\n  titledquestion: { signature: \"m o\", renderInfo: { breakAround: true } },\n  pointpoints: { signature: \"m m\", renderInfo: { breakAround: true } },\n  bonuspointpoints: { signature: \"m m\", renderInfo: { breakAround: true } }\n};\nvar environments2 = {\n  choices: {\n    signature: \"o\",\n    processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\")\n  },\n  checkboxes: {\n    signature: \"o\",\n    processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\")\n  },\n  oneparchoices: {\n    signature: \"o\",\n    processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\")\n  },\n  oneparcheckboxes: {\n    signature: \"o\",\n    processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\")\n  },\n  parts: {\n    signature: \"o\",\n    processContent: (nodes) => cleanEnumerateBody(nodes, \"part\")\n  },\n  subparts: {\n    signature: \"o\",\n    processContent: (nodes) => cleanEnumerateBody(nodes, \"subpart\")\n  },\n  subsubparts: {\n    signature: \"o\",\n    processContent: (nodes) => cleanEnumerateBody(nodes, \"subsubpart\")\n  },\n  questions: {\n    signature: \"o\",\n    processContent: (nodes) => cleanEnumerateBody(nodes, \"question\")\n  }\n};\n\n// package/geometry/provides.ts\nvar macros3 = {\n  geometry: {\n    signature: \"m\",\n    renderInfo: { breakAround: true, pgfkeysArgs: true }\n  }\n};\nvar environments3 = {};\n\n// package/hyperref/provides.ts\nvar macros4 = {\n  hypersetup: {\n    signature: \"m\",\n    renderInfo: { breakAround: true, pgfkeysArgs: true }\n  },\n  href: { signature: \"o m m\" },\n  url: { signature: \"m\" },\n  nolinkurl: { signature: \"m\" },\n  hyperbaseurl: { signature: \"m\" },\n  hyperimage: { signature: \"m m\" },\n  hyperdef: { signature: \"m m m\" },\n  hyperref: { signature: \"o m\" },\n  hyperlink: { signature: \"m m\" },\n  hypertarget: { signature: \"m m\" },\n  autoref: { signature: \"s m\" },\n  pageref: { signature: \"s m\" },\n  autopageref: { signature: \"s m\" },\n  pdfstringdef: { signature: \"m m\" },\n  pdfbookmark: { signature: \"o m m\" },\n  currentpdfbookmark: { signature: \"m m\" },\n  subpdfbookmark: { signature: \"m m\" },\n  belowpdfbookmark: { signature: \"m m\" },\n  texorpdfstring: { signature: \"m m\" },\n  thispdfpagelabel: { signature: \"m\" },\n  hypercalcbp: { signature: \"m\" }\n};\nvar environments4 = {};\n\n// package/latex2e/provides.ts\n\nvar macros5 = {\n  \"\\\\\": { signature: \"!s o\" },\n  _: { signature: \"m\", escapeToken: \"\" },\n  \"^\": { signature: \"m\", escapeToken: \"\" },\n  newcommand: {\n    signature: \"s +m o +o +m\",\n    renderInfo: { breakAround: true }\n  },\n  renewcommand: {\n    signature: \"s +m o +o +m\",\n    renderInfo: { breakAround: true }\n  },\n  providecommand: {\n    signature: \"s +m o +o +m\",\n    renderInfo: { breakAround: true }\n  },\n  newcounter: {\n    signature: \"m o\",\n    renderInfo: { breakAround: true }\n  },\n  usecounter: {\n    signature: \"m\"\n  },\n  setcounter: {\n    signature: \"m m\",\n    renderInfo: { breakAround: true }\n  },\n  addtocounter: {\n    signature: \"m m\",\n    renderInfo: { breakAround: true }\n  },\n  stepcounter: {\n    signature: \"m\",\n    renderInfo: { breakAround: true }\n  },\n  refstepcounter: {\n    signature: \"m\",\n    renderInfo: { breakAround: true }\n  },\n  newlength: {\n    signature: \"m\",\n    renderInfo: { breakAround: true }\n  },\n  addtolength: {\n    signature: \"m m\",\n    renderInfo: { breakAround: true }\n  },\n  settodepth: {\n    signature: \"m m\",\n    renderInfo: { breakAround: true }\n  },\n  settoheight: {\n    signature: \"m m\",\n    renderInfo: { breakAround: true }\n  },\n  settowidth: {\n    signature: \"m m\",\n    renderInfo: { breakAround: true }\n  },\n  stretch: { signature: \"m\" },\n  hspace: { signature: \"s m\" },\n  vspace: { signature: \"s m\", renderInfo: { breakAround: true } },\n  vfill: { renderInfo: { breakAround: true } },\n  indent: { renderInfo: { breakAround: true } },\n  phantom: { signature: \"m\" },\n  vphantom: { signature: \"m\" },\n  hphantom: { signature: \"m\" },\n  noindent: { renderInfo: { breakAround: true } },\n  smallskip: { renderInfo: { breakAround: true } },\n  medskip: { renderInfo: { breakAround: true } },\n  bigskip: { renderInfo: { breakAround: true } },\n  smallbreak: { renderInfo: { breakAround: true } },\n  medbreak: { renderInfo: { breakAround: true } },\n  bigbreak: { renderInfo: { breakAround: true } },\n  newline: { renderInfo: { breakAround: true } },\n  linebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n  nolinebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n  clearpage: { renderInfo: { breakAround: true } },\n  cleardoublepage: { renderInfo: { breakAround: true } },\n  newpage: { renderInfo: { breakAround: true } },\n  enlargethispage: { signature: \"s\", renderInfo: { breakAround: true } },\n  pagebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n  nopagebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n  newsavebox: {\n    signature: \"m\",\n    renderInfo: { breakAround: true }\n  },\n  sbox: {\n    signature: \"m m\",\n    renderInfo: { breakAround: true }\n  },\n  savebox: {\n    signature: \"m o o m\",\n    renderInfo: { breakAround: true }\n  },\n  mbox: { signature: \"m\" },\n  makebox: { signature: \"d() o o m\", renderInfo: { breakAround: true } },\n  fbox: { signature: \"m\" },\n  framebox: { signature: \"o o m\", renderInfo: { breakAround: true } },\n  frame: { signature: \"m\", renderInfo: { breakAround: true } },\n  parbox: { signature: \"o o o m m\", renderInfo: { breakAround: true } },\n  raisebox: { signature: \"m o o m\" },\n  marginpar: { signature: \"o m\", renderInfo: { breakAround: true } },\n  colorbox: { signature: \"o m m\", renderInfo: { breakAround: true } },\n  fcolorbox: { signature: \"o m m\", renderInfo: { breakAround: true } },\n  rotatebox: { signature: \"o m m\" },\n  scalebox: { signature: \"m o m\" },\n  reflectbox: { signature: \"m\" },\n  resizebox: { signature: \"s m m m\" },\n  newenvironment: {\n    signature: \"s m o o m m\",\n    renderInfo: { breakAround: true }\n  },\n  renewenvironment: {\n    signature: \"s m o o m m\",\n    renderInfo: { breakAround: true }\n  },\n  newtheorem: {\n    signature: \"s m o m o\",\n    renderInfo: { breakAround: true }\n  },\n  newfont: {\n    signature: \"m m\",\n    renderInfo: { breakAround: true }\n  },\n  alph: { signature: \"m\" },\n  Alph: { signature: \"m\" },\n  arabic: { signature: \"m\" },\n  roman: { signature: \"m\" },\n  Roman: { signature: \"m\" },\n  fnsymbol: { signature: \"m\" },\n  documentclass: {\n    signature: \"o m\",\n    renderInfo: { breakAround: true, pgfkeysArgs: true }\n  },\n  usepackage: {\n    signature: \"o m\",\n    renderInfo: { breakAround: true, pgfkeysArgs: true }\n  },\n  item: { signature: \"o\", renderInfo: { hangingIndent: true } },\n  value: { signature: \"m\" },\n  centering: { renderInfo: { breakAround: true } },\n  input: { signature: \"m\", renderInfo: { breakAround: true } },\n  include: { signature: \"m\", renderInfo: { breakAround: true } },\n  includeonly: {\n    signature: \"m\",\n    renderInfo: { breakAround: true, pgfkeysArgs: true }\n  },\n  discretionary: { signature: \"m m m\" },\n  hyphenation: { signature: \"m m m\" },\n  footnote: { signature: \"o m\", renderInfo: { inParMode: true } },\n  footnotemark: { signature: \"o\" },\n  footnotetext: { signature: \"o m\", renderInfo: { inParMode: true } },\n  caption: {\n    signature: \"o m\",\n    renderInfo: { inParMode: true, breakAround: true }\n  },\n  sqrt: { signature: \"o m\", renderInfo: { inMathMode: true } },\n  frac: { signature: \"m m\", renderInfo: { inMathMode: true } },\n  stackrel: { signature: \"m m\" },\n  ensuremath: { signature: \"m\", renderInfo: { inMathMode: true } },\n  abstract: {\n    signature: \"m\",\n    renderInfo: { breakAround: true, inParMode: true }\n  },\n  maketitle: { renderInfo: { breakAround: true } },\n  doublespacing: { renderInfo: { breakAround: true } },\n  singlespacing: { renderInfo: { breakAround: true } },\n  author: {\n    signature: \"m\",\n    renderInfo: { breakAround: true, inParMode: true }\n  },\n  date: { signature: \"m\", renderInfo: { breakAround: true } },\n  thanks: {\n    signature: \"m\",\n    renderInfo: { breakAround: true, inParMode: true }\n  },\n  title: {\n    signature: \"o m\",\n    renderInfo: { breakAround: true, inParMode: true }\n  },\n  pagenumbering: { signature: \"m\", renderInfo: { breakAround: true } },\n  pagestyle: { signature: \"m\", renderInfo: { breakAround: true } },\n  thispagestyle: { signature: \"m\", renderInfo: { breakAround: true } },\n  definecolor: { signature: \"m m m\", renderInfo: { breakAround: true } },\n  pagecolor: { signature: \"o m\", renderInfo: { breakAround: true } },\n  nopagecolor: { renderInfo: { breakAround: true } },\n  multicolumn: { signature: \"m m m\" },\n  includegraphics: {\n    signature: \"s o o m\",\n    renderInfo: { breakAround: true, pgfkeysArgs: true }\n  },\n  rule: { signature: \"o m m\" },\n  part: {\n    signature: \"s o m\",\n    renderInfo: { breakAround: true, inParMode: true }\n  },\n  chapter: {\n    signature: \"s o m\",\n    renderInfo: { breakAround: true, inParMode: true }\n  },\n  section: {\n    signature: \"s o m\",\n    renderInfo: { breakAround: true, inParMode: true }\n  },\n  subsection: {\n    signature: \"s o m\",\n    renderInfo: { breakAround: true, inParMode: true }\n  },\n  subsubsection: {\n    signature: \"s o m\",\n    renderInfo: { breakAround: true, inParMode: true }\n  },\n  paragraph: {\n    signature: \"s o m\",\n    renderInfo: { breakAround: true, inParMode: true }\n  },\n  subparagraph: {\n    signature: \"s o m\",\n    renderInfo: { breakAround: true, inParMode: true }\n  },\n  appendix: { renderInfo: { breakAround: true, inParMode: true } },\n  frontmatter: { renderInfo: { breakAround: true, inParMode: true } },\n  mainmatter: { renderInfo: { breakAround: true, inParMode: true } },\n  backmatter: { renderInfo: { breakAround: true, inParMode: true } },\n  bibitem: { signature: \"o m\", renderInfo: { hangingIndent: true } },\n  cite: { signature: \"o m\" },\n  textrm: { signature: \"m\", renderInfo: { inParMode: true } },\n  textit: { signature: \"m\", renderInfo: { inParMode: true } },\n  textmd: { signature: \"m\", renderInfo: { inParMode: true } },\n  textbf: { signature: \"m\", renderInfo: { inParMode: true } },\n  textup: { signature: \"m\", renderInfo: { inParMode: true } },\n  textsl: { signature: \"m\", renderInfo: { inParMode: true } },\n  textsf: { signature: \"m\", renderInfo: { inParMode: true } },\n  textsc: { signature: \"m\", renderInfo: { inParMode: true } },\n  texttt: { signature: \"m\", renderInfo: { inParMode: true } },\n  emph: { signature: \"m\", renderInfo: { inParMode: true } },\n  textnormal: { signature: \"m\", renderInfo: { inParMode: true } },\n  uppercase: { signature: \"m\", renderInfo: { inParMode: true } },\n  mathbf: { signature: \"m\" },\n  mathsf: { signature: \"m\" },\n  mathtt: { signature: \"m\" },\n  mathit: { signature: \"m\" },\n  mathnormal: { signature: \"m\" },\n  mathcal: { signature: \"m\" },\n  mathrm: { signature: \"m\" },\n  setlength: { signature: \"m m\", renderInfo: { breakAround: true } },\n  ref: { signature: \"s m\" },\n  label: { signature: \"o m\" },\n  printbibliography: { renderInfo: { breakAround: true } },\n  addtocontents: { signature: \"m m\", renderInfo: { breakAround: true } },\n  addcontentsline: { signature: \"m m m\", renderInfo: { breakAround: true } },\n  contentsline: { signature: \"m m m\", renderInfo: { breakAround: true } },\n  bibliography: { signature: \"m\", renderInfo: { breakAround: true } },\n  bibliographystyle: { signature: \"m\", renderInfo: { breakAround: true } }\n};\nvar environments5 = {\n  document: {\n    processContent: (nodes) => {\n      Object(_unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_4__[\"trim\"])(nodes);\n      return nodes;\n    }\n  },\n  array: { signature: \"o m\", renderInfo: { alignContent: true } },\n  description: { signature: \"o\", processContent: cleanEnumerateBody },\n  enumerate: {\n    signature: \"o\",\n    processContent: cleanEnumerateBody,\n    renderInfo: { pgfkeysArgs: true }\n  },\n  itemize: { signature: \"o\", processContent: cleanEnumerateBody },\n  trivlist: { signature: \"o\", processContent: cleanEnumerateBody },\n  list: { signature: \"m m\", processContent: cleanEnumerateBody },\n  figure: { signature: \"o\" },\n  \"figure*\": { signature: \"o\" },\n  filecontents: { signature: \"o m\" },\n  \"filecontents*\": { signature: \"o m\" },\n  minipage: { signature: \"o o o m\" },\n  picture: { signature: \"r() d()\" },\n  tabbing: { renderInfo: { alignContent: true } },\n  table: { signature: \"o\" },\n  tabular: { signature: \"o m\", renderInfo: { alignContent: true } },\n  \"tabular*\": { signature: \"m o m\", renderInfo: { alignContent: true } },\n  thebibliography: {\n    signature: \"m\",\n    processContent: (nodes) => cleanEnumerateBody(nodes, \"bibitem\")\n  },\n  math: { renderInfo: { inMathMode: true } }\n};\n\n// package/makeidx/provides.ts\nvar macros6 = {\n  see: { signature: \"m m\" },\n  seealso: { signature: \"m m\" },\n  seename: { signature: \"m\" },\n  alsoname: { signature: \"m\" },\n  index: { signature: \"m\" }\n};\nvar environments6 = {};\n\n// package/mathtools/provides.ts\nvar macros7 = {\n  mathtoolsset: {\n    signature: \"m\",\n    renderInfo: { breakAround: true, pgfkeysArgs: true }\n  },\n  mathllap: {\n    signature: \"o m\"\n  },\n  mathrlap: {\n    signature: \"o m\"\n  },\n  mathclap: {\n    signature: \"o m\"\n  },\n  clap: {\n    signature: \"m\"\n  },\n  mathmbox: {\n    signature: \"m\"\n  },\n  mathmakebox: {\n    signature: \"o o m\"\n  },\n  cramped: {\n    signature: \"o m\"\n  },\n  crampedllap: {\n    signature: \"o m\"\n  },\n  crampedrlap: {\n    signature: \"o m\"\n  },\n  crampedclap: {\n    signature: \"o m\"\n  },\n  crampedsubstack: {\n    signature: \"o m\"\n  },\n  smashoperator: {\n    signature: \"o m\"\n  },\n  newtagform: {\n    signature: \"m o m m\"\n  },\n  renewtagform: {\n    signature: \"m o m m\"\n  },\n  usetagform: {\n    signature: \"m\"\n  },\n  xleftrightarrow: { signature: \"o m\" },\n  xLeftarrow: { signature: \"o m\" },\n  xhookleftarrow: { signature: \"o m\" },\n  xmapsto: { signature: \"o m\" },\n  xRightarrow: { signature: \"o m\" },\n  xLeftrightarrow: { signature: \"o m\" },\n  xhookrightarrow: { signature: \"o m\" },\n  underbracket: { signature: \"o o m\" },\n  overbracket: { signature: \"o o m\" },\n  underbrace: { signature: \"m\" },\n  overbrace: { signature: \"m\" },\n  shoveleft: { signature: \"o m\" },\n  shoveright: { signature: \"o m\" },\n  ArrowBetweenLines: { signature: \"s o\" },\n  vdotswithin: { signature: \"m\" },\n  shortdotswithin: { signature: \"s m\" },\n  DeclarePairedDelimiter: {\n    signature: \"m m m\",\n    renderInfo: { breakAround: true }\n  },\n  DeclarePairedDelimiterX: {\n    signature: \"m o m m m\",\n    renderInfo: { breakAround: true }\n  },\n  DeclarePairedDelimiterXPP: {\n    signature: \"m o m m m m m\",\n    renderInfo: { breakAround: true }\n  },\n  prescript: { signature: \"m m m\" },\n  DeclareMathSizes: { signature: \"m m m m\" },\n  newgathered: { signature: \"m m m m\" },\n  renewgathered: { signature: \"m m m m\" },\n  splitfrac: { signature: \"m m\" },\n  splitdfrac: { signature: \"m m\" },\n  xmathstrut: { signature: \"o m\" },\n  newtheorem: { signature: \"s m o m o\", renderInfo: { breakAround: true } },\n  theoremstyle: { signature: \"m\", renderInfo: { breakAround: true } },\n  newtheoremstyle: {\n    signature: \"m m m m m m m m m\",\n    renderInfo: { breakAround: true }\n  },\n  text: { signature: \"m\", renderInfo: { inMathMode: false } },\n  mathbb: { signature: \"m\" },\n  mathscr: { signature: \"m\" },\n  mathfrak: { signature: \"m\" },\n  frak: { signature: \"m\" },\n  Bdd: { signature: \"m\" },\n  bold: { signature: \"m\" },\n  operatorname: { signature: \"s m\" },\n  DeclareMathOperator: {\n    signature: \"s m m\",\n    renderInfo: { breakAround: true }\n  }\n};\nvar environments7 = {\n  crampedsubarray: {\n    signature: \"m\",\n    renderInfo: { alignContent: true, inMathMode: true }\n  },\n  matrix: { renderInfo: { alignContent: true, inMathMode: true } },\n  bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n  pmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n  vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n  Bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n  Vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n  smallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n  psmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n  vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n  bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n  Bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n  Vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n  \"matrix*\": {\n    signature: \"o\",\n    renderInfo: { alignContent: true, inMathMode: true }\n  },\n  \"bmatrix*\": {\n    signature: \"o\",\n    renderInfo: { alignContent: true, inMathMode: true }\n  },\n  \"pmatrix*\": {\n    signature: \"o\",\n    renderInfo: { alignContent: true, inMathMode: true }\n  },\n  \"vmatrix*\": {\n    signature: \"o\",\n    renderInfo: { alignContent: true, inMathMode: true }\n  },\n  \"Bmatrix*\": {\n    signature: \"o\",\n    renderInfo: { alignContent: true, inMathMode: true }\n  },\n  \"Vmatrix*\": {\n    signature: \"o\",\n    renderInfo: { alignContent: true, inMathMode: true }\n  },\n  \"smallmatrix*\": {\n    signature: \"o\",\n    renderInfo: { alignContent: true, inMathMode: true }\n  },\n  \"psmallmatrix*\": {\n    signature: \"o\",\n    renderInfo: { alignContent: true, inMathMode: true }\n  },\n  \"bsmallmatrix*\": {\n    signature: \"o\",\n    renderInfo: { alignContent: true, inMathMode: true }\n  },\n  \"vsmallmatrix*\": {\n    signature: \"o\",\n    renderInfo: { alignContent: true, inMathMode: true }\n  },\n  \"Bsmallmatrix*\": {\n    signature: \"o\",\n    renderInfo: { alignContent: true, inMathMode: true }\n  },\n  \"Vsmallmatrix*\": {\n    signature: \"o\",\n    renderInfo: { alignContent: true, inMathMode: true }\n  },\n  multilined: { signature: \"o o\", renderInfo: { inMathMode: true } },\n  cases: { renderInfo: { alignContent: true, inMathMode: true } },\n  \"cases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n  dcases: { renderInfo: { alignContent: true, inMathMode: true } },\n  \"dcases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n  rcases: { renderInfo: { alignContent: true, inMathMode: true } },\n  \"rcases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n  drcases: { renderInfo: { alignContent: true, inMathMode: true } },\n  \"drcases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n  spreadlines: { signature: \"m\", renderInfo: { inMathMode: true } },\n  lgathered: { signature: \"o\", renderInfo: { inMathMode: true } },\n  rgathered: { signature: \"o\", renderInfo: { inMathMode: true } },\n  \"align*\": { renderInfo: { inMathMode: true, alignContent: true } },\n  align: { renderInfo: { inMathMode: true, alignContent: true } },\n  aligned: { renderInfo: { inMathMode: true, alignContent: true } },\n  \"alignat*\": { renderInfo: { inMathMode: true, alignContent: true } },\n  alignat: { renderInfo: { inMathMode: true, alignContent: true } },\n  \"equation*\": { renderInfo: { inMathMode: true } },\n  equation: { renderInfo: { inMathMode: true } },\n  \"gather*\": { renderInfo: { inMathMode: true } },\n  gather: { renderInfo: { inMathMode: true } },\n  \"multline*\": { renderInfo: { inMathMode: true } },\n  multline: { renderInfo: { inMathMode: true } },\n  \"flalign*\": { renderInfo: { inMathMode: true, alignContent: true } },\n  flalign: { renderInfo: { inMathMode: true, alignContent: true } },\n  split: { renderInfo: { inMathMode: true } },\n  displaymath: { renderInfo: { inMathMode: true } },\n  theorem: { signature: \"o\" },\n  lemma: { signature: \"o\" },\n  definition: { signature: \"o\" },\n  proposition: { signature: \"o\" },\n  corollary: { signature: \"o\" },\n  remark: { signature: \"!o\" },\n  example: { signature: \"!o\" },\n  proof: { signature: \"o\" }\n};\n\n// package/nicematrix/provides.ts\nvar macros8 = {\n  NiceMatrixOptions: {\n    signature: \"m\",\n    renderInfo: { pgfkeysArgs: true, breakAround: true }\n  }\n};\nvar environments8 = {\n  NiceTabular: {\n    signature: \"o m !o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  NiceMatrixBlock: {\n    signature: \"!o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  NiceArrayWithDelims: {\n    signature: \"m m o m !o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  NiceArray: {\n    signature: \"o m !o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  pNiceArray: {\n    signature: \"o m !o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  bNiceArray: {\n    signature: \"o m !o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  BNiceArray: {\n    signature: \"o m !o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  vNiceArray: {\n    signature: \"o m !o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  VNiceArray: {\n    signature: \"o m !o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  NiceMatrix: {\n    signature: \"!o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  pNiceMatrix: {\n    signature: \"!o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  bNiceMatrix: {\n    signature: \"!o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  BNiceMatrix: {\n    signature: \"!o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  vNiceMatrix: {\n    signature: \"!o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  },\n  VNiceMatrix: {\n    signature: \"!o\",\n    renderInfo: { pgfkeysArgs: true, alignContent: true }\n  }\n};\n\n// package/systeme/provides.ts\nvar macros9 = {\n  systeme: {\n    signature: \"s o o m\",\n    renderInfo: { inMathMode: true }\n  },\n  sysdelim: {\n    signature: \"m m\"\n  },\n  syseqsep: { signature: \"m\" },\n  sysalign: { signature: \"m\" },\n  syssignspace: { signature: \"m\" },\n  syseqspace: { signature: \"m\" },\n  syslineskipcoeff: { signature: \"m\" },\n  syseqivsign: { signature: \"m\" },\n  sysaddeqsign: { signature: \"m\" },\n  sysremoveeqsign: { signature: \"m\" },\n  sysextracolonsign: { signature: \"m\" },\n  syscodeextracol: { signature: \"m\" },\n  sysautonum: { signature: \"m\" },\n  syssubstitute: { signature: \"m\" }\n};\nvar environments9 = {};\n\n// package/systeme/libs/parser.ts\n\n\n\n\n// package/systeme/libs/print-raw.ts\n\n\n// package/systeme/libs/systeme.ts\n\n\n\n\n// ../structured-clone/dist/index.js\n(function() {\n  if (typeof globalThis === \"object\")\n    return;\n  Object.defineProperty(Object.prototype, \"__magic__\", {\n    get: function() {\n      return this;\n    },\n    configurable: true\n  });\n  __magic__.globalThis = __magic__;\n  delete Object.prototype.__magic__;\n})();\nvar clone = typeof globalThis.structuredClone === \"function\" ? globalThis.structuredClone : (obj) => JSON.parse(JSON.stringify(obj));\n\n// package/systeme/libs/systeme.ts\n\n\n\n\n\n// package/tikz/provides.ts\nvar macros10 = {\n  pgfkeys: {\n    signature: \"m\",\n    renderInfo: { breakAround: true, pgfkeysArgs: true }\n  },\n  tikzoption: {\n    signature: \"m\",\n    renderInfo: { breakAround: true, pgfkeysArgs: true }\n  },\n  tikzstyle: {\n    signature: \"m\",\n    renderInfo: { breakAround: true, pgfkeysArgs: true }\n  },\n  usetikzlibrary: {\n    signature: \"m\",\n    renderInfo: { breakAround: true, pgfkeysArgs: true }\n  },\n  pgfplotsset: {\n    signature: \"m\",\n    renderInfo: { breakAround: true, pgfkeysArgs: true }\n  },\n  pgfplotstabletypeset: {\n    signature: \"o m\",\n    renderInfo: { breakAround: true, pgfkeysArgs: true }\n  }\n};\nvar environments10 = {\n  tikzpicture: { signature: \"o\", renderInfo: { pgfkeysArgs: true } },\n  axis: { signature: \"o\", renderInfo: { pgfkeysArgs: true } }\n};\n\n// package/xcolor/provides.ts\nvar macros11 = {\n  substitutecolormodel: {\n    signature: \"m m\",\n    renderInfo: { breakAround: true }\n  },\n  selectcolormodel: {\n    signature: \"m\",\n    renderInfo: { breakAround: true }\n  },\n  definecolor: {\n    signature: \"o m m m\",\n    renderInfo: { breakAround: true }\n  },\n  providecolor: {\n    signature: \"o m m m\",\n    renderInfo: { breakAround: true }\n  },\n  colorlet: {\n    signature: \"o m o m\",\n    renderInfo: { breakAround: true }\n  },\n  definecolorset: {\n    signature: \"o m m m\",\n    renderInfo: { breakAround: true }\n  },\n  providecolorset: {\n    signature: \"o m m m m\",\n    renderInfo: { breakAround: true }\n  },\n  preparecolor: {\n    signature: \"o m m m\",\n    renderInfo: { breakAround: true }\n  },\n  preparecolorset: {\n    signature: \"o m m m m\",\n    renderInfo: { breakAround: true }\n  },\n  DefineNamedColor: {\n    signature: \"m m m m\",\n    renderInfo: { breakAround: true }\n  },\n  definecolors: {\n    signature: \"m\",\n    renderInfo: { breakAround: true }\n  },\n  providecolors: {\n    signature: \"m\",\n    renderInfo: { breakAround: true }\n  },\n  color: { signature: \"o m\", renderInfo: { breakAround: true } },\n  textcolor: { signature: \"o m m\", renderInfo: { inParMode: true } },\n  pagecolor: { signature: \"o m\" },\n  colorbox: { signature: \"o m m\" },\n  fcolorbox: { signature: \"o m o m m\" },\n  boxframe: { signature: \"o m\" },\n  testcolor: { signature: \"o m\" },\n  blendcolors: { signature: \"s m\" },\n  maskcolors: { signature: \"o m\" },\n  definecolorseries: {\n    signature: \"m m m o m o m\",\n    renderInfo: { breakAround: true }\n  },\n  resetcolorseries: {\n    signature: \"o m\",\n    renderInfo: { breakAround: true }\n  },\n  rowcolors: { signature: \"s o m m m\" },\n  extractcolorspec: { signature: \"m m\" },\n  extractcolorspecs: { signature: \"m m m\" },\n  convertcolorspec: { signature: \"m m m m\" }\n};\nvar environments11 = {\n  testcolors: { signature: \"o\", renderInfo: { pgfkeysArgs: true } }\n};\n\n// package/xcolor/libs/xcolor.ts\n\n\n// package/xcolor/libs/predefined-colors.ts\n\nvar fromRgb = ([r, g, b]) => color__WEBPACK_IMPORTED_MODULE_10___default()([r * 255, g * 255, b * 255], \"rgb\");\nvar DVI_PS_NAMES = {\n  Apricot: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#FBB982\"),\n  Aquamarine: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#00B5BE\"),\n  Bittersweet: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#C04F17\"),\n  Black: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#221E1F\"),\n  Blue: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#2D2F92\"),\n  BlueGreen: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#00B3B8\"),\n  BlueViolet: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#473992\"),\n  BrickRed: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#B6321C\"),\n  Brown: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#792500\"),\n  BurntOrange: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#F7921D\"),\n  CadetBlue: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#74729A\"),\n  CarnationPink: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#F282B4\"),\n  Cerulean: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#00A2E3\"),\n  CornflowerBlue: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#41B0E4\"),\n  Cyan: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#00AEEF\"),\n  Dandelion: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#FDBC42\"),\n  DarkOrchid: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#A4538A\"),\n  Emerald: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#00A99D\"),\n  ForestGreen: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#009B55\"),\n  Fuchsia: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#8C368C\"),\n  Goldenrod: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#FFDF42\"),\n  Gray: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#949698\"),\n  Green: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#00A64F\"),\n  GreenYellow: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#DFE674\"),\n  JungleGreen: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#00A99A\"),\n  Lavender: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#F49EC4\"),\n  LimeGreen: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#8DC73E\"),\n  Magenta: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#EC008C\"),\n  Mahogany: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#A9341F\"),\n  Maroon: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#AF3235\"),\n  Melon: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#F89E7B\"),\n  MidnightBlue: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#006795\"),\n  Mulberry: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#A93C93\"),\n  NavyBlue: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#006EB8\"),\n  OliveGreen: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#3C8031\"),\n  Orange: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#F58137\"),\n  OrangeRed: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#ED135A\"),\n  Orchid: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#AF72B0\"),\n  Peach: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#F7965A\"),\n  Periwinkle: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#7977B8\"),\n  PineGreen: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#008B72\"),\n  Plum: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#92268F\"),\n  ProcessBlue: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#00B0F0\"),\n  Purple: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#99479B\"),\n  RawSienna: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#974006\"),\n  Red: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#ED1B23\"),\n  RedOrange: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#F26035\"),\n  RedViolet: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#A1246B\"),\n  Rhodamine: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#EF559F\"),\n  RoyalBlue: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#0071BC\"),\n  RoyalPurple: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#613F99\"),\n  RubineRed: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#ED017D\"),\n  Salmon: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#F69289\"),\n  SeaGreen: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#3FBC9D\"),\n  Sepia: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#671800\"),\n  SkyBlue: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#46C5DD\"),\n  SpringGreen: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#C6DC67\"),\n  Tan: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#DA9D76\"),\n  TealBlue: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#00AEB3\"),\n  Thistle: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#D883B7\"),\n  Turquoise: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#00B4CE\"),\n  Violet: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#58429B\"),\n  VioletRed: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#EF58A0\"),\n  White: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#FFFFFF\"),\n  WildStrawberry: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#EE2967\"),\n  Yellow: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#FFF200\"),\n  YellowGreen: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#98CC70\"),\n  YellowOrange: color__WEBPACK_IMPORTED_MODULE_10___default()(\"#FAA21A\")\n};\nvar SVG_NAMES = {\n  AliceBlue: fromRgb([0.94, 0.972, 1]),\n  AntiqueWhite: fromRgb([0.98, 0.92, 0.844]),\n  Aqua: fromRgb([0, 1, 1]),\n  Aquamarine: fromRgb([0.498, 1, 0.83]),\n  Azure: fromRgb([0.94, 1, 1]),\n  Beige: fromRgb([0.96, 0.96, 0.864]),\n  Bisque: fromRgb([1, 0.894, 0.77]),\n  Black: fromRgb([0, 0, 0]),\n  BlanchedAlmond: fromRgb([1, 0.92, 0.804]),\n  Blue: fromRgb([0, 0, 1]),\n  BlueViolet: fromRgb([0.54, 0.17, 0.888]),\n  Brown: fromRgb([0.648, 0.165, 0.165]),\n  BurlyWood: fromRgb([0.87, 0.72, 0.53]),\n  CadetBlue: fromRgb([0.372, 0.62, 0.628]),\n  Chartreuse: fromRgb([0.498, 1, 0]),\n  Chocolate: fromRgb([0.824, 0.41, 0.116]),\n  Coral: fromRgb([1, 0.498, 0.312]),\n  CornflowerBlue: fromRgb([0.392, 0.585, 0.93]),\n  Cornsilk: fromRgb([1, 0.972, 0.864]),\n  Crimson: fromRgb([0.864, 0.08, 0.235]),\n  Cyan: fromRgb([0, 1, 1]),\n  DarkBlue: fromRgb([0, 0, 0.545]),\n  DarkCyan: fromRgb([0, 0.545, 0.545]),\n  DarkGoldenrod: fromRgb([0.72, 0.525, 0.044]),\n  DarkGray: fromRgb([0.664, 0.664, 0.664]),\n  DarkGreen: fromRgb([0, 0.392, 0]),\n  DarkGrey: fromRgb([0.664, 0.664, 0.664]),\n  DarkKhaki: fromRgb([0.74, 0.716, 0.42]),\n  DarkMagenta: fromRgb([0.545, 0, 0.545]),\n  DarkOliveGreen: fromRgb([0.332, 0.42, 0.185]),\n  DarkOrange: fromRgb([1, 0.55, 0]),\n  DarkOrchid: fromRgb([0.6, 0.196, 0.8]),\n  DarkRed: fromRgb([0.545, 0, 0]),\n  DarkSalmon: fromRgb([0.912, 0.59, 0.48]),\n  DarkSeaGreen: fromRgb([0.56, 0.736, 0.56]),\n  DarkSlateBlue: fromRgb([0.284, 0.24, 0.545]),\n  DarkSlateGray: fromRgb([0.185, 0.31, 0.31]),\n  DarkSlateGrey: fromRgb([0.185, 0.31, 0.31]),\n  DarkTurquoise: fromRgb([0, 0.808, 0.82]),\n  DarkViolet: fromRgb([0.58, 0, 0.828]),\n  DeepPink: fromRgb([1, 0.08, 0.576]),\n  DeepSkyBlue: fromRgb([0, 0.75, 1]),\n  DimGray: fromRgb([0.41, 0.41, 0.41]),\n  DimGrey: fromRgb([0.41, 0.41, 0.41]),\n  DodgerBlue: fromRgb([0.116, 0.565, 1]),\n  FireBrick: fromRgb([0.698, 0.132, 0.132]),\n  FloralWhite: fromRgb([1, 0.98, 0.94]),\n  ForestGreen: fromRgb([0.132, 0.545, 0.132]),\n  Fuchsia: fromRgb([1, 0, 1]),\n  Gainsboro: fromRgb([0.864, 0.864, 0.864]),\n  GhostWhite: fromRgb([0.972, 0.972, 1]),\n  Gold: fromRgb([1, 0.844, 0]),\n  Goldenrod: fromRgb([0.855, 0.648, 0.125]),\n  Gray: fromRgb([0.5, 0.5, 0.5]),\n  Green: fromRgb([0, 0.5, 0]),\n  GreenYellow: fromRgb([0.68, 1, 0.185]),\n  Grey: fromRgb([0.5, 0.5, 0.5]),\n  Honeydew: fromRgb([0.94, 1, 0.94]),\n  HotPink: fromRgb([1, 0.41, 0.705]),\n  IndianRed: fromRgb([0.804, 0.36, 0.36]),\n  Indigo: fromRgb([0.294, 0, 0.51]),\n  Ivory: fromRgb([1, 1, 0.94]),\n  Khaki: fromRgb([0.94, 0.9, 0.55]),\n  Lavender: fromRgb([0.9, 0.9, 0.98]),\n  LavenderBlush: fromRgb([1, 0.94, 0.96]),\n  LawnGreen: fromRgb([0.488, 0.99, 0]),\n  LemonChiffon: fromRgb([1, 0.98, 0.804]),\n  LightBlue: fromRgb([0.68, 0.848, 0.9]),\n  LightCoral: fromRgb([0.94, 0.5, 0.5]),\n  LightCyan: fromRgb([0.88, 1, 1]),\n  LightGoldenrod: fromRgb([0.933, 0.867, 0.51]),\n  LightGoldenrodYellow: fromRgb([0.98, 0.98, 0.824]),\n  LightGray: fromRgb([0.828, 0.828, 0.828]),\n  LightGreen: fromRgb([0.565, 0.932, 0.565]),\n  LightGrey: fromRgb([0.828, 0.828, 0.828]),\n  LightPink: fromRgb([1, 0.712, 0.756]),\n  LightSalmon: fromRgb([1, 0.628, 0.48]),\n  LightSeaGreen: fromRgb([0.125, 0.698, 0.668]),\n  LightSkyBlue: fromRgb([0.53, 0.808, 0.98]),\n  LightSlateBlue: fromRgb([0.518, 0.44, 1]),\n  LightSlateGray: fromRgb([0.468, 0.532, 0.6]),\n  LightSlateGrey: fromRgb([0.468, 0.532, 0.6]),\n  LightSteelBlue: fromRgb([0.69, 0.77, 0.87]),\n  LightYellow: fromRgb([1, 1, 0.88]),\n  Lime: fromRgb([0, 1, 0]),\n  LimeGreen: fromRgb([0.196, 0.804, 0.196]),\n  Linen: fromRgb([0.98, 0.94, 0.9]),\n  Magenta: fromRgb([1, 0, 1]),\n  Maroon: fromRgb([0.5, 0, 0]),\n  MediumAquamarine: fromRgb([0.4, 0.804, 0.668]),\n  MediumBlue: fromRgb([0, 0, 0.804]),\n  MediumOrchid: fromRgb([0.73, 0.332, 0.828]),\n  MediumPurple: fromRgb([0.576, 0.44, 0.86]),\n  MediumSeaGreen: fromRgb([0.235, 0.7, 0.444]),\n  MediumSlateBlue: fromRgb([0.484, 0.408, 0.932]),\n  MediumSpringGreen: fromRgb([0, 0.98, 0.604]),\n  MediumTurquoise: fromRgb([0.284, 0.82, 0.8]),\n  MediumVioletRed: fromRgb([0.78, 0.084, 0.52]),\n  MidnightBlue: fromRgb([0.098, 0.098, 0.44]),\n  MintCream: fromRgb([0.96, 1, 0.98]),\n  MistyRose: fromRgb([1, 0.894, 0.884]),\n  Moccasin: fromRgb([1, 0.894, 0.71]),\n  NavajoWhite: fromRgb([1, 0.87, 0.68]),\n  Navy: fromRgb([0, 0, 0.5]),\n  NavyBlue: fromRgb([0, 0, 0.5]),\n  OldLace: fromRgb([0.992, 0.96, 0.9]),\n  Olive: fromRgb([0.5, 0.5, 0]),\n  OliveDrab: fromRgb([0.42, 0.556, 0.136]),\n  Orange: fromRgb([1, 0.648, 0]),\n  OrangeRed: fromRgb([1, 0.27, 0]),\n  Orchid: fromRgb([0.855, 0.44, 0.84]),\n  PaleGoldenrod: fromRgb([0.932, 0.91, 0.668]),\n  PaleGreen: fromRgb([0.596, 0.985, 0.596]),\n  PaleTurquoise: fromRgb([0.688, 0.932, 0.932]),\n  PaleVioletRed: fromRgb([0.86, 0.44, 0.576]),\n  PapayaWhip: fromRgb([1, 0.936, 0.835]),\n  PeachPuff: fromRgb([1, 0.855, 0.725]),\n  Peru: fromRgb([0.804, 0.52, 0.248]),\n  Pink: fromRgb([1, 0.752, 0.796]),\n  Plum: fromRgb([0.868, 0.628, 0.868]),\n  PowderBlue: fromRgb([0.69, 0.88, 0.9]),\n  Purple: fromRgb([0.5, 0, 0.5]),\n  Red: fromRgb([1, 0, 0]),\n  RosyBrown: fromRgb([0.736, 0.56, 0.56]),\n  RoyalBlue: fromRgb([0.255, 0.41, 0.884]),\n  SaddleBrown: fromRgb([0.545, 0.27, 0.075]),\n  Salmon: fromRgb([0.98, 0.5, 0.448]),\n  SandyBrown: fromRgb([0.956, 0.644, 0.376]),\n  SeaGreen: fromRgb([0.18, 0.545, 0.34]),\n  Seashell: fromRgb([1, 0.96, 0.932]),\n  Sienna: fromRgb([0.628, 0.32, 0.176]),\n  Silver: fromRgb([0.752, 0.752, 0.752]),\n  SkyBlue: fromRgb([0.53, 0.808, 0.92]),\n  SlateBlue: fromRgb([0.415, 0.352, 0.804]),\n  SlateGray: fromRgb([0.44, 0.5, 0.565]),\n  SlateGrey: fromRgb([0.44, 0.5, 0.565]),\n  Snow: fromRgb([1, 0.98, 0.98]),\n  SpringGreen: fromRgb([0, 1, 0.498]),\n  SteelBlue: fromRgb([0.275, 0.51, 0.705]),\n  Tan: fromRgb([0.824, 0.705, 0.55]),\n  Teal: fromRgb([0, 0.5, 0.5]),\n  Thistle: fromRgb([0.848, 0.75, 0.848]),\n  Tomato: fromRgb([1, 0.39, 0.28]),\n  Turquoise: fromRgb([0.25, 0.88, 0.815]),\n  Violet: fromRgb([0.932, 0.51, 0.932]),\n  VioletRed: fromRgb([0.816, 0.125, 0.565]),\n  Wheat: fromRgb([0.96, 0.87, 0.7]),\n  White: fromRgb([1, 1, 1]),\n  WhiteSmoke: fromRgb([0.96, 0.96, 0.96]),\n  Yellow: fromRgb([1, 1, 0]),\n  YellowGreen: fromRgb([0.604, 0.804, 0.196])\n};\nvar X11_NAMES = {\n  AntiqueWhite1: fromRgb([1, 0.936, 0.86]),\n  AntiqueWhite2: fromRgb([0.932, 0.875, 0.8]),\n  AntiqueWhite3: fromRgb([0.804, 0.752, 0.69]),\n  AntiqueWhite4: fromRgb([0.545, 0.512, 0.47]),\n  Aquamarine1: fromRgb([0.498, 1, 0.83]),\n  Aquamarine2: fromRgb([0.464, 0.932, 0.776]),\n  Aquamarine3: fromRgb([0.4, 0.804, 0.668]),\n  Aquamarine4: fromRgb([0.27, 0.545, 0.455]),\n  Azure1: fromRgb([0.94, 1, 1]),\n  Azure2: fromRgb([0.88, 0.932, 0.932]),\n  Azure3: fromRgb([0.756, 0.804, 0.804]),\n  Azure4: fromRgb([0.512, 0.545, 0.545]),\n  Bisque1: fromRgb([1, 0.894, 0.77]),\n  Bisque2: fromRgb([0.932, 0.835, 0.716]),\n  Bisque3: fromRgb([0.804, 0.716, 0.62]),\n  Bisque4: fromRgb([0.545, 0.49, 0.42]),\n  Blue1: fromRgb([0, 0, 1]),\n  Blue2: fromRgb([0, 0, 0.932]),\n  Blue3: fromRgb([0, 0, 0.804]),\n  Blue4: fromRgb([0, 0, 0.545]),\n  Brown1: fromRgb([1, 0.25, 0.25]),\n  Brown2: fromRgb([0.932, 0.23, 0.23]),\n  Brown3: fromRgb([0.804, 0.2, 0.2]),\n  Brown4: fromRgb([0.545, 0.136, 0.136]),\n  Burlywood1: fromRgb([1, 0.828, 0.608]),\n  Burlywood2: fromRgb([0.932, 0.772, 0.57]),\n  Burlywood3: fromRgb([0.804, 0.668, 0.49]),\n  Burlywood4: fromRgb([0.545, 0.45, 0.332]),\n  CadetBlue1: fromRgb([0.596, 0.96, 1]),\n  CadetBlue2: fromRgb([0.556, 0.898, 0.932]),\n  CadetBlue3: fromRgb([0.48, 0.772, 0.804]),\n  CadetBlue4: fromRgb([0.325, 0.525, 0.545]),\n  Chartreuse1: fromRgb([0.498, 1, 0]),\n  Chartreuse2: fromRgb([0.464, 0.932, 0]),\n  Chartreuse3: fromRgb([0.4, 0.804, 0]),\n  Chartreuse4: fromRgb([0.27, 0.545, 0]),\n  Chocolate1: fromRgb([1, 0.498, 0.14]),\n  Chocolate2: fromRgb([0.932, 0.464, 0.13]),\n  Chocolate3: fromRgb([0.804, 0.4, 0.112]),\n  Chocolate4: fromRgb([0.545, 0.27, 0.075]),\n  Coral1: fromRgb([1, 0.448, 0.336]),\n  Coral2: fromRgb([0.932, 0.415, 0.312]),\n  Coral3: fromRgb([0.804, 0.356, 0.27]),\n  Coral4: fromRgb([0.545, 0.244, 0.185]),\n  Cornsilk1: fromRgb([1, 0.972, 0.864]),\n  Cornsilk2: fromRgb([0.932, 0.91, 0.804]),\n  Cornsilk3: fromRgb([0.804, 0.785, 0.694]),\n  Cornsilk4: fromRgb([0.545, 0.532, 0.47]),\n  Cyan1: fromRgb([0, 1, 1]),\n  Cyan2: fromRgb([0, 0.932, 0.932]),\n  Cyan3: fromRgb([0, 0.804, 0.804]),\n  Cyan4: fromRgb([0, 0.545, 0.545]),\n  DarkGoldenrod1: fromRgb([1, 0.725, 0.06]),\n  DarkGoldenrod2: fromRgb([0.932, 0.68, 0.055]),\n  DarkGoldenrod3: fromRgb([0.804, 0.585, 0.048]),\n  DarkGoldenrod4: fromRgb([0.545, 0.396, 0.03]),\n  DarkOliveGreen1: fromRgb([0.792, 1, 0.44]),\n  DarkOliveGreen2: fromRgb([0.736, 0.932, 0.408]),\n  DarkOliveGreen3: fromRgb([0.635, 0.804, 0.352]),\n  DarkOliveGreen4: fromRgb([0.43, 0.545, 0.24]),\n  DarkOrange1: fromRgb([1, 0.498, 0]),\n  DarkOrange2: fromRgb([0.932, 0.464, 0]),\n  DarkOrange3: fromRgb([0.804, 0.4, 0]),\n  DarkOrange4: fromRgb([0.545, 0.27, 0]),\n  DarkOrchid1: fromRgb([0.75, 0.244, 1]),\n  DarkOrchid2: fromRgb([0.698, 0.228, 0.932]),\n  DarkOrchid3: fromRgb([0.604, 0.196, 0.804]),\n  DarkOrchid4: fromRgb([0.408, 0.132, 0.545]),\n  DarkSeaGreen1: fromRgb([0.756, 1, 0.756]),\n  DarkSeaGreen2: fromRgb([0.705, 0.932, 0.705]),\n  DarkSeaGreen3: fromRgb([0.608, 0.804, 0.608]),\n  DarkSeaGreen4: fromRgb([0.41, 0.545, 0.41]),\n  DarkSlateGray1: fromRgb([0.592, 1, 1]),\n  DarkSlateGray2: fromRgb([0.552, 0.932, 0.932]),\n  DarkSlateGray3: fromRgb([0.475, 0.804, 0.804]),\n  DarkSlateGray4: fromRgb([0.32, 0.545, 0.545]),\n  DeepPink1: fromRgb([1, 0.08, 0.576]),\n  DeepPink2: fromRgb([0.932, 0.07, 0.536]),\n  DeepPink3: fromRgb([0.804, 0.064, 0.464]),\n  DeepPink4: fromRgb([0.545, 0.04, 0.312]),\n  DeepSkyBlue1: fromRgb([0, 0.75, 1]),\n  DeepSkyBlue2: fromRgb([0, 0.698, 0.932]),\n  DeepSkyBlue3: fromRgb([0, 0.604, 0.804]),\n  DeepSkyBlue4: fromRgb([0, 0.408, 0.545]),\n  DodgerBlue1: fromRgb([0.116, 0.565, 1]),\n  DodgerBlue2: fromRgb([0.11, 0.525, 0.932]),\n  DodgerBlue3: fromRgb([0.094, 0.455, 0.804]),\n  DodgerBlue4: fromRgb([0.064, 0.305, 0.545]),\n  Firebrick1: fromRgb([1, 0.19, 0.19]),\n  Firebrick2: fromRgb([0.932, 0.172, 0.172]),\n  Firebrick3: fromRgb([0.804, 0.15, 0.15]),\n  Firebrick4: fromRgb([0.545, 0.1, 0.1]),\n  Gold1: fromRgb([1, 0.844, 0]),\n  Gold2: fromRgb([0.932, 0.79, 0]),\n  Gold3: fromRgb([0.804, 0.68, 0]),\n  Gold4: fromRgb([0.545, 0.46, 0]),\n  Goldenrod1: fromRgb([1, 0.756, 0.145]),\n  Goldenrod2: fromRgb([0.932, 0.705, 0.132]),\n  Goldenrod3: fromRgb([0.804, 0.608, 0.112]),\n  Goldenrod4: fromRgb([0.545, 0.41, 0.08]),\n  Green1: fromRgb([0, 1, 0]),\n  Green2: fromRgb([0, 0.932, 0]),\n  Green3: fromRgb([0, 0.804, 0]),\n  Green4: fromRgb([0, 0.545, 0]),\n  Honeydew1: fromRgb([0.94, 1, 0.94]),\n  Honeydew2: fromRgb([0.88, 0.932, 0.88]),\n  Honeydew3: fromRgb([0.756, 0.804, 0.756]),\n  Honeydew4: fromRgb([0.512, 0.545, 0.512]),\n  HotPink1: fromRgb([1, 0.43, 0.705]),\n  HotPink2: fromRgb([0.932, 0.415, 0.655]),\n  HotPink3: fromRgb([0.804, 0.376, 0.565]),\n  HotPink4: fromRgb([0.545, 0.228, 0.385]),\n  IndianRed1: fromRgb([1, 0.415, 0.415]),\n  IndianRed2: fromRgb([0.932, 0.39, 0.39]),\n  IndianRed3: fromRgb([0.804, 0.332, 0.332]),\n  IndianRed4: fromRgb([0.545, 0.228, 0.228]),\n  Ivory1: fromRgb([1, 1, 0.94]),\n  Ivory2: fromRgb([0.932, 0.932, 0.88]),\n  Ivory3: fromRgb([0.804, 0.804, 0.756]),\n  Ivory4: fromRgb([0.545, 0.545, 0.512]),\n  Khaki1: fromRgb([1, 0.965, 0.56]),\n  Khaki2: fromRgb([0.932, 0.9, 0.52]),\n  Khaki3: fromRgb([0.804, 0.776, 0.45]),\n  Khaki4: fromRgb([0.545, 0.525, 0.305]),\n  LavenderBlush1: fromRgb([1, 0.94, 0.96]),\n  LavenderBlush2: fromRgb([0.932, 0.88, 0.898]),\n  LavenderBlush3: fromRgb([0.804, 0.756, 0.772]),\n  LavenderBlush4: fromRgb([0.545, 0.512, 0.525]),\n  LemonChiffon1: fromRgb([1, 0.98, 0.804]),\n  LemonChiffon2: fromRgb([0.932, 0.912, 0.75]),\n  LemonChiffon3: fromRgb([0.804, 0.79, 0.648]),\n  LemonChiffon4: fromRgb([0.545, 0.536, 0.44]),\n  LightBlue1: fromRgb([0.75, 0.936, 1]),\n  LightBlue2: fromRgb([0.698, 0.875, 0.932]),\n  LightBlue3: fromRgb([0.604, 0.752, 0.804]),\n  LightBlue4: fromRgb([0.408, 0.512, 0.545]),\n  LightCyan1: fromRgb([0.88, 1, 1]),\n  LightCyan2: fromRgb([0.82, 0.932, 0.932]),\n  LightCyan3: fromRgb([0.705, 0.804, 0.804]),\n  LightCyan4: fromRgb([0.48, 0.545, 0.545]),\n  LightGoldenrod1: fromRgb([1, 0.925, 0.545]),\n  LightGoldenrod2: fromRgb([0.932, 0.864, 0.51]),\n  LightGoldenrod3: fromRgb([0.804, 0.745, 0.44]),\n  LightGoldenrod4: fromRgb([0.545, 0.505, 0.298]),\n  LightPink1: fromRgb([1, 0.684, 0.725]),\n  LightPink2: fromRgb([0.932, 0.635, 0.68]),\n  LightPink3: fromRgb([0.804, 0.55, 0.585]),\n  LightPink4: fromRgb([0.545, 0.372, 0.396]),\n  LightSalmon1: fromRgb([1, 0.628, 0.48]),\n  LightSalmon2: fromRgb([0.932, 0.585, 0.448]),\n  LightSalmon3: fromRgb([0.804, 0.505, 0.385]),\n  LightSalmon4: fromRgb([0.545, 0.34, 0.26]),\n  LightSkyBlue1: fromRgb([0.69, 0.888, 1]),\n  LightSkyBlue2: fromRgb([0.644, 0.828, 0.932]),\n  LightSkyBlue3: fromRgb([0.552, 0.712, 0.804]),\n  LightSkyBlue4: fromRgb([0.376, 0.484, 0.545]),\n  LightSteelBlue1: fromRgb([0.792, 0.884, 1]),\n  LightSteelBlue2: fromRgb([0.736, 0.824, 0.932]),\n  LightSteelBlue3: fromRgb([0.635, 0.71, 0.804]),\n  LightSteelBlue4: fromRgb([0.43, 0.484, 0.545]),\n  LightYellow1: fromRgb([1, 1, 0.88]),\n  LightYellow2: fromRgb([0.932, 0.932, 0.82]),\n  LightYellow3: fromRgb([0.804, 0.804, 0.705]),\n  LightYellow4: fromRgb([0.545, 0.545, 0.48]),\n  Magenta1: fromRgb([1, 0, 1]),\n  Magenta2: fromRgb([0.932, 0, 0.932]),\n  Magenta3: fromRgb([0.804, 0, 0.804]),\n  Magenta4: fromRgb([0.545, 0, 0.545]),\n  Maroon1: fromRgb([1, 0.204, 0.7]),\n  Maroon2: fromRgb([0.932, 0.19, 0.655]),\n  Maroon3: fromRgb([0.804, 0.16, 0.565]),\n  Maroon4: fromRgb([0.545, 0.11, 0.385]),\n  MediumOrchid1: fromRgb([0.88, 0.4, 1]),\n  MediumOrchid2: fromRgb([0.82, 0.372, 0.932]),\n  MediumOrchid3: fromRgb([0.705, 0.32, 0.804]),\n  MediumOrchid4: fromRgb([0.48, 0.215, 0.545]),\n  MediumPurple1: fromRgb([0.67, 0.51, 1]),\n  MediumPurple2: fromRgb([0.624, 0.475, 0.932]),\n  MediumPurple3: fromRgb([0.536, 0.408, 0.804]),\n  MediumPurple4: fromRgb([0.365, 0.28, 0.545]),\n  MistyRose1: fromRgb([1, 0.894, 0.884]),\n  MistyRose2: fromRgb([0.932, 0.835, 0.824]),\n  MistyRose3: fromRgb([0.804, 0.716, 0.71]),\n  MistyRose4: fromRgb([0.545, 0.49, 0.484]),\n  NavajoWhite1: fromRgb([1, 0.87, 0.68]),\n  NavajoWhite2: fromRgb([0.932, 0.81, 0.63]),\n  NavajoWhite3: fromRgb([0.804, 0.7, 0.545]),\n  NavajoWhite4: fromRgb([0.545, 0.475, 0.37]),\n  OliveDrab1: fromRgb([0.752, 1, 0.244]),\n  OliveDrab2: fromRgb([0.7, 0.932, 0.228]),\n  OliveDrab3: fromRgb([0.604, 0.804, 0.196]),\n  OliveDrab4: fromRgb([0.41, 0.545, 0.132]),\n  Orange1: fromRgb([1, 0.648, 0]),\n  Orange2: fromRgb([0.932, 0.604, 0]),\n  Orange3: fromRgb([0.804, 0.52, 0]),\n  Orange4: fromRgb([0.545, 0.352, 0]),\n  OrangeRed1: fromRgb([1, 0.27, 0]),\n  OrangeRed2: fromRgb([0.932, 0.25, 0]),\n  OrangeRed3: fromRgb([0.804, 0.215, 0]),\n  OrangeRed4: fromRgb([0.545, 0.145, 0]),\n  Orchid1: fromRgb([1, 0.512, 0.98]),\n  Orchid2: fromRgb([0.932, 0.48, 0.912]),\n  Orchid3: fromRgb([0.804, 0.41, 0.79]),\n  Orchid4: fromRgb([0.545, 0.28, 0.536]),\n  PaleGreen1: fromRgb([0.604, 1, 0.604]),\n  PaleGreen2: fromRgb([0.565, 0.932, 0.565]),\n  PaleGreen3: fromRgb([0.488, 0.804, 0.488]),\n  PaleGreen4: fromRgb([0.33, 0.545, 0.33]),\n  PaleTurquoise1: fromRgb([0.732, 1, 1]),\n  PaleTurquoise2: fromRgb([0.684, 0.932, 0.932]),\n  PaleTurquoise3: fromRgb([0.59, 0.804, 0.804]),\n  PaleTurquoise4: fromRgb([0.4, 0.545, 0.545]),\n  PaleVioletRed1: fromRgb([1, 0.51, 0.67]),\n  PaleVioletRed2: fromRgb([0.932, 0.475, 0.624]),\n  PaleVioletRed3: fromRgb([0.804, 0.408, 0.536]),\n  PaleVioletRed4: fromRgb([0.545, 0.28, 0.365]),\n  PeachPuff1: fromRgb([1, 0.855, 0.725]),\n  PeachPuff2: fromRgb([0.932, 0.796, 0.68]),\n  PeachPuff3: fromRgb([0.804, 0.688, 0.585]),\n  PeachPuff4: fromRgb([0.545, 0.468, 0.396]),\n  Pink1: fromRgb([1, 0.71, 0.772]),\n  Pink2: fromRgb([0.932, 0.664, 0.72]),\n  Pink3: fromRgb([0.804, 0.57, 0.62]),\n  Pink4: fromRgb([0.545, 0.39, 0.424]),\n  Plum1: fromRgb([1, 0.732, 1]),\n  Plum2: fromRgb([0.932, 0.684, 0.932]),\n  Plum3: fromRgb([0.804, 0.59, 0.804]),\n  Plum4: fromRgb([0.545, 0.4, 0.545]),\n  Purple1: fromRgb([0.608, 0.19, 1]),\n  Purple2: fromRgb([0.57, 0.172, 0.932]),\n  Purple3: fromRgb([0.49, 0.15, 0.804]),\n  Purple4: fromRgb([0.332, 0.1, 0.545]),\n  Red1: fromRgb([1, 0, 0]),\n  Red2: fromRgb([0.932, 0, 0]),\n  Red3: fromRgb([0.804, 0, 0]),\n  Red4: fromRgb([0.545, 0, 0]),\n  RosyBrown1: fromRgb([1, 0.756, 0.756]),\n  RosyBrown2: fromRgb([0.932, 0.705, 0.705]),\n  RosyBrown3: fromRgb([0.804, 0.608, 0.608]),\n  RosyBrown4: fromRgb([0.545, 0.41, 0.41]),\n  RoyalBlue1: fromRgb([0.284, 0.464, 1]),\n  RoyalBlue2: fromRgb([0.264, 0.43, 0.932]),\n  RoyalBlue3: fromRgb([0.228, 0.372, 0.804]),\n  RoyalBlue4: fromRgb([0.152, 0.25, 0.545]),\n  Salmon1: fromRgb([1, 0.55, 0.41]),\n  Salmon2: fromRgb([0.932, 0.51, 0.385]),\n  Salmon3: fromRgb([0.804, 0.44, 0.33]),\n  Salmon4: fromRgb([0.545, 0.298, 0.224]),\n  SeaGreen1: fromRgb([0.33, 1, 0.624]),\n  SeaGreen2: fromRgb([0.305, 0.932, 0.58]),\n  SeaGreen3: fromRgb([0.264, 0.804, 0.5]),\n  SeaGreen4: fromRgb([0.18, 0.545, 0.34]),\n  Seashell1: fromRgb([1, 0.96, 0.932]),\n  Seashell2: fromRgb([0.932, 0.898, 0.87]),\n  Seashell3: fromRgb([0.804, 0.772, 0.75]),\n  Seashell4: fromRgb([0.545, 0.525, 0.51]),\n  Sienna1: fromRgb([1, 0.51, 0.28]),\n  Sienna2: fromRgb([0.932, 0.475, 0.26]),\n  Sienna3: fromRgb([0.804, 0.408, 0.224]),\n  Sienna4: fromRgb([0.545, 0.28, 0.15]),\n  SkyBlue1: fromRgb([0.53, 0.808, 1]),\n  SkyBlue2: fromRgb([0.494, 0.752, 0.932]),\n  SkyBlue3: fromRgb([0.424, 0.65, 0.804]),\n  SkyBlue4: fromRgb([0.29, 0.44, 0.545]),\n  SlateBlue1: fromRgb([0.512, 0.435, 1]),\n  SlateBlue2: fromRgb([0.48, 0.404, 0.932]),\n  SlateBlue3: fromRgb([0.41, 0.35, 0.804]),\n  SlateBlue4: fromRgb([0.28, 0.235, 0.545]),\n  SlateGray1: fromRgb([0.776, 0.888, 1]),\n  SlateGray2: fromRgb([0.725, 0.828, 0.932]),\n  SlateGray3: fromRgb([0.624, 0.712, 0.804]),\n  SlateGray4: fromRgb([0.424, 0.484, 0.545]),\n  Snow1: fromRgb([1, 0.98, 0.98]),\n  Snow2: fromRgb([0.932, 0.912, 0.912]),\n  Snow3: fromRgb([0.804, 0.79, 0.79]),\n  Snow4: fromRgb([0.545, 0.536, 0.536]),\n  SpringGreen1: fromRgb([0, 1, 0.498]),\n  SpringGreen2: fromRgb([0, 0.932, 0.464]),\n  SpringGreen3: fromRgb([0, 0.804, 0.4]),\n  SpringGreen4: fromRgb([0, 0.545, 0.27]),\n  SteelBlue1: fromRgb([0.39, 0.72, 1]),\n  SteelBlue2: fromRgb([0.36, 0.675, 0.932]),\n  SteelBlue3: fromRgb([0.31, 0.58, 0.804]),\n  SteelBlue4: fromRgb([0.21, 0.392, 0.545]),\n  Tan1: fromRgb([1, 0.648, 0.31]),\n  Tan2: fromRgb([0.932, 0.604, 0.288]),\n  Tan3: fromRgb([0.804, 0.52, 0.248]),\n  Tan4: fromRgb([0.545, 0.352, 0.17]),\n  Thistle1: fromRgb([1, 0.884, 1]),\n  Thistle2: fromRgb([0.932, 0.824, 0.932]),\n  Thistle3: fromRgb([0.804, 0.71, 0.804]),\n  Thistle4: fromRgb([0.545, 0.484, 0.545]),\n  Tomato1: fromRgb([1, 0.39, 0.28]),\n  Tomato2: fromRgb([0.932, 0.36, 0.26]),\n  Tomato3: fromRgb([0.804, 0.31, 0.224]),\n  Tomato4: fromRgb([0.545, 0.21, 0.15]),\n  Turquoise1: fromRgb([0, 0.96, 1]),\n  Turquoise2: fromRgb([0, 0.898, 0.932]),\n  Turquoise3: fromRgb([0, 0.772, 0.804]),\n  Turquoise4: fromRgb([0, 0.525, 0.545]),\n  VioletRed1: fromRgb([1, 0.244, 0.59]),\n  VioletRed2: fromRgb([0.932, 0.228, 0.55]),\n  VioletRed3: fromRgb([0.804, 0.196, 0.47]),\n  VioletRed4: fromRgb([0.545, 0.132, 0.32]),\n  Wheat1: fromRgb([1, 0.905, 0.73]),\n  Wheat2: fromRgb([0.932, 0.848, 0.684]),\n  Wheat3: fromRgb([0.804, 0.73, 0.59]),\n  Wheat4: fromRgb([0.545, 0.494, 0.4]),\n  Yellow1: fromRgb([1, 1, 0]),\n  Yellow2: fromRgb([0.932, 0.932, 0]),\n  Yellow3: fromRgb([0.804, 0.804, 0]),\n  Yellow4: fromRgb([0.545, 0.545, 0]),\n  Gray0: fromRgb([0.745, 0.745, 0.745]),\n  Green0: fromRgb([0, 1, 0]),\n  Grey0: fromRgb([0.745, 0.745, 0.745]),\n  Maroon0: fromRgb([0.69, 0.19, 0.376]),\n  Purple0: fromRgb([0.628, 0.125, 0.94])\n};\n\n// package/xcolor/libs/parser.ts\n\n\n// package/xcolor/libs/xcolor.ts\nvar XColorCoreModelToColor = {\n  rgb: ([r, g, b]) => color__WEBPACK_IMPORTED_MODULE_10___default()([r * 255, g * 255, b * 255], \"rgb\"),\n  cmy: ([c, m, y]) => XColorCoreModelToColor.rgb([1 - c, 1 - m, 1 - y]),\n  cmyk: ([c, m, y, k]) => color__WEBPACK_IMPORTED_MODULE_10___default()([c * 255, m * 255, y * 255, k * 100], \"cmyk\"),\n  hsb: ([h, s, b]) => color__WEBPACK_IMPORTED_MODULE_10___default()([h * 360, s * 100, b * 100], \"hsv\"),\n  gray: ([v]) => color__WEBPACK_IMPORTED_MODULE_10___default()([v * 255, v * 255, v * 255], \"rgb\")\n};\nvar XColorModelToColor = __spreadValues({\n  wave: ([lambda]) => {\n    const gamma = 0.8;\n    let baseRgb = [0, 0, 0];\n    if (380 <= lambda && lambda < 440) {\n      baseRgb = [(440 - lambda) / (440 - 380), 0, 1];\n    }\n    if (440 <= lambda && lambda < 490) {\n      baseRgb = [0, (lambda - 440) / (490 - 440), 1];\n    }\n    if (490 <= lambda && lambda < 510) {\n      baseRgb = [0, 1, (510 - lambda) / (510 - 490)];\n    }\n    if (510 <= lambda && lambda < 580) {\n      baseRgb = [(lambda - 510) / (580 - 510), 1, 0];\n    }\n    if (580 <= lambda && lambda < 6450) {\n      baseRgb = [1, (645 - lambda) / (645 - 580), 0];\n    }\n    if (645 <= lambda && lambda <= 780) {\n      baseRgb = [1, 0, 0];\n    }\n    let f = 1;\n    if (380 <= lambda && 420 < lambda) {\n      f = 0.3 + 0.7 * (lambda - 380) / (420 - 380);\n    }\n    if (700 < lambda && lambda <= 780) {\n      f = 0.3 + 0.7 * (780 - lambda) / (780 - 700);\n    }\n    const rgb = [\n      Math.pow(baseRgb[0] * f, gamma),\n      Math.pow(baseRgb[1] * f, gamma),\n      Math.pow(baseRgb[2] * f, gamma)\n    ];\n    return color__WEBPACK_IMPORTED_MODULE_10___default()([rgb[0] * 255, rgb[1] * 255, rgb[2] * 255], \"rgb\");\n  },\n  Hsb: ([h, s, b]) => XColorCoreModelToColor.hsb([h / 360, s, b]),\n  HSB: ([h, s, b]) => XColorCoreModelToColor.hsb([h / 240, s / 240, b / 240]),\n  HTML: ([v]) => v.startsWith(\"#\") ? color__WEBPACK_IMPORTED_MODULE_10___default()(v) : color__WEBPACK_IMPORTED_MODULE_10___default()(`#${v}`),\n  RGB: ([r, g, b]) => color__WEBPACK_IMPORTED_MODULE_10___default()([r, g, b], \"rgb\"),\n  Gray: ([v]) => XColorCoreModelToColor.gray([v / 15])\n}, XColorCoreModelToColor);\nvar PREDEFINED_XCOLOR_COLORS = __spreadValues(__spreadValues(__spreadValues({\n  red: XColorCoreModelToColor.rgb([1, 0, 0]),\n  green: XColorCoreModelToColor.rgb([0, 1, 0]),\n  blue: XColorCoreModelToColor.rgb([0, 0, 1]),\n  brown: XColorCoreModelToColor.rgb([0.75, 0.5, 0.25]),\n  lime: XColorCoreModelToColor.rgb([0.75, 1, 0]),\n  orange: XColorCoreModelToColor.rgb([1, 0.5, 0]),\n  pink: XColorCoreModelToColor.rgb([1, 0.75, 0.75]),\n  purple: XColorCoreModelToColor.rgb([0.75, 0, 0.25]),\n  teal: XColorCoreModelToColor.rgb([0, 0.5, 0.5]),\n  violet: XColorCoreModelToColor.rgb([0.5, 0, 0.5]),\n  cyan: XColorCoreModelToColor.rgb([0, 1, 1]),\n  magenta: XColorCoreModelToColor.rgb([1, 0, 1]),\n  yellow: XColorCoreModelToColor.rgb([1, 1, 0]),\n  olive: XColorCoreModelToColor.rgb([0.5, 0.5, 0]),\n  black: XColorCoreModelToColor.rgb([0, 0, 0]),\n  darkgray: XColorCoreModelToColor.rgb([0.25, 0.25, 0.25]),\n  gray: XColorCoreModelToColor.rgb([0.5, 0.5, 0.5]),\n  lightgray: XColorCoreModelToColor.rgb([0.75, 0.75, 0.75]),\n  white: XColorCoreModelToColor.rgb([1, 1, 1])\n}, DVI_PS_NAMES), SVG_NAMES), X11_NAMES);\n\n// package/xcolor/libs/xcolor-macro-to-hex.ts\n\n\n\n\n// package/xcolor/libs/color-to-textcolor-macro.ts\n\n\n// package/xparse/provides.ts\nvar macros12 = {\n  NewDocumentCommand: {\n    signature: \"m m m\",\n    renderInfo: { breakAround: true }\n  },\n  RenewDocumentCommand: {\n    signature: \"m m m\",\n    renderInfo: { breakAround: true }\n  },\n  ProvideDocumentCommand: {\n    signature: \"m m m\",\n    renderInfo: { breakAround: true }\n  },\n  DeclareDocumentCommand: {\n    signature: \"m m m\",\n    renderInfo: { breakAround: true }\n  },\n  NewDocumentEnvironment: {\n    signature: \"m m m m\",\n    renderInfo: { breakAround: true }\n  },\n  RenewDocumentEnvironment: {\n    signature: \"m m m m\",\n    renderInfo: { breakAround: true }\n  },\n  ProvideDocumentEnvironment: {\n    signature: \"m m m m\",\n    renderInfo: { breakAround: true }\n  },\n  DeclareDocumentEnvironment: {\n    signature: \"m m m m\",\n    renderInfo: { breakAround: true }\n  },\n  NewExpandableDocumentCommand: {\n    signature: \"m m m\",\n    renderInfo: { breakAround: true }\n  },\n  RenewExpandableDocumentCommand: {\n    signature: \"m m m\",\n    renderInfo: { breakAround: true }\n  },\n  ProvideExpandableDocumentCommand: {\n    signature: \"m m m\",\n    renderInfo: { breakAround: true }\n  },\n  DeclareExpandableDocumentCommand: {\n    signature: \"m m m\",\n    renderInfo: { breakAround: true }\n  },\n  RequirePackage: {\n    signature: \"o m\",\n    renderInfo: { pgfkeysArgs: true, breakAround: true }\n  },\n  DeclareOption: { signature: \"m m\", renderInfo: { breakAround: true } }\n};\nvar environments12 = {};\n\n// index.ts\nvar macroInfo = {\n  cleveref: macros,\n  exam: macros2,\n  geometry: macros3,\n  hyperref: macros4,\n  latex2e: macros5,\n  makeidx: macros6,\n  mathtools: macros7,\n  nicematrix: macros8,\n  systeme: macros9,\n  tikz: macros10,\n  xcolor: macros11,\n  xparse: macros12\n};\nvar environmentInfo = {\n  cleveref: environments,\n  exam: environments2,\n  geometry: environments3,\n  hyperref: environments4,\n  latex2e: environments5,\n  makeidx: environments6,\n  mathtools: environments7,\n  nicematrix: environments8,\n  systeme: environments9,\n  tikz: environments10,\n  xcolor: environments11,\n  xparse: environments12\n};\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-ctan/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-util-argspec/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-util-argspec/index.js ***!
  \*************************************************************************/
/*! exports provided: ArgSpecAst, parse, printRaw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArgSpecAst\", function() { return argspec_types_exports; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"printRaw\", function() { return printRaw; });\n/* harmony import */ var _unified_latex_unified_latex_util_pegjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @unified-latex/unified-latex-util-pegjs */ \"./node_modules/@unified-latex/unified-latex-util-pegjs/index.js\");\n// libs/argspec-parser.ts\n\nfunction getDecorators(node) {\n  let ret = \"\";\n  if (node.noLeadingWhitespace) {\n    ret += \"!\";\n  }\n  return ret;\n}\nfunction printRaw(node, root = false) {\n  if (typeof node === \"string\") {\n    return node;\n  }\n  if (Array.isArray(node)) {\n    const sepToken = root ? \" \" : \"\";\n    return node.map((tok) => printRaw(tok)).join(sepToken);\n  }\n  const decorators = getDecorators(node);\n  const defaultArg = node.defaultArg ? printRaw(node.defaultArg) : \"\";\n  let spec = decorators;\n  switch (node.type) {\n    case \"body\":\n      return decorators + \"b\";\n    case \"optionalStar\":\n      return decorators + \"s\";\n    case \"optionalToken\":\n      return spec + \"t\" + node.token;\n    case \"optional\":\n      if (node.openBrace === \"[\" && node.closeBrace === \"]\") {\n        spec += node.defaultArg ? \"O\" : \"o\";\n      } else {\n        spec += node.defaultArg ? \"D\" : \"d\";\n        spec += node.openBrace + node.closeBrace;\n      }\n      return spec + defaultArg;\n    case \"mandatory\":\n      if (node.openBrace === \"{\" && node.closeBrace === \"}\") {\n        spec += \"m\";\n      } else {\n        spec += node.defaultArg ? \"R\" : \"r\";\n        spec += node.openBrace + node.closeBrace;\n      }\n      return spec + defaultArg;\n    case \"embellishment\":\n      spec += node.defaultArg ? \"E\" : \"e\";\n      return spec + \"{\" + printRaw(node.embellishmentTokens) + \"}\" + defaultArg;\n    case \"verbatim\":\n      return spec + \"v\" + node.openBrace;\n    case \"group\":\n      return spec + \"{\" + printRaw(node.content) + \"}\";\n    default:\n      console.warn(`Unknown node type \"${node.type}\" for node`, node);\n      return \"\";\n  }\n}\nvar parseCache = {};\nfunction parse(str = \"\") {\n  parseCache[str] = parseCache[str] || _unified_latex_unified_latex_util_pegjs__WEBPACK_IMPORTED_MODULE_0__[\"ArgSpecPegParser\"].parse(str);\n  return parseCache[str];\n}\n\n// libs/argspec-types.ts\nvar argspec_types_exports = {};\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-util-argspec/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-util-arguments/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-util-arguments/index.js ***!
  \***************************************************************************/
/*! exports provided: attachMacroArgs, attachMacroArgsInArray, getArgsContent, gobbleArguments, unifiedLatexAttachMacroArguments */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attachMacroArgs\", function() { return attachMacroArgs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attachMacroArgsInArray\", function() { return attachMacroArgsInArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getArgsContent\", function() { return getArgsContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gobbleArguments\", function() { return gobbleArguments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unifiedLatexAttachMacroArguments\", function() { return unifiedLatexAttachMacroArguments; });\n/* harmony import */ var _unified_latex_unified_latex_util_argspec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @unified-latex/unified-latex-util-argspec */ \"./node_modules/@unified-latex/unified-latex-util-argspec/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_builder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @unified-latex/unified-latex-builder */ \"./node_modules/@unified-latex/unified-latex-builder/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @unified-latex/unified-latex-util-match */ \"./node_modules/@unified-latex/unified-latex-util-match/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_render_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @unified-latex/unified-latex-util-render-info */ \"./node_modules/@unified-latex/unified-latex-util-render-info/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @unified-latex/unified-latex-util-visit */ \"./node_modules/@unified-latex/unified-latex-util-visit/index.js\");\n// libs/gobble-arguments.ts\n\n\n\n// libs/gobble-single-argument.ts\n\n\nfunction gobbleSingleArgument(nodes, argSpec, startPos = 0) {\n  if (typeof argSpec === \"string\" || !argSpec.type) {\n    throw new Error(`argSpec must be an already-parsed argument specification, not \"${JSON.stringify(argSpec)}\"`);\n  }\n  let argument = null;\n  let currPos = startPos;\n  const gobbleWhitespace = argSpec.noLeadingWhitespace ? () => {\n  } : () => {\n    while (currPos < nodes.length) {\n      if (!_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_2__[\"match\"].whitespace(nodes[currPos])) {\n        break;\n      }\n      currPos++;\n    }\n  };\n  const openMark = argSpec.openBrace || \"\";\n  const closeMark = argSpec.closeBrace || \"\";\n  const acceptGroup = argSpec.type === \"mandatory\" && openMark === \"{\" && closeMark === \"}\";\n  function findBracePositions() {\n    let openMarkPos = null;\n    if (openMark) {\n      openMarkPos = nodes.findIndex((node, i) => i >= currPos && _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_2__[\"match\"].string(node, openMark));\n      if (openMarkPos < currPos) {\n        openMarkPos = null;\n      }\n    }\n    let closeMarkPos = null;\n    if (openMarkPos != null) {\n      closeMarkPos = nodes.findIndex((node, i) => i >= openMarkPos + 1 && _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_2__[\"match\"].string(node, closeMark));\n      if (closeMarkPos < openMarkPos + 1) {\n        closeMarkPos = null;\n      }\n    }\n    return [openMarkPos, closeMarkPos];\n  }\n  gobbleWhitespace();\n  const currNode = nodes[currPos];\n  if (currNode == null || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_2__[\"match\"].comment(currNode) || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_2__[\"match\"].parbreak(currNode)) {\n    return { argument, nodesRemoved: 0 };\n  }\n  switch (argSpec.type) {\n    case \"mandatory\":\n      if (acceptGroup) {\n        let content = [currNode];\n        if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_2__[\"match\"].group(currNode)) {\n          content = currNode.content;\n        }\n        argument = Object(_unified_latex_unified_latex_builder__WEBPACK_IMPORTED_MODULE_1__[\"arg\"])(content, {\n          openMark,\n          closeMark\n        });\n        currPos++;\n        break;\n      }\n    case \"optional\":\n      if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_2__[\"match\"].string(currNode, openMark)) {\n        const [openMarkPos, closeMarkPos] = findBracePositions();\n        if (openMarkPos != null && closeMarkPos != null) {\n          argument = Object(_unified_latex_unified_latex_builder__WEBPACK_IMPORTED_MODULE_1__[\"arg\"])(nodes.slice(openMarkPos + 1, closeMarkPos), {\n            openMark,\n            closeMark\n          });\n          currPos = closeMarkPos + 1;\n          break;\n        }\n      }\n      break;\n    case \"optionalStar\":\n      if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_2__[\"match\"].string(currNode, \"*\")) {\n        argument = Object(_unified_latex_unified_latex_builder__WEBPACK_IMPORTED_MODULE_1__[\"arg\"])([currNode], { openMark: \"\", closeMark: \"\" });\n        currPos++;\n        break;\n      }\n      break;\n    default:\n      console.warn(`Don't know how to find an argument of argspec type \"${argSpec.type}\"`);\n  }\n  const nodesRemoved = argument ? currPos - startPos : 0;\n  nodes.splice(startPos, nodesRemoved);\n  return { argument, nodesRemoved };\n}\n\n// libs/gobble-arguments.ts\nfunction gobbleArguments(nodes, argSpec, startPos = 0) {\n  if (typeof argSpec === \"string\") {\n    argSpec = Object(_unified_latex_unified_latex_util_argspec__WEBPACK_IMPORTED_MODULE_0__[\"parse\"])(argSpec);\n  }\n  const args = [];\n  let nodesRemoved = 0;\n  for (const spec of argSpec) {\n    const { argument, nodesRemoved: removed } = gobbleSingleArgument(nodes, spec, startPos);\n    if (argument) {\n      args.push(argument);\n      nodesRemoved += removed;\n    } else {\n      args.push(Object(_unified_latex_unified_latex_builder__WEBPACK_IMPORTED_MODULE_1__[\"arg\"])([], { openMark: \"\", closeMark: \"\" }));\n    }\n  }\n  return { args, nodesRemoved };\n}\n\n// libs/attach-arguments.ts\n\n\n\nfunction attachMacroArgsInArray(nodes, macros) {\n  let currIndex;\n  const isRelevantMacro = _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_2__[\"match\"].createMacroMatcher(macros);\n  function gobbleUntilMacro() {\n    while (currIndex >= 0 && !isRelevantMacro(nodes[currIndex])) {\n      currIndex--;\n    }\n  }\n  currIndex = nodes.length - 1;\n  while (currIndex >= 0) {\n    gobbleUntilMacro();\n    if (currIndex < 0) {\n      return;\n    }\n    const macroIndex = currIndex;\n    const macro = nodes[macroIndex];\n    const macroName = macro.content;\n    const macroInfo = macros[macroName];\n    Object(_unified_latex_unified_latex_util_render_info__WEBPACK_IMPORTED_MODULE_3__[\"updateRenderInfo\"])(macro, macroInfo.renderInfo);\n    if (macroInfo.signature == null) {\n      currIndex--;\n      continue;\n    }\n    if (macro.args != null) {\n      currIndex = macroIndex - 1;\n      continue;\n    }\n    currIndex++;\n    const { args } = gobbleArguments(nodes, macroInfo.signature, currIndex);\n    macro.args = args;\n    currIndex = macroIndex - 1;\n  }\n}\nfunction attachMacroArgs(tree, macros) {\n  Object(_unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_4__[\"visit\"])(tree, (nodes) => {\n    attachMacroArgsInArray(nodes, macros);\n  }, { includeArrays: true, test: Array.isArray });\n}\n\n// libs/unified-latex-attach-macro-arguments.ts\n\nvar unifiedLatexAttachMacroArguments = function unifiedLatexAttachMacroArguments2(options) {\n  return (tree) => {\n    const { macros = {} } = options || {};\n    if (Object.keys(macros).length === 0) {\n      console.warn(\"Attempting to attach macro arguments but no macros are specified.\");\n    }\n    Object(_unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_4__[\"visit\"])(tree, (nodes) => {\n      attachMacroArgsInArray(nodes, macros);\n    }, { includeArrays: true, test: Array.isArray });\n  };\n};\n\n// libs/get-args-content.ts\nfunction getArgsContent(node) {\n  if (!Array.isArray(node.args)) {\n    return [];\n  }\n  return node.args.map((arg3) => {\n    if (arg3.openMark === \"\" && arg3.content.length === 0) {\n      return null;\n    }\n    return arg3.content;\n  });\n}\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-util-arguments/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-util-comments/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-util-comments/index.js ***!
  \**************************************************************************/
/*! exports provided: deleteComments */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deleteComments\", function() { return deleteComments; });\n/* harmony import */ var _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @unified-latex/unified-latex-util-match */ \"./node_modules/@unified-latex/unified-latex-util-match/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_replace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @unified-latex/unified-latex-util-replace */ \"./node_modules/@unified-latex/unified-latex-util-replace/index.js\");\n// libs/delete-comments.ts\n\n\nfunction deleteComments(ast) {\n  return Object(_unified_latex_unified_latex_util_replace__WEBPACK_IMPORTED_MODULE_1__[\"replaceNode\"])(ast, (node) => {\n    if (!_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].comment(node)) {\n      return;\n    }\n    if (node.leadingWhitespace) {\n      return { type: \"whitespace\" };\n    }\n    return null;\n  });\n}\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-util-comments/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-util-environments/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-util-environments/index.js ***!
  \******************************************************************************/
/*! exports provided: processEnvironment, processEnvironments, unifiedLatexProcessEnvironments */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"processEnvironment\", function() { return processEnvironment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"processEnvironments\", function() { return processEnvironments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unifiedLatexProcessEnvironments\", function() { return unifiedLatexProcessEnvironments; });\n/* harmony import */ var _unified_latex_unified_latex_util_render_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @unified-latex/unified-latex-util-render-info */ \"./node_modules/@unified-latex/unified-latex-util-render-info/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_arguments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @unified-latex/unified-latex-util-arguments */ \"./node_modules/@unified-latex/unified-latex-util-arguments/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @unified-latex/unified-latex-util-match */ \"./node_modules/@unified-latex/unified-latex-util-match/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @unified-latex/unified-latex-util-visit */ \"./node_modules/@unified-latex/unified-latex-util-visit/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @unified-latex/unified-latex-util-print-raw */ \"./node_modules/@unified-latex/unified-latex-util-print-raw/index.js\");\n// libs/process-environment.ts\n\n\n\n\n\nfunction processEnvironment(envNode, envInfo) {\n  if (envInfo.signature && envNode.args == null) {\n    const { args } = Object(_unified_latex_unified_latex_util_arguments__WEBPACK_IMPORTED_MODULE_1__[\"gobbleArguments\"])(envNode.content, envInfo.signature);\n    envNode.args = args;\n  }\n  Object(_unified_latex_unified_latex_util_render_info__WEBPACK_IMPORTED_MODULE_0__[\"updateRenderInfo\"])(envNode, envInfo.renderInfo);\n  if (typeof envInfo.processContent === \"function\") {\n    envNode.content = envInfo.processContent(envNode.content);\n  }\n}\nfunction processEnvironments(tree, environments) {\n  const isRelevantEnvironment = _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_2__[\"match\"].createEnvironmentMatcher(environments);\n  Object(_unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_3__[\"visit\"])(tree, {\n    leave: (node) => {\n      const envName = Object(_unified_latex_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_4__[\"printRaw\"])(node.env);\n      const envInfo = environments[envName];\n      if (!envInfo) {\n        throw new Error(`Could not find environment info for environment \"${envName}\"`);\n      }\n      processEnvironment(node, envInfo);\n    }\n  }, { test: isRelevantEnvironment });\n}\n\n// libs/unified-latex-process-environment.ts\n\n\n\nvar unifiedLatexProcessEnvironments = function unifiedLatexAttachMacroArguments(options) {\n  const { environments = {} } = options || {};\n  const isRelevantEnvironment = _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_2__[\"match\"].createEnvironmentMatcher(environments);\n  return (tree) => {\n    if (Object.keys(environments).length === 0) {\n      console.warn(\"Attempting to attach macro arguments but no macros are specified.\");\n    }\n    Object(_unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_3__[\"visit\"])(tree, {\n      leave: (node) => {\n        const envName = Object(_unified_latex_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_4__[\"printRaw\"])(node.env);\n        const envInfo = environments[envName];\n        if (!envInfo) {\n          throw new Error(`Could not find environment info for environment \"${envName}\"`);\n        }\n        processEnvironment(node, envInfo);\n      }\n    }, { test: isRelevantEnvironment });\n  };\n};\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-util-environments/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-util-match/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-util-match/index.js ***!
  \***********************************************************************/
/*! exports provided: anyEnvironment, anyMacro, anyString, argument, blankArgument, comment, environment, group, macro, match, math, parbreak, string, whitespace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"anyEnvironment\", function() { return anyEnvironment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"anyMacro\", function() { return anyMacro; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"anyString\", function() { return anyString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"argument\", function() { return argument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"blankArgument\", function() { return blankArgument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"comment\", function() { return comment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"environment\", function() { return environment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"group\", function() { return group; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"macro\", function() { return macro; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"match\", function() { return match; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"math\", function() { return math; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parbreak\", function() { return parbreak; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"string\", function() { return string; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"whitespace\", function() { return whitespace; });\n/* harmony import */ var _unified_latex_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @unified-latex/unified-latex-util-print-raw */ \"./node_modules/@unified-latex/unified-latex-util-print-raw/index.js\");\n// libs/match.ts\n\nfunction createMacroMatcher(macros) {\n  const macrosHash = Array.isArray(macros) ? macros.length > 0 ? typeof macros[0] === \"string\" ? Object.fromEntries(macros.map((macro2) => {\n    if (typeof macro2 !== \"string\") {\n      throw new Error(\"Wrong branch of map function\");\n    }\n    return [macro2, {}];\n  })) : Object.fromEntries(macros.map((macro2) => {\n    if (typeof macro2 === \"string\") {\n      throw new Error(\"Wrong branch of map function\");\n    }\n    if (macro2.escapeToken != null) {\n      return [\n        macro2.content,\n        { escapeToken: macro2.escapeToken }\n      ];\n    }\n    return [macro2.content, {}];\n  })) : {} : macros;\n  return function matchAgainstMacros(node) {\n    if (node == null || node.type !== \"macro\") {\n      return false;\n    }\n    const spec = macrosHash[node.content];\n    if (!spec) {\n      return false;\n    }\n    if (typeof spec === \"object\" && \"escapeToken\" in spec) {\n      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;\n    }\n    return true;\n  };\n}\nfunction createEnvironmentMatcher(macros) {\n  const environmentsHash = Array.isArray(macros) ? Object.fromEntries(macros.map((str) => {\n    return [str, {}];\n  })) : macros;\n  return function matchAgainstEnvironments(node) {\n    if (!match.anyEnvironment(node)) {\n      return false;\n    }\n    const envName = Object(_unified_latex_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__[\"printRaw\"])(node.env);\n    const spec = environmentsHash[envName];\n    if (!spec) {\n      return false;\n    }\n    return true;\n  };\n}\nvar match = {\n  macro(node, macroName) {\n    if (node == null) {\n      return false;\n    }\n    return node.type === \"macro\" && (macroName == null || node.content === macroName);\n  },\n  anyMacro(node) {\n    return match.macro(node);\n  },\n  environment(node, envName) {\n    if (node == null) {\n      return false;\n    }\n    return (node.type === \"environment\" || node.type === \"mathenv\") && (envName == null || Object(_unified_latex_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__[\"printRaw\"])(node.env) === envName);\n  },\n  anyEnvironment(node) {\n    return match.environment(node);\n  },\n  comment(node) {\n    if (node == null) {\n      return false;\n    }\n    return node.type === \"comment\";\n  },\n  parbreak(node) {\n    if (node == null) {\n      return false;\n    }\n    return node.type === \"parbreak\";\n  },\n  whitespace(node) {\n    if (node == null) {\n      return false;\n    }\n    return node.type === \"whitespace\";\n  },\n  whitespaceLike(node) {\n    if (node == null) {\n      return false;\n    }\n    return node.type === \"whitespace\" || node.type === \"whitespace\" && node.leadingWhitespace === true;\n  },\n  string(node, value) {\n    if (node == null) {\n      return false;\n    }\n    return node.type === \"string\" && (value == null || node.content === value);\n  },\n  anyString(node) {\n    return match.string(node);\n  },\n  group(node) {\n    if (node == null) {\n      return false;\n    }\n    return node.type === \"group\";\n  },\n  argument(node) {\n    if (node == null) {\n      return false;\n    }\n    return node.type === \"argument\";\n  },\n  blankArgument(node) {\n    if (!match.argument(node)) {\n      return false;\n    }\n    return node.openMark === \"\" && node.closeMark === \"\" && node.content.length === 0;\n  },\n  math(node) {\n    if (node == null) {\n      return false;\n    }\n    return node.type === \"displaymath\" || node.type === \"inlinemath\";\n  },\n  createMacroMatcher,\n  createEnvironmentMatcher\n};\n\n// index.ts\nvar {\n  anyEnvironment,\n  anyMacro,\n  anyString,\n  argument,\n  blankArgument,\n  comment,\n  environment,\n  group,\n  macro,\n  math,\n  parbreak,\n  string,\n  whitespace\n} = match;\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-util-match/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-util-parse/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-util-parse/index.js ***!
  \***********************************************************************/
/*! exports provided: parse, parseMath, parseMathMinimal, parseMinimal, unifiedLatexAstComplier, unifiedLatexFromString, unifiedLatexFromStringMinimal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseMath\", function() { return parseMath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseMathMinimal\", function() { return parseMathMinimal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseMinimal\", function() { return parseMinimal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unifiedLatexAstComplier\", function() { return unifiedLatexAstComplier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unifiedLatexFromString\", function() { return unifiedLatexFromString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unifiedLatexFromStringMinimal\", function() { return unifiedLatexFromStringMinimal; });\n/* harmony import */ var unified__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unified */ \"./node_modules/unified/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_ctan__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @unified-latex/unified-latex-ctan */ \"./node_modules/@unified-latex/unified-latex-ctan/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @unified-latex/unified-latex-util-trim */ \"./node_modules/@unified-latex/unified-latex-util-trim/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_pegjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @unified-latex/unified-latex-util-pegjs */ \"./node_modules/@unified-latex/unified-latex-util-pegjs/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @unified-latex/unified-latex-util-visit */ \"./node_modules/@unified-latex/unified-latex-util-visit/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @unified-latex/unified-latex-util-match */ \"./node_modules/@unified-latex/unified-latex-util-match/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @unified-latex/unified-latex-util-print-raw */ \"./node_modules/@unified-latex/unified-latex-util-print-raw/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_arguments__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @unified-latex/unified-latex-util-arguments */ \"./node_modules/@unified-latex/unified-latex-util-arguments/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_environments__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @unified-latex/unified-latex-util-environments */ \"./node_modules/@unified-latex/unified-latex-util-environments/index.js\");\n// libs/compiler-ast.ts\nvar unifiedLatexAstComplier = function unifiedLatexAstComplier2() {\n  Object.assign(this, { Compiler: (x) => x });\n};\n\n// libs/plugin-from-string.ts\n\n\n\n\n// libs/parse-minimal.ts\n\nfunction parseMinimal(str) {\n  return _unified_latex_unified_latex_util_pegjs__WEBPACK_IMPORTED_MODULE_3__[\"LatexPegParser\"].parse(str);\n}\nfunction parseMathMinimal(str) {\n  return _unified_latex_unified_latex_util_pegjs__WEBPACK_IMPORTED_MODULE_3__[\"LatexPegParser\"].parse(str, { startRule: \"math\" });\n}\n\n// libs/plugin-from-string-minimal.ts\nvar unifiedLatexFromStringMinimal = function unifiedLatexFromStringMinimal2(options) {\n  const parser2 = (str) => {\n    if ((options == null ? void 0 : options.mode) === \"math\") {\n      return {\n        type: \"root\",\n        content: parseMathMinimal(str),\n        _renderInfo: { inMathMode: true }\n      };\n    }\n    return parseMinimal(str);\n  };\n  Object.assign(this, { Parser: parser2 });\n};\n\n// libs/process-macros-and-environments.ts\n\n\n\n\n// libs/reparse-math.ts\n\n\n\nfunction unifiedLatexReparseMathConstructPlugin({\n  mathEnvs,\n  mathMacros\n}) {\n  const isMathEnvironment = _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_5__[\"match\"].createEnvironmentMatcher(mathEnvs);\n  const isMathMacro = _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_5__[\"match\"].createMacroMatcher(mathMacros);\n  return (tree) => {\n    Object(_unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_4__[\"visit\"])(tree, (node) => {\n      if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_5__[\"match\"].anyMacro(node)) {\n        for (const arg of node.args || []) {\n          if (arg.content.length > 0 && !wasParsedInMathMode(arg.content)) {\n            arg.content = parseMathMinimal(Object(_unified_latex_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_6__[\"printRaw\"])(arg.content));\n          }\n        }\n      }\n      if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_5__[\"match\"].anyEnvironment(node)) {\n        if (!wasParsedInMathMode(node.content)) {\n          node.content = parseMathMinimal(Object(_unified_latex_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_6__[\"printRaw\"])(node.content));\n        }\n      }\n    }, {\n      test: (node) => isMathEnvironment(node) || isMathMacro(node)\n    });\n  };\n}\nfunction wasParsedInMathMode(nodes) {\n  return !nodes.some((node) => _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_5__[\"match\"].anyString(node) && node.content.length > 1 || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_5__[\"match\"].string(node, \"^\") || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_5__[\"match\"].string(node, \"_\"));\n}\n\n// libs/process-macros-and-environments.ts\n\n\nvar unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse = function unifiedLatexAttachMacroArguments(options) {\n  const { environments = {}, macros = {} } = options || {};\n  const mathMacros = Object.fromEntries(Object.entries(macros).filter(([_, info]) => {\n    var _a;\n    return ((_a = info.renderInfo) == null ? void 0 : _a.inMathMode) === true;\n  }));\n  const mathEnvs = Object.fromEntries(Object.entries(environments).filter(([_, info]) => {\n    var _a;\n    return ((_a = info.renderInfo) == null ? void 0 : _a.inMathMode) === true;\n  }));\n  const mathReparser = unifiedLatexReparseMathConstructPlugin({\n    mathEnvs: Object.keys(mathEnvs),\n    mathMacros: Object.keys(mathMacros)\n  });\n  const isRelevantEnvironment = _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_5__[\"match\"].createEnvironmentMatcher(environments);\n  const isRelevantMathEnvironment = _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_5__[\"match\"].createEnvironmentMatcher(mathEnvs);\n  return (tree) => {\n    Object(_unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_4__[\"visit\"])(tree, {\n      enter: (nodes) => {\n        if (!Array.isArray(nodes)) {\n          return;\n        }\n        Object(_unified_latex_unified_latex_util_arguments__WEBPACK_IMPORTED_MODULE_7__[\"attachMacroArgsInArray\"])(nodes, mathMacros);\n      },\n      leave: (node) => {\n        if (!isRelevantMathEnvironment(node)) {\n          return;\n        }\n        const envName = Object(_unified_latex_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_6__[\"printRaw\"])(node.env);\n        const envInfo = environments[envName];\n        if (!envInfo) {\n          throw new Error(`Could not find environment info for environment \"${envName}\"`);\n        }\n        Object(_unified_latex_unified_latex_util_environments__WEBPACK_IMPORTED_MODULE_8__[\"processEnvironment\"])(node, envInfo);\n      }\n    }, { includeArrays: true });\n    mathReparser(tree);\n    Object(_unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_4__[\"visit\"])(tree, {\n      enter: (nodes) => {\n        if (!Array.isArray(nodes)) {\n          return;\n        }\n        Object(_unified_latex_unified_latex_util_arguments__WEBPACK_IMPORTED_MODULE_7__[\"attachMacroArgsInArray\"])(nodes, macros);\n      },\n      leave: (node) => {\n        if (!isRelevantEnvironment(node)) {\n          return;\n        }\n        const envName = Object(_unified_latex_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_6__[\"printRaw\"])(node.env);\n        const envInfo = environments[envName];\n        if (!envInfo) {\n          throw new Error(`Could not find environment info for environment \"${envName}\"`);\n        }\n        Object(_unified_latex_unified_latex_util_environments__WEBPACK_IMPORTED_MODULE_8__[\"processEnvironment\"])(node, envInfo);\n      }\n    }, { includeArrays: true });\n  };\n};\n\n// libs/plugin-from-string.ts\nvar unifiedLatexFromString = function unifiedLatexFromString2(options) {\n  const {\n    mode = \"regular\",\n    macros = {},\n    environments = {}\n  } = options || {};\n  const allMacroInfo = Object.assign({}, macros, ...Object.values(_unified_latex_unified_latex_ctan__WEBPACK_IMPORTED_MODULE_1__[\"macroInfo\"]));\n  const allEnvInfo = Object.assign({}, environments, ...Object.values(_unified_latex_unified_latex_ctan__WEBPACK_IMPORTED_MODULE_1__[\"environmentInfo\"]));\n  const fullParser = Object(unified__WEBPACK_IMPORTED_MODULE_0__[\"unified\"])().use(unifiedLatexFromStringMinimal, { mode }).use(unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse, {\n    macros: allMacroInfo,\n    environments: allEnvInfo\n  }).use(_unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__[\"unifiedLatexTrimEnvironmentContents\"]).use(_unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__[\"unifiedLatexTrimRoot\"]).use(unifiedLatexAstComplier);\n  const parser2 = (str) => {\n    const file = fullParser.processSync({ value: str });\n    return file.result;\n  };\n  Object.assign(this, { Parser: parser2 });\n};\n\n// libs/parse.ts\n\nvar parser = Object(unified__WEBPACK_IMPORTED_MODULE_0__[\"unified\"])().use(unifiedLatexFromString).freeze();\nfunction parse(str) {\n  return parser.parse(str);\n}\n\n// libs/parse-math.ts\n\n\nfunction parseMath(str) {\n  if (typeof str !== \"string\") {\n    str = Object(_unified_latex_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_6__[\"printRaw\"])(str);\n  }\n  const file = Object(unified__WEBPACK_IMPORTED_MODULE_0__[\"unified\"])().use(unifiedLatexFromString, { mode: \"math\" }).use(unifiedLatexAstComplier).processSync({ value: str });\n  return file.result.content;\n}\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-util-parse/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-util-pegjs/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-util-pegjs/index.js ***!
  \***********************************************************************/
/*! exports provided: AlignEnvironmentPegParser, ArgSpecPegParser, GluePegParser, LatexPegParser, LigaturesPegParser, MacroSubstitutionPegParser, PgfkeysPegParser, SystemePegParser, TabularPegParser, XColorPegParser, decorateArrayForPegjs, splitStringsIntoSingleChars */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AlignEnvironmentPegParser\", function() { return AlignEnvironmentPegParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArgSpecPegParser\", function() { return ArgSpecPegParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GluePegParser\", function() { return GluePegParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LatexPegParser\", function() { return LatexPegParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LigaturesPegParser\", function() { return LigaturesPegParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MacroSubstitutionPegParser\", function() { return MacroSubstitutionPegParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PgfkeysPegParser\", function() { return PgfkeysPegParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SystemePegParser\", function() { return SystemePegParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TabularPegParser\", function() { return TabularPegParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XColorPegParser\", function() { return XColorPegParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decorateArrayForPegjs\", function() { return decorateArrayForPegjs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitStringsIntoSingleChars\", function() { return splitStringsIntoSingleChars; });\n/* harmony import */ var _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @unified-latex/unified-latex-util-match */ \"./node_modules/@unified-latex/unified-latex-util-match/index.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// libs/decorate-array-for-pegjs.ts\nfunction decorateArrayForPegjs(array) {\n  array.charAt = function(i) {\n    return this[i];\n  };\n  array.charCodeAt = () => 0;\n  array.substring = function(i, j) {\n    return this.slice(i, j);\n  };\n  array.replace = function(a, b) {\n    const ret = JSON.stringify(this);\n    return ret.replace(a, b);\n  };\n  return array;\n}\n\n// libs/split-strings.ts\n\nfunction splitStringsIntoSingleChars(nodes) {\n  return nodes.flatMap((node) => _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].anyString(node) ? Array.from(node.content).map((c) => ({\n    type: \"string\",\n    content: c\n  })) : node);\n}\n\n// grammars/latex.pegjs\nvar latex_default = function() {\n  \"use strict\";\n  function peg$subclass(child, parent) {\n    function C() {\n      this.constructor = child;\n    }\n    C.prototype = parent.prototype;\n    child.prototype = new C();\n  }\n  function peg$SyntaxError(message, expected, found, location) {\n    var self = Error.call(this, message);\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n    }\n    self.expected = expected;\n    self.found = found;\n    self.location = location;\n    self.name = \"SyntaxError\";\n    return self;\n  }\n  peg$subclass(peg$SyntaxError, Error);\n  function peg$padEnd(str, targetLength, padString) {\n    padString = padString || \" \";\n    if (str.length > targetLength) {\n      return str;\n    }\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n  }\n  peg$SyntaxError.prototype.format = function(sources) {\n    var str = \"Error: \" + this.message;\n    if (this.location) {\n      var src = null;\n      var k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].source === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      var s = this.location.start;\n      var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n      if (src) {\n        var e = this.location.end;\n        var filler = peg$padEnd(\"\", s.line.toString().length);\n        var line = src[s.line - 1];\n        var last = s.line === e.line ? e.column : line.length + 1;\n        str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1) + peg$padEnd(\"\", last - s.column, \"^\");\n      } else {\n        str += \"\\n at \" + loc;\n      }\n    }\n    return str;\n  };\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n      literal: function(expectation) {\n        return '\"' + literalEscape(expectation.text) + '\"';\n      },\n      class: function(expectation) {\n        var escapedParts = expectation.parts.map(function(part) {\n          return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n        });\n        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n      },\n      any: function() {\n        return \"any character\";\n      },\n      end: function() {\n        return \"end of input\";\n      },\n      other: function(expectation) {\n        return expectation.description;\n      }\n    };\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    function literalEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function classEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n    function describeExpected(expected2) {\n      var descriptions = expected2.map(describeExpectation);\n      var i, j;\n      descriptions.sort();\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n        default:\n          return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n      }\n    }\n    function describeFound(found2) {\n      return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n    }\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n    var peg$FAILED = {};\n    var peg$source = options.grammarSource;\n    var peg$startRuleFunctions = { document: peg$parsedocument, math: peg$parsemath };\n    var peg$startRuleFunction = peg$parsedocument;\n    var peg$c0 = \"%\";\n    var peg$c1 = \".\";\n    var peg$c2 = \"verb*\";\n    var peg$c3 = \"verb\";\n    var peg$c4 = \"verbatim*\";\n    var peg$c5 = \"verbatim\";\n    var peg$c6 = \"filecontents*\";\n    var peg$c7 = \"filecontents\";\n    var peg$c8 = \"comment\";\n    var peg$c9 = \"lstlisting\";\n    var peg$c10 = \"[\";\n    var peg$c11 = \"]\";\n    var peg$c12 = \"(\";\n    var peg$c13 = \")\";\n    var peg$c14 = \"begin\";\n    var peg$c15 = \"end\";\n    var peg$c16 = \"equation*\";\n    var peg$c17 = \"equation\";\n    var peg$c18 = \"align*\";\n    var peg$c19 = \"align\";\n    var peg$c20 = \"alignat*\";\n    var peg$c21 = \"alignat\";\n    var peg$c22 = \"gather*\";\n    var peg$c23 = \"gather\";\n    var peg$c24 = \"multline*\";\n    var peg$c25 = \"multline\";\n    var peg$c26 = \"flalign*\";\n    var peg$c27 = \"flalign\";\n    var peg$c28 = \"split\";\n    var peg$c29 = \"math\";\n    var peg$c30 = \"displaymath\";\n    var peg$c31 = \"\\\\\";\n    var peg$c32 = \"{\";\n    var peg$c33 = \"}\";\n    var peg$c34 = \"$\";\n    var peg$c35 = \"&\";\n    var peg$c36 = \"\\r\";\n    var peg$c37 = \"\\n\";\n    var peg$c38 = \"\\r\\n\";\n    var peg$c39 = \"#\";\n    var peg$c40 = \"^\";\n    var peg$c41 = \"_\";\n    var peg$c42 = \"\\0\";\n    var peg$r0 = /^[ \\t]/;\n    var peg$r1 = /^[a-zA-Z]/;\n    var peg$r2 = /^[0-9]/;\n    var peg$r3 = /^[.,;:\\-*\\/()!?=+<>[\\]`'\"~]/;\n    var peg$e0 = peg$otherExpectation(\"document\");\n    var peg$e1 = peg$otherExpectation(\"math\");\n    var peg$e2 = peg$otherExpectation(\"token\");\n    var peg$e3 = peg$anyExpectation();\n    var peg$e4 = peg$otherExpectation(\"parbreak\");\n    var peg$e5 = peg$otherExpectation(\"math token\");\n    var peg$e6 = peg$otherExpectation(\"nonchar token\");\n    var peg$e7 = peg$literalExpectation(\"%\", false);\n    var peg$e8 = peg$otherExpectation(\"whitespace\");\n    var peg$e9 = peg$otherExpectation(\"number\");\n    var peg$e10 = peg$literalExpectation(\".\", false);\n    var peg$e11 = peg$otherExpectation(\"special macro\");\n    var peg$e12 = peg$literalExpectation(\"verb*\", false);\n    var peg$e13 = peg$literalExpectation(\"verb\", false);\n    var peg$e14 = peg$otherExpectation(\"verbatim environment\");\n    var peg$e15 = peg$literalExpectation(\"verbatim*\", false);\n    var peg$e16 = peg$literalExpectation(\"verbatim\", false);\n    var peg$e17 = peg$literalExpectation(\"filecontents*\", false);\n    var peg$e18 = peg$literalExpectation(\"filecontents\", false);\n    var peg$e19 = peg$literalExpectation(\"comment\", false);\n    var peg$e20 = peg$literalExpectation(\"lstlisting\", false);\n    var peg$e21 = peg$otherExpectation(\"macro\");\n    var peg$e22 = peg$otherExpectation(\"group\");\n    var peg$e23 = peg$otherExpectation(\"environment\");\n    var peg$e24 = peg$otherExpectation(\"math environment\");\n    var peg$e25 = peg$otherExpectation(\"math group\");\n    var peg$e26 = peg$literalExpectation(\"[\", false);\n    var peg$e27 = peg$literalExpectation(\"]\", false);\n    var peg$e28 = peg$literalExpectation(\"(\", false);\n    var peg$e29 = peg$literalExpectation(\")\", false);\n    var peg$e30 = peg$literalExpectation(\"begin\", false);\n    var peg$e31 = peg$literalExpectation(\"end\", false);\n    var peg$e32 = peg$literalExpectation(\"equation*\", false);\n    var peg$e33 = peg$literalExpectation(\"equation\", false);\n    var peg$e34 = peg$literalExpectation(\"align*\", false);\n    var peg$e35 = peg$literalExpectation(\"align\", false);\n    var peg$e36 = peg$literalExpectation(\"alignat*\", false);\n    var peg$e37 = peg$literalExpectation(\"alignat\", false);\n    var peg$e38 = peg$literalExpectation(\"gather*\", false);\n    var peg$e39 = peg$literalExpectation(\"gather\", false);\n    var peg$e40 = peg$literalExpectation(\"multline*\", false);\n    var peg$e41 = peg$literalExpectation(\"multline\", false);\n    var peg$e42 = peg$literalExpectation(\"flalign*\", false);\n    var peg$e43 = peg$literalExpectation(\"flalign\", false);\n    var peg$e44 = peg$literalExpectation(\"split\", false);\n    var peg$e45 = peg$literalExpectation(\"math\", false);\n    var peg$e46 = peg$literalExpectation(\"displaymath\", false);\n    var peg$e47 = peg$otherExpectation(\"escape\");\n    var peg$e48 = peg$literalExpectation(\"\\\\\", false);\n    var peg$e49 = peg$literalExpectation(\"{\", false);\n    var peg$e50 = peg$literalExpectation(\"}\", false);\n    var peg$e51 = peg$literalExpectation(\"$\", false);\n    var peg$e52 = peg$literalExpectation(\"&\", false);\n    var peg$e53 = peg$otherExpectation(\"newline\");\n    var peg$e54 = peg$literalExpectation(\"\\r\", false);\n    var peg$e55 = peg$literalExpectation(\"\\n\", false);\n    var peg$e56 = peg$literalExpectation(\"\\r\\n\", false);\n    var peg$e57 = peg$literalExpectation(\"#\", false);\n    var peg$e58 = peg$literalExpectation(\"^\", false);\n    var peg$e59 = peg$literalExpectation(\"_\", false);\n    var peg$e60 = peg$literalExpectation(\"\\0\", false);\n    var peg$e61 = peg$classExpectation([\" \", \"\t\"], false, false);\n    var peg$e62 = peg$otherExpectation(\"letter\");\n    var peg$e63 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false);\n    var peg$e64 = peg$otherExpectation(\"digit\");\n    var peg$e65 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n    var peg$e66 = peg$otherExpectation(\"punctuation\");\n    var peg$e67 = peg$classExpectation([\".\", \",\", \";\", \":\", \"-\", \"*\", \"/\", \"(\", \")\", \"!\", \"?\", \"=\", \"+\", \"<\", \">\", \"[\", \"]\", \"`\", \"'\", '\"', \"~\"], false, false);\n    var peg$e68 = peg$otherExpectation(\"full comment\");\n    var peg$e69 = peg$otherExpectation(\"comment\");\n    var peg$f0 = function(content) {\n      return createNode(\"root\", { content });\n    };\n    var peg$f1 = function(t) {\n      return t;\n    };\n    var peg$f2 = function(eq) {\n      return createNode(\"inlinemath\", { content: eq });\n    };\n    var peg$f3 = function(s) {\n      return createNode(\"string\", { content: s });\n    };\n    var peg$f4 = function() {\n      return createNode(\"parbreak\");\n    };\n    var peg$f5 = function(x) {\n      return x;\n    };\n    var peg$f6 = function() {\n      return createNode(\"macro\", { content: \"^\", escapeToken: \"\" });\n    };\n    var peg$f7 = function() {\n      return createNode(\"macro\", { content: \"_\", escapeToken: \"\" });\n    };\n    var peg$f8 = function() {\n      return createNode(\"whitespace\");\n    };\n    var peg$f9 = function(a, b) {\n      return a.join(\"\") + \".\" + b.join(\"\");\n    };\n    var peg$f10 = function(b) {\n      return \".\" + b.join(\"\");\n    };\n    var peg$f11 = function(a) {\n      return a.join(\"\") + \".\";\n    };\n    var peg$f12 = function(env, e, end) {\n      return end == e;\n    };\n    var peg$f13 = function(env, e, x) {\n      return x;\n    };\n    var peg$f14 = function(env, e, x, end) {\n      return end == e;\n    };\n    var peg$f15 = function(env, e, x) {\n      return createNode(\"verb\", {\n        env,\n        escape: e,\n        content: x.join(\"\")\n      });\n    };\n    var peg$f16 = function(x) {\n      return createNode(\"displaymath\", { content: x });\n    };\n    var peg$f17 = function(x) {\n      return createNode(\"inlinemath\", { content: x });\n    };\n    var peg$f18 = function(env, end_env) {\n      return compare_env({ content: [env] }, end_env);\n    };\n    var peg$f19 = function(env, x) {\n      return x;\n    };\n    var peg$f20 = function(env, body) {\n      return createNode(\"verbatim\", {\n        env,\n        content: body.join(\"\")\n      });\n    };\n    var peg$f21 = function(n) {\n      return n.join(\"\");\n    };\n    var peg$f22 = function(n) {\n      return n;\n    };\n    var peg$f23 = function(m) {\n      return createNode(\"macro\", { content: m });\n    };\n    var peg$f24 = function(c) {\n      return c;\n    };\n    var peg$f25 = function(x) {\n      return createNode(\"group\", { content: x });\n    };\n    var peg$f26 = function(g) {\n      return text().slice(1, -1);\n    };\n    var peg$f27 = function(env, env_comment, end_env) {\n      return compare_env(env, end_env);\n    };\n    var peg$f28 = function(env, env_comment, x) {\n      return x;\n    };\n    var peg$f29 = function(env, env_comment, body) {\n      return createNode(\"environment\", {\n        env,\n        content: env_comment ? [env_comment, ...body] : body\n      });\n    };\n    var peg$f30 = function(env, env_comment, end_env) {\n      return compare_env({ content: [env] }, end_env);\n    };\n    var peg$f31 = function(env, env_comment, body) {\n      return createNode(\"mathenv\", {\n        env,\n        content: env_comment ? [env_comment, ...body] : body\n      });\n    };\n    var peg$f32 = function(e) {\n      return createNode(\"string\", { content: e });\n    };\n    var peg$f33 = function() {\n      return createNode(\"string\", { content: \"\\\\\" });\n    };\n    var peg$f34 = function() {\n      return \" \";\n    };\n    var peg$f35 = function(p) {\n      return createNode(\"string\", { content: p });\n    };\n    var peg$f36 = function(leading_sp, comment) {\n      return createNode(\"comment\", __spreadProps(__spreadValues({}, comment), {\n        sameline: false,\n        leadingWhitespace: leading_sp.length > 0\n      }));\n    };\n    var peg$f37 = function(spaces, x) {\n      return createNode(\"comment\", __spreadProps(__spreadValues({}, x), {\n        sameline: true,\n        leadingWhitespace: spaces.length > 0\n      }));\n    };\n    var peg$f38 = function(c) {\n      return { content: c.join(\"\"), suffixParbreak: true };\n    };\n    var peg$f39 = function(c) {\n      return { content: c.join(\"\") };\n    };\n    var peg$f40 = function() {\n      var loc = location();\n      return loc.start.column === 1;\n    };\n    var peg$currPos = 0;\n    var peg$savedPos = 0;\n    var peg$posDetailsCache = [{ line: 1, column: 1 }];\n    var peg$maxFailPos = 0;\n    var peg$maxFailExpected = [];\n    var peg$silentFails = 0;\n    var peg$result;\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n      }\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n    function offset() {\n      return peg$savedPos;\n    }\n    function range() {\n      return {\n        source: peg$source,\n        start: peg$savedPos,\n        end: peg$currPos\n      };\n    }\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);\n    }\n    function error(message, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildSimpleError(message, location2);\n    }\n    function peg$literalExpectation(text2, ignoreCase) {\n      return { type: \"literal\", text: text2, ignoreCase };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts, inverted, ignoreCase };\n    }\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description };\n    }\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos];\n      var p;\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column\n        };\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n          p++;\n        }\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos);\n      var endPosDetails = peg$computePosDetails(endPos);\n      return {\n        source: peg$source,\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n    function peg$fail(expected2) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n      peg$maxFailExpected.push(expected2);\n    }\n    function peg$buildSimpleError(message, location2) {\n      return new peg$SyntaxError(message, null, null, location2);\n    }\n    function peg$buildStructuredError(expected2, found, location2) {\n      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);\n    }\n    function peg$parsedocument() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsetoken();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsetoken();\n      }\n      peg$savedPos = s0;\n      s1 = peg$f0(s1);\n      s0 = s1;\n      peg$silentFails--;\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$e0);\n      }\n      return s0;\n    }\n    function peg$parsemath() {\n      var s0, s1;\n      peg$silentFails++;\n      s0 = [];\n      s1 = peg$parsemath_token();\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parsemath_token();\n      }\n      peg$silentFails--;\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$e1);\n      }\n      return s0;\n    }\n    function peg$parsetoken() {\n      var s0, s1, s2, s3, s4, s5;\n      peg$silentFails++;\n      s0 = peg$parsespecial_macro();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsemacro();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsefull_comment();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsegroup();\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parsemath_shift();\n              if (s1 !== peg$FAILED) {\n                s2 = [];\n                s3 = peg$currPos;\n                s4 = peg$currPos;\n                peg$silentFails++;\n                s5 = peg$parsemath_shift();\n                peg$silentFails--;\n                if (s5 === peg$FAILED) {\n                  s4 = void 0;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsemath_token();\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s3;\n                    s3 = peg$f1(s5);\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n                if (s3 !== peg$FAILED) {\n                  while (s3 !== peg$FAILED) {\n                    s2.push(s3);\n                    s3 = peg$currPos;\n                    s4 = peg$currPos;\n                    peg$silentFails++;\n                    s5 = peg$parsemath_shift();\n                    peg$silentFails--;\n                    if (s5 === peg$FAILED) {\n                      s4 = void 0;\n                    } else {\n                      peg$currPos = s4;\n                      s4 = peg$FAILED;\n                    }\n                    if (s4 !== peg$FAILED) {\n                      s5 = peg$parsemath_token();\n                      if (s5 !== peg$FAILED) {\n                        peg$savedPos = s3;\n                        s3 = peg$f1(s5);\n                      } else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  }\n                } else {\n                  s2 = peg$FAILED;\n                }\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parsemath_shift();\n                  if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s0 = peg$f2(s2);\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsealignment_tab();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parseparbreak();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsemacro_parameter();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parseignore();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsenumber();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsewhitespace();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsepunctuation();\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$currPos;\n                              s1 = peg$currPos;\n                              s2 = [];\n                              s3 = peg$currPos;\n                              s4 = peg$currPos;\n                              peg$silentFails++;\n                              s5 = peg$parsenonchar_token();\n                              peg$silentFails--;\n                              if (s5 === peg$FAILED) {\n                                s4 = void 0;\n                              } else {\n                                peg$currPos = s4;\n                                s4 = peg$FAILED;\n                              }\n                              if (s4 !== peg$FAILED) {\n                                if (input.length > peg$currPos) {\n                                  s5 = input.charAt(peg$currPos);\n                                  peg$currPos++;\n                                } else {\n                                  s5 = peg$FAILED;\n                                  if (peg$silentFails === 0) {\n                                    peg$fail(peg$e3);\n                                  }\n                                }\n                                if (s5 !== peg$FAILED) {\n                                  s4 = [s4, s5];\n                                  s3 = s4;\n                                } else {\n                                  peg$currPos = s3;\n                                  s3 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s3;\n                                s3 = peg$FAILED;\n                              }\n                              if (s3 !== peg$FAILED) {\n                                while (s3 !== peg$FAILED) {\n                                  s2.push(s3);\n                                  s3 = peg$currPos;\n                                  s4 = peg$currPos;\n                                  peg$silentFails++;\n                                  s5 = peg$parsenonchar_token();\n                                  peg$silentFails--;\n                                  if (s5 === peg$FAILED) {\n                                    s4 = void 0;\n                                  } else {\n                                    peg$currPos = s4;\n                                    s4 = peg$FAILED;\n                                  }\n                                  if (s4 !== peg$FAILED) {\n                                    if (input.length > peg$currPos) {\n                                      s5 = input.charAt(peg$currPos);\n                                      peg$currPos++;\n                                    } else {\n                                      s5 = peg$FAILED;\n                                      if (peg$silentFails === 0) {\n                                        peg$fail(peg$e3);\n                                      }\n                                    }\n                                    if (s5 !== peg$FAILED) {\n                                      s4 = [s4, s5];\n                                      s3 = s4;\n                                    } else {\n                                      peg$currPos = s3;\n                                      s3 = peg$FAILED;\n                                    }\n                                  } else {\n                                    peg$currPos = s3;\n                                    s3 = peg$FAILED;\n                                  }\n                                }\n                              } else {\n                                s2 = peg$FAILED;\n                              }\n                              if (s2 !== peg$FAILED) {\n                                s1 = input.substring(s1, peg$currPos);\n                              } else {\n                                s1 = s2;\n                              }\n                              if (s1 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s1 = peg$f3(s1);\n                              }\n                              s0 = s1;\n                              if (s0 === peg$FAILED) {\n                                s0 = peg$parsebegin_group();\n                                if (s0 === peg$FAILED) {\n                                  s0 = peg$parseend_group();\n                                  if (s0 === peg$FAILED) {\n                                    s0 = peg$parsemath_shift();\n                                    if (s0 === peg$FAILED) {\n                                      s0 = peg$currPos;\n                                      if (input.length > peg$currPos) {\n                                        s1 = input.charAt(peg$currPos);\n                                        peg$currPos++;\n                                      } else {\n                                        s1 = peg$FAILED;\n                                        if (peg$silentFails === 0) {\n                                          peg$fail(peg$e3);\n                                        }\n                                      }\n                                      if (s1 !== peg$FAILED) {\n                                        peg$savedPos = s0;\n                                        s1 = peg$f3(s1);\n                                      }\n                                      s0 = s1;\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      return s0;\n    }\n    function peg$parseparbreak() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsesp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsesp();\n      }\n      s3 = peg$parsenl();\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$currPos;\n        s6 = [];\n        s7 = peg$parsesp();\n        while (s7 !== peg$FAILED) {\n          s6.push(s7);\n          s7 = peg$parsesp();\n        }\n        s7 = peg$parsenl();\n        if (s7 !== peg$FAILED) {\n          s6 = [s6, s7];\n          s5 = s6;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = [];\n            s7 = peg$parsesp();\n            while (s7 !== peg$FAILED) {\n              s6.push(s7);\n              s7 = peg$parsesp();\n            }\n            s7 = peg$parsenl();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = [];\n          s6 = peg$parsesp();\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$parsesp();\n          }\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsecomment_start();\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = void 0;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            s2 = [s2, s3, s4, s5, s6];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = [];\n        s3 = peg$parsesp();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsesp();\n        }\n        s3 = peg$parsenl();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = [];\n          s7 = peg$parsesp();\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parsesp();\n          }\n          s7 = peg$parsenl();\n          if (s7 !== peg$FAILED) {\n            s6 = [s6, s7];\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = [];\n              s7 = peg$parsesp();\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$parsesp();\n              }\n              s7 = peg$parsenl();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            }\n          } else {\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f4();\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e4);\n        }\n      }\n      return s0;\n    }\n    function peg$parsemath_token() {\n      var s0, s1, s2, s3, s4;\n      peg$silentFails++;\n      s0 = peg$parsespecial_macro();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsemacro();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsefull_comment();\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = [];\n            s2 = peg$parsewhitespace();\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parsewhitespace();\n            }\n            s2 = peg$parsegroup();\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$parsewhitespace();\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$parsewhitespace();\n              }\n              peg$savedPos = s0;\n              s0 = peg$f5(s2);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = [];\n              s2 = peg$parsewhitespace();\n              while (s2 !== peg$FAILED) {\n                s1.push(s2);\n                s2 = peg$parsewhitespace();\n              }\n              s2 = peg$parsealignment_tab();\n              if (s2 !== peg$FAILED) {\n                s3 = [];\n                s4 = peg$parsewhitespace();\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n                  s4 = peg$parsewhitespace();\n                }\n                peg$savedPos = s0;\n                s0 = peg$f5(s2);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = [];\n                s2 = peg$parsewhitespace();\n                while (s2 !== peg$FAILED) {\n                  s1.push(s2);\n                  s2 = peg$parsewhitespace();\n                }\n                s2 = peg$parsemacro_parameter();\n                if (s2 !== peg$FAILED) {\n                  s3 = [];\n                  s4 = peg$parsewhitespace();\n                  while (s4 !== peg$FAILED) {\n                    s3.push(s4);\n                    s4 = peg$parsewhitespace();\n                  }\n                  peg$savedPos = s0;\n                  s0 = peg$f5(s2);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  s1 = [];\n                  s2 = peg$parsewhitespace();\n                  while (s2 !== peg$FAILED) {\n                    s1.push(s2);\n                    s2 = peg$parsewhitespace();\n                  }\n                  s2 = peg$parsesuperscript();\n                  if (s2 !== peg$FAILED) {\n                    s3 = [];\n                    s4 = peg$parsewhitespace();\n                    while (s4 !== peg$FAILED) {\n                      s3.push(s4);\n                      s4 = peg$parsewhitespace();\n                    }\n                    peg$savedPos = s0;\n                    s0 = peg$f6();\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    s1 = [];\n                    s2 = peg$parsewhitespace();\n                    while (s2 !== peg$FAILED) {\n                      s1.push(s2);\n                      s2 = peg$parsewhitespace();\n                    }\n                    s2 = peg$parsesubscript();\n                    if (s2 !== peg$FAILED) {\n                      s3 = [];\n                      s4 = peg$parsewhitespace();\n                      while (s4 !== peg$FAILED) {\n                        s3.push(s4);\n                        s4 = peg$parsewhitespace();\n                      }\n                      peg$savedPos = s0;\n                      s0 = peg$f7();\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parseignore();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsewhitespace();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$currPos;\n                          if (input.length > peg$currPos) {\n                            s1 = input.charAt(peg$currPos);\n                            peg$currPos++;\n                          } else {\n                            s1 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                              peg$fail(peg$e3);\n                            }\n                          }\n                          if (s1 !== peg$FAILED) {\n                            peg$savedPos = s0;\n                            s1 = peg$f3(s1);\n                          }\n                          s0 = s1;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e5);\n        }\n      }\n      return s0;\n    }\n    function peg$parsenonchar_token() {\n      var s0, s1;\n      peg$silentFails++;\n      s0 = peg$parseescape();\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 37) {\n          s0 = peg$c0;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e7);\n          }\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsebegin_group();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseend_group();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsemath_shift();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsealignment_tab();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsenl();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsemacro_parameter();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parseignore();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsesp();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsepunctuation();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parseEOF();\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e6);\n        }\n      }\n      return s0;\n    }\n    function peg$parsewhitespace() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsenl();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsesp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsesp();\n        }\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = [];\n        s3 = peg$parsesp();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsesp();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsenl();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$parsecomment_start();\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = void 0;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parsesp();\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$parsesp();\n              }\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$parsenl();\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = void 0;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = [];\n          s2 = peg$parsesp();\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parsesp();\n            }\n          } else {\n            s1 = peg$FAILED;\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f8();\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e8);\n        }\n      }\n      return s0;\n    }\n    function peg$parsenumber() {\n      var s0, s1, s2, s3, s4, s5;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsenum();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsenum();\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e10);\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsenum();\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parsenum();\n            }\n          } else {\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s1 = peg$f9(s2, s4);\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c1;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e10);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsenum();\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parsenum();\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s1 = peg$f10(s3);\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = [];\n          s3 = peg$parsenum();\n          if (s3 !== peg$FAILED) {\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsenum();\n            }\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s3 = peg$c1;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e10);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s1;\n              s1 = peg$f11(s2);\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f3(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e9);\n        }\n      }\n      return s0;\n    }\n    function peg$parsespecial_macro() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseescape();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c2) {\n          s2 = peg$c2;\n          peg$currPos += 5;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e12);\n          }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 4) === peg$c3) {\n            s2 = peg$c3;\n            peg$currPos += 4;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e13);\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e3);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$currPos;\n            if (input.length > peg$currPos) {\n              s8 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s8 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e3);\n              }\n            }\n            if (s8 !== peg$FAILED) {\n              peg$savedPos = peg$currPos;\n              s9 = peg$f12(s2, s3, s8);\n              if (s9) {\n                s9 = void 0;\n              } else {\n                s9 = peg$FAILED;\n              }\n              if (s9 !== peg$FAILED) {\n                s8 = [s8, s9];\n                s7 = s8;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = void 0;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s7 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e3);\n                }\n              }\n              if (s7 !== peg$FAILED) {\n                peg$savedPos = s5;\n                s5 = peg$f13(s2, s3, s7);\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$currPos;\n              if (input.length > peg$currPos) {\n                s8 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s8 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e3);\n                }\n              }\n              if (s8 !== peg$FAILED) {\n                peg$savedPos = peg$currPos;\n                s9 = peg$f12(s2, s3, s8);\n                if (s9) {\n                  s9 = void 0;\n                } else {\n                  s9 = peg$FAILED;\n                }\n                if (s9 !== peg$FAILED) {\n                  s8 = [s8, s9];\n                  s7 = s8;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = void 0;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s7 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e3);\n                  }\n                }\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s5;\n                  s5 = peg$f13(s2, s3, s7);\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            }\n            s5 = peg$currPos;\n            if (input.length > peg$currPos) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e3);\n              }\n            }\n            if (s6 !== peg$FAILED) {\n              peg$savedPos = peg$currPos;\n              s7 = peg$f14(s2, s3, s4, s6);\n              if (s7) {\n                s7 = void 0;\n              } else {\n                s7 = peg$FAILED;\n              }\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f15(s2, s3, s4);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseverbatim_environment();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsebegin_display_math();\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$parseend_display_math();\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = void 0;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsemath_token();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f5(s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$currPos;\n              peg$silentFails++;\n              s5 = peg$parseend_display_math();\n              peg$silentFails--;\n              if (s5 === peg$FAILED) {\n                s4 = void 0;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsemath_token();\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s3 = peg$f5(s5);\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n            s3 = peg$parseend_display_math();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f16(s2);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsebegin_inline_math();\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n              s3 = peg$currPos;\n              s4 = peg$currPos;\n              peg$silentFails++;\n              s5 = peg$parseend_inline_math();\n              peg$silentFails--;\n              if (s5 === peg$FAILED) {\n                s4 = void 0;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsemath_token();\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s3 = peg$f5(s5);\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$currPos;\n                s4 = peg$currPos;\n                peg$silentFails++;\n                s5 = peg$parseend_inline_math();\n                peg$silentFails--;\n                if (s5 === peg$FAILED) {\n                  s4 = void 0;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsemath_token();\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s3;\n                    s3 = peg$f5(s5);\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n              s3 = peg$parseend_inline_math();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f17(s2);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parsemath_shift();\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parsemath_shift();\n                if (s2 !== peg$FAILED) {\n                  s3 = [];\n                  s4 = peg$currPos;\n                  s5 = peg$currPos;\n                  peg$silentFails++;\n                  s6 = peg$currPos;\n                  s7 = peg$parsemath_shift();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parsemath_shift();\n                    if (s8 !== peg$FAILED) {\n                      s7 = [s7, s8];\n                      s6 = s7;\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                  peg$silentFails--;\n                  if (s6 === peg$FAILED) {\n                    s5 = void 0;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parsemath_token();\n                    if (s6 !== peg$FAILED) {\n                      peg$savedPos = s4;\n                      s4 = peg$f5(s6);\n                    } else {\n                      peg$currPos = s4;\n                      s4 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                  while (s4 !== peg$FAILED) {\n                    s3.push(s4);\n                    s4 = peg$currPos;\n                    s5 = peg$currPos;\n                    peg$silentFails++;\n                    s6 = peg$currPos;\n                    s7 = peg$parsemath_shift();\n                    if (s7 !== peg$FAILED) {\n                      s8 = peg$parsemath_shift();\n                      if (s8 !== peg$FAILED) {\n                        s7 = [s7, s8];\n                        s6 = s7;\n                      } else {\n                        peg$currPos = s6;\n                        s6 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                    peg$silentFails--;\n                    if (s6 === peg$FAILED) {\n                      s5 = void 0;\n                    } else {\n                      peg$currPos = s5;\n                      s5 = peg$FAILED;\n                    }\n                    if (s5 !== peg$FAILED) {\n                      s6 = peg$parsemath_token();\n                      if (s6 !== peg$FAILED) {\n                        peg$savedPos = s4;\n                        s4 = peg$f5(s6);\n                      } else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s4;\n                      s4 = peg$FAILED;\n                    }\n                  }\n                  s4 = peg$parsemath_shift();\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsemath_shift();\n                    if (s5 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s0 = peg$f16(s3);\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsemath_environment();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parseenvironment();\n                }\n              }\n            }\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e11);\n        }\n      }\n      return s0;\n    }\n    function peg$parseverbatim_environment() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsebegin_env();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebegin_group();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseverbatim_env_name();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseend_group();\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$currPos;\n              s7 = peg$currPos;\n              peg$silentFails++;\n              s8 = peg$currPos;\n              s9 = peg$parseend_env();\n              if (s9 !== peg$FAILED) {\n                s10 = peg$parsegroup();\n                if (s10 !== peg$FAILED) {\n                  peg$savedPos = peg$currPos;\n                  s11 = peg$f18(s3, s10);\n                  if (s11) {\n                    s11 = void 0;\n                  } else {\n                    s11 = peg$FAILED;\n                  }\n                  if (s11 !== peg$FAILED) {\n                    s9 = [s9, s10, s11];\n                    s8 = s9;\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n              peg$silentFails--;\n              if (s8 === peg$FAILED) {\n                s7 = void 0;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              if (s7 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s8 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e3);\n                  }\n                }\n                if (s8 !== peg$FAILED) {\n                  peg$savedPos = s6;\n                  s6 = peg$f19(s3, s8);\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$currPos;\n                s7 = peg$currPos;\n                peg$silentFails++;\n                s8 = peg$currPos;\n                s9 = peg$parseend_env();\n                if (s9 !== peg$FAILED) {\n                  s10 = peg$parsegroup();\n                  if (s10 !== peg$FAILED) {\n                    peg$savedPos = peg$currPos;\n                    s11 = peg$f18(s3, s10);\n                    if (s11) {\n                      s11 = void 0;\n                    } else {\n                      s11 = peg$FAILED;\n                    }\n                    if (s11 !== peg$FAILED) {\n                      s9 = [s9, s10, s11];\n                      s8 = s9;\n                    } else {\n                      peg$currPos = s8;\n                      s8 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n                peg$silentFails--;\n                if (s8 === peg$FAILED) {\n                  s7 = void 0;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n                if (s7 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s8 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$e3);\n                    }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s6;\n                    s6 = peg$f19(s3, s8);\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              }\n              s6 = peg$parseend_env();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsebegin_group();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseverbatim_env_name();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseend_group();\n                    if (s9 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s0 = peg$f20(s3, s5);\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e14);\n        }\n      }\n      return s0;\n    }\n    function peg$parseverbatim_env_name() {\n      var s0;\n      if (input.substr(peg$currPos, 9) === peg$c4) {\n        s0 = peg$c4;\n        peg$currPos += 9;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e15);\n        }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 8) === peg$c5) {\n          s0 = peg$c5;\n          peg$currPos += 8;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e16);\n          }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 13) === peg$c6) {\n            s0 = peg$c6;\n            peg$currPos += 13;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e17);\n            }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 12) === peg$c7) {\n              s0 = peg$c7;\n              peg$currPos += 12;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e18);\n              }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c8) {\n                s0 = peg$c8;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e19);\n                }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 10) === peg$c9) {\n                  s0 = peg$c9;\n                  peg$currPos += 10;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e20);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return s0;\n    }\n    function peg$parsemacro() {\n      var s0, s1, s2, s3, s4;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseescape();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsechar();\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsechar();\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s1 = peg$f21(s3);\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parseescape();\n        if (s2 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e3);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s1 = peg$f22(s3);\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f23(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e21);\n        }\n      }\n      return s0;\n    }\n    function peg$parsegroup() {\n      var s0, s1, s2, s3, s4, s5;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsebegin_group();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseend_group();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsetoken();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f24(s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseend_group();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsetoken();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f24(s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        s3 = peg$parseend_group();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f25(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e22);\n        }\n      }\n      return s0;\n    }\n    function peg$parsegroup_contents_as_string() {\n      var s0, s1;\n      s0 = peg$currPos;\n      s1 = peg$parsegroup();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f26(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parseenvironment() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsebegin_env();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsegroup_contents_as_string();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsesameline_comment();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$currPos;\n          s8 = peg$parseend_env();\n          if (s8 !== peg$FAILED) {\n            s9 = peg$parsegroup_contents_as_string();\n            if (s9 !== peg$FAILED) {\n              peg$savedPos = peg$currPos;\n              s10 = peg$f27(s2, s3, s9);\n              if (s10) {\n                s10 = void 0;\n              } else {\n                s10 = peg$FAILED;\n              }\n              if (s10 !== peg$FAILED) {\n                s8 = [s8, s9, s10];\n                s7 = s8;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = void 0;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsetoken();\n            if (s7 !== peg$FAILED) {\n              peg$savedPos = s5;\n              s5 = peg$f28(s2, s3, s7);\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$currPos;\n            s8 = peg$parseend_env();\n            if (s8 !== peg$FAILED) {\n              s9 = peg$parsegroup_contents_as_string();\n              if (s9 !== peg$FAILED) {\n                peg$savedPos = peg$currPos;\n                s10 = peg$f27(s2, s3, s9);\n                if (s10) {\n                  s10 = void 0;\n                } else {\n                  s10 = peg$FAILED;\n                }\n                if (s10 !== peg$FAILED) {\n                  s8 = [s8, s9, s10];\n                  s7 = s8;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = void 0;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsetoken();\n              if (s7 !== peg$FAILED) {\n                peg$savedPos = s5;\n                s5 = peg$f28(s2, s3, s7);\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          }\n          s5 = peg$parseend_env();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsegroup_contents_as_string();\n            if (s6 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f29(s2, s3, s4);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e23);\n        }\n      }\n      return s0;\n    }\n    function peg$parsemath_environment() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsebegin_env();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebegin_group();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsemath_env_name();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseend_group();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsesameline_comment();\n              if (s5 === peg$FAILED) {\n                s5 = null;\n              }\n              s6 = [];\n              s7 = peg$currPos;\n              s8 = peg$currPos;\n              peg$silentFails++;\n              s9 = peg$currPos;\n              s10 = peg$parseend_env();\n              if (s10 !== peg$FAILED) {\n                s11 = peg$parsegroup();\n                if (s11 !== peg$FAILED) {\n                  peg$savedPos = peg$currPos;\n                  s12 = peg$f30(s3, s5, s11);\n                  if (s12) {\n                    s12 = void 0;\n                  } else {\n                    s12 = peg$FAILED;\n                  }\n                  if (s12 !== peg$FAILED) {\n                    s10 = [s10, s11, s12];\n                    s9 = s10;\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s9;\n                  s9 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s9;\n                s9 = peg$FAILED;\n              }\n              peg$silentFails--;\n              if (s9 === peg$FAILED) {\n                s8 = void 0;\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parsemath_token();\n                if (s9 !== peg$FAILED) {\n                  peg$savedPos = s7;\n                  s7 = peg$f28(s3, s5, s9);\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$currPos;\n                s8 = peg$currPos;\n                peg$silentFails++;\n                s9 = peg$currPos;\n                s10 = peg$parseend_env();\n                if (s10 !== peg$FAILED) {\n                  s11 = peg$parsegroup();\n                  if (s11 !== peg$FAILED) {\n                    peg$savedPos = peg$currPos;\n                    s12 = peg$f30(s3, s5, s11);\n                    if (s12) {\n                      s12 = void 0;\n                    } else {\n                      s12 = peg$FAILED;\n                    }\n                    if (s12 !== peg$FAILED) {\n                      s10 = [s10, s11, s12];\n                      s9 = s10;\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s9;\n                  s9 = peg$FAILED;\n                }\n                peg$silentFails--;\n                if (s9 === peg$FAILED) {\n                  s8 = void 0;\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parsemath_token();\n                  if (s9 !== peg$FAILED) {\n                    peg$savedPos = s7;\n                    s7 = peg$f28(s3, s5, s9);\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              }\n              s7 = peg$parseend_env();\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parsebegin_group();\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parsemath_env_name();\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parseend_group();\n                    if (s10 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s0 = peg$f31(s3, s5, s6);\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e24);\n        }\n      }\n      return s0;\n    }\n    function peg$parsemath_group() {\n      var s0, s1, s2, s3, s4, s5;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsebegin_group();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseend_group();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsemath_token();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f24(s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseend_group();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemath_token();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f24(s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        s3 = peg$parseend_group();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f25(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e25);\n        }\n      }\n      return s0;\n    }\n    function peg$parsebegin_display_math() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parseescape();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 91) {\n          s2 = peg$c10;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e26);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseend_display_math() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parseescape();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s2 = peg$c11;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e27);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsebegin_inline_math() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parseescape();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c12;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e28);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseend_inline_math() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parseescape();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s2 = peg$c13;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e29);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsebegin_env() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parseescape();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c14) {\n          s2 = peg$c14;\n          peg$currPos += 5;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e30);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseend_env() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parseescape();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 3) === peg$c15) {\n          s2 = peg$c15;\n          peg$currPos += 3;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e31);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsemath_env_name() {\n      var s0, s1;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 9) === peg$c16) {\n        s1 = peg$c16;\n        peg$currPos += 9;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e32);\n        }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.substr(peg$currPos, 8) === peg$c17) {\n          s1 = peg$c17;\n          peg$currPos += 8;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e33);\n          }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.substr(peg$currPos, 6) === peg$c18) {\n            s1 = peg$c18;\n            peg$currPos += 6;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e34);\n            }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c19) {\n              s1 = peg$c19;\n              peg$currPos += 5;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e35);\n              }\n            }\n            if (s1 === peg$FAILED) {\n              if (input.substr(peg$currPos, 8) === peg$c20) {\n                s1 = peg$c20;\n                peg$currPos += 8;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e36);\n                }\n              }\n              if (s1 === peg$FAILED) {\n                if (input.substr(peg$currPos, 7) === peg$c21) {\n                  s1 = peg$c21;\n                  peg$currPos += 7;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e37);\n                  }\n                }\n                if (s1 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 7) === peg$c22) {\n                    s1 = peg$c22;\n                    peg$currPos += 7;\n                  } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$e38);\n                    }\n                  }\n                  if (s1 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 6) === peg$c23) {\n                      s1 = peg$c23;\n                      peg$currPos += 6;\n                    } else {\n                      s1 = peg$FAILED;\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$e39);\n                      }\n                    }\n                    if (s1 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 9) === peg$c24) {\n                        s1 = peg$c24;\n                        peg$currPos += 9;\n                      } else {\n                        s1 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                          peg$fail(peg$e40);\n                        }\n                      }\n                      if (s1 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c25) {\n                          s1 = peg$c25;\n                          peg$currPos += 8;\n                        } else {\n                          s1 = peg$FAILED;\n                          if (peg$silentFails === 0) {\n                            peg$fail(peg$e41);\n                          }\n                        }\n                        if (s1 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 8) === peg$c26) {\n                            s1 = peg$c26;\n                            peg$currPos += 8;\n                          } else {\n                            s1 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                              peg$fail(peg$e42);\n                            }\n                          }\n                          if (s1 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 7) === peg$c27) {\n                              s1 = peg$c27;\n                              peg$currPos += 7;\n                            } else {\n                              s1 = peg$FAILED;\n                              if (peg$silentFails === 0) {\n                                peg$fail(peg$e43);\n                              }\n                            }\n                            if (s1 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 5) === peg$c28) {\n                                s1 = peg$c28;\n                                peg$currPos += 5;\n                              } else {\n                                s1 = peg$FAILED;\n                                if (peg$silentFails === 0) {\n                                  peg$fail(peg$e44);\n                                }\n                              }\n                              if (s1 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 4) === peg$c29) {\n                                  s1 = peg$c29;\n                                  peg$currPos += 4;\n                                } else {\n                                  s1 = peg$FAILED;\n                                  if (peg$silentFails === 0) {\n                                    peg$fail(peg$e45);\n                                  }\n                                }\n                                if (s1 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 11) === peg$c30) {\n                                    s1 = peg$c30;\n                                    peg$currPos += 11;\n                                  } else {\n                                    s1 = peg$FAILED;\n                                    if (peg$silentFails === 0) {\n                                      peg$fail(peg$e46);\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f32(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parseescape() {\n      var s0, s1;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c31;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e48);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f33();\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e47);\n        }\n      }\n      return s0;\n    }\n    function peg$parsebegin_group() {\n      var s0, s1;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c32;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e49);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f3(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parseend_group() {\n      var s0, s1;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 125) {\n        s1 = peg$c33;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e50);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f3(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parsemath_shift() {\n      var s0, s1;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 36) {\n        s1 = peg$c34;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e51);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f3(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parsealignment_tab() {\n      var s0, s1;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 38) {\n        s1 = peg$c35;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e52);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f3(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parsenl() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      if (input.charCodeAt(peg$currPos) === 13) {\n        s2 = peg$c36;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e54);\n        }\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = void 0;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 10) {\n          s2 = peg$c37;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e55);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 13) {\n          s0 = peg$c36;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e54);\n          }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c38) {\n            s0 = peg$c38;\n            peg$currPos += 2;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e56);\n            }\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e53);\n        }\n      }\n      return s0;\n    }\n    function peg$parsemacro_parameter() {\n      var s0, s1;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 35) {\n        s1 = peg$c39;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e57);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f3(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parsesuperscript() {\n      var s0, s1;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 94) {\n        s1 = peg$c40;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e58);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f3(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parsesubscript() {\n      var s0, s1;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 95) {\n        s1 = peg$c41;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e59);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f3(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parseignore() {\n      var s0;\n      if (input.charCodeAt(peg$currPos) === 0) {\n        s0 = peg$c42;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e60);\n        }\n      }\n      return s0;\n    }\n    function peg$parsesp() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$r0.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e61);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$r0.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e61);\n            }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f34();\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e8);\n        }\n      }\n      return s0;\n    }\n    function peg$parsechar() {\n      var s0, s1;\n      peg$silentFails++;\n      if (peg$r1.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e63);\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e62);\n        }\n      }\n      return s0;\n    }\n    function peg$parsenum() {\n      var s0, s1;\n      peg$silentFails++;\n      if (peg$r2.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e65);\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e64);\n        }\n      }\n      return s0;\n    }\n    function peg$parsepunctuation() {\n      var s0, s1;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (peg$r3.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e67);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f35(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e66);\n        }\n      }\n      return s0;\n    }\n    function peg$parsecomment_start() {\n      var s0;\n      if (input.charCodeAt(peg$currPos) === 37) {\n        s0 = peg$c0;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e7);\n        }\n      }\n      return s0;\n    }\n    function peg$parsefull_comment() {\n      var s0, s1;\n      peg$silentFails++;\n      s0 = peg$parseownline_comment();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsesameline_comment();\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e68);\n        }\n      }\n      return s0;\n    }\n    function peg$parseownline_comment() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsesp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsesp();\n      }\n      s3 = peg$parsenl();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      s2 = peg$parseleading_sp();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecomment();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f36(s2, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsesameline_comment() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsesp();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsesp();\n      }\n      s2 = peg$parsecomment();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f37(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsecomment() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsecomment_start();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parsenl();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e3);\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f24(s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsenl();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e3);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f24(s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseparbreak();\n        peg$silentFails--;\n        if (s4 !== peg$FAILED) {\n          peg$currPos = s3;\n          s3 = void 0;\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f38(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsecomment_start();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsenl();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e3);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f24(s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$parsenl();\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = void 0;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e3);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f24(s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          s3 = peg$currPos;\n          s4 = peg$parsenl();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsesp();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsesp();\n            }\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsecomment_start();\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = void 0;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsenl();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parseEOF();\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f39(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e69);\n        }\n      }\n      return s0;\n    }\n    function peg$parseleading_sp() {\n      var s0, s1, s2, s3, s4;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsestart_of_line();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsesp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsesp();\n        }\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n      return s0;\n    }\n    function peg$parsestart_of_line() {\n      var s0;\n      peg$savedPos = peg$currPos;\n      s0 = peg$f40();\n      if (s0) {\n        s0 = void 0;\n      } else {\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseEOF() {\n      var s0, s1;\n      s0 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      peg$silentFails--;\n      if (s1 === peg$FAILED) {\n        s0 = void 0;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function toString(e) {\n      if (typeof e === \"string\") {\n        return e;\n      }\n      if (typeof e.content === \"string\") {\n        return e.content;\n      }\n      if (e && e.type === \"whitespace\") {\n        return \" \";\n      }\n      return e;\n    }\n    function compare_env(g1, g2) {\n      const g1Name = typeof g1 === \"string\" ? g1 : g1.content.map(toString).join(\"\");\n      const g2Name = typeof g2 === \"string\" ? g2 : g2.content.map(toString).join(\"\");\n      return g1Name === g2Name;\n    }\n    function createNode(type, extra = {}) {\n      return __spreadProps(__spreadValues({ type }, extra), { position: location() });\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n}();\n\n// grammars/align-environment.pegjs\nvar align_environment_default = function() {\n  \"use strict\";\n  function peg$subclass(child, parent) {\n    function C() {\n      this.constructor = child;\n    }\n    C.prototype = parent.prototype;\n    child.prototype = new C();\n  }\n  function peg$SyntaxError(message, expected, found, location) {\n    var self = Error.call(this, message);\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n    }\n    self.expected = expected;\n    self.found = found;\n    self.location = location;\n    self.name = \"SyntaxError\";\n    return self;\n  }\n  peg$subclass(peg$SyntaxError, Error);\n  function peg$padEnd(str, targetLength, padString) {\n    padString = padString || \" \";\n    if (str.length > targetLength) {\n      return str;\n    }\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n  }\n  peg$SyntaxError.prototype.format = function(sources) {\n    var str = \"Error: \" + this.message;\n    if (this.location) {\n      var src = null;\n      var k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].source === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      var s = this.location.start;\n      var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n      if (src) {\n        var e = this.location.end;\n        var filler = peg$padEnd(\"\", s.line.toString().length);\n        var line = src[s.line - 1];\n        var last = s.line === e.line ? e.column : line.length + 1;\n        str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1) + peg$padEnd(\"\", last - s.column, \"^\");\n      } else {\n        str += \"\\n at \" + loc;\n      }\n    }\n    return str;\n  };\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n      literal: function(expectation) {\n        return '\"' + literalEscape(expectation.text) + '\"';\n      },\n      class: function(expectation) {\n        var escapedParts = expectation.parts.map(function(part) {\n          return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n        });\n        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n      },\n      any: function() {\n        return \"any character\";\n      },\n      end: function() {\n        return \"end of input\";\n      },\n      other: function(expectation) {\n        return expectation.description;\n      }\n    };\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    function literalEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function classEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n    function describeExpected(expected2) {\n      var descriptions = expected2.map(describeExpectation);\n      var i, j;\n      descriptions.sort();\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n        default:\n          return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n      }\n    }\n    function describeFound(found2) {\n      return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n    }\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n    var peg$FAILED = {};\n    var peg$source = options.grammarSource;\n    var peg$startRuleFunctions = { body: peg$parsebody };\n    var peg$startRuleFunction = peg$parsebody;\n    var peg$e0 = peg$anyExpectation();\n    var peg$f0 = function() {\n      return [];\n    };\n    var peg$f1 = function(x) {\n      return __spreadValues({ cells: [], colSeps: [] }, x);\n    };\n    var peg$f2 = function(rowItems, rowSep, trailingComment) {\n      return __spreadProps(__spreadValues({}, rowItems), { rowSep, trailingComment });\n    };\n    var peg$f3 = function(rowItems, trailingComment) {\n      return __spreadProps(__spreadValues({}, rowItems), { rowSep: null, trailingComment });\n    };\n    var peg$f4 = function(x) {\n      return x;\n    };\n    var peg$f5 = function(x) {\n      return {\n        cells: [],\n        colSeps: [],\n        rowSep: null,\n        trailingComment: x\n      };\n    };\n    var peg$f6 = function(x) {\n      return x;\n    };\n    var peg$f7 = function(colSep, cell) {\n      return { colSep, cell };\n    };\n    var peg$f8 = function(colSep) {\n      return { colSep };\n    };\n    var peg$f9 = function(a, b) {\n      return processRow(a, b);\n    };\n    var peg$f10 = function(b) {\n      return processRow(null, b);\n    };\n    var peg$f11 = function(tok) {\n      return options.isSameLineComment(tok);\n    };\n    var peg$f12 = function(tok) {\n      return tok;\n    };\n    var peg$f13 = function(tok) {\n      return options.isOwnLineComment(tok);\n    };\n    var peg$f14 = function(tok) {\n      return options.isWhitespace(tok);\n    };\n    var peg$f15 = function(tok) {\n      return options.isRowSep(tok);\n    };\n    var peg$f16 = function(tok) {\n      return options.isColSep(tok);\n    };\n    var peg$currPos = 0;\n    var peg$savedPos = 0;\n    var peg$posDetailsCache = [{ line: 1, column: 1 }];\n    var peg$maxFailPos = 0;\n    var peg$maxFailExpected = [];\n    var peg$silentFails = 0;\n    var peg$result;\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n      }\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n    function offset() {\n      return peg$savedPos;\n    }\n    function range() {\n      return {\n        source: peg$source,\n        start: peg$savedPos,\n        end: peg$currPos\n      };\n    }\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);\n    }\n    function error(message, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildSimpleError(message, location2);\n    }\n    function peg$literalExpectation(text2, ignoreCase) {\n      return { type: \"literal\", text: text2, ignoreCase };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts, inverted, ignoreCase };\n    }\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description };\n    }\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos];\n      var p;\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column\n        };\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n          p++;\n        }\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos);\n      var endPosDetails = peg$computePosDetails(endPos);\n      return {\n        source: peg$source,\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n    function peg$fail(expected2) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n      peg$maxFailExpected.push(expected2);\n    }\n    function peg$buildSimpleError(message, location2) {\n      return new peg$SyntaxError(message, null, null, location2);\n    }\n    function peg$buildStructuredError(expected2, found, location2) {\n      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);\n    }\n    function peg$parsebody() {\n      var s0, s1;\n      s0 = [];\n      s1 = peg$parsecomment_only_line();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parserow_with_end();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parserow_without_end();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          s1 = peg$parsecomment_only_line();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parserow_with_end();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parserow_without_end();\n            }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseEOL();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f0();\n        }\n        s0 = s1;\n      }\n      return s0;\n    }\n    function peg$parserow_with_end() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parserow_items();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s1;\n      s2 = peg$f1(s2);\n      s1 = s2;\n      s2 = peg$parserow_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetrailing_comment();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f2(s1, s2, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parserow_without_end() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parserow_items();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsetrailing_comment();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f3(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsetrailing_comment() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsewhitespace();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewhitespace();\n      }\n      s2 = peg$parsesame_line_comment();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f4(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsecomment_only_line() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsewhitespace();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewhitespace();\n      }\n      s2 = peg$parseown_line_comment();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f5(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsetoken() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      s2 = peg$parserow_sep();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsecol_sep();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsetrailing_comment();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseown_line_comment();\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = void 0;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f6(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsecell() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsetoken();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsetoken();\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n      return s0;\n    }\n    function peg$parseseparated_cell() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parsecol_sep();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsecell();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f7(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsecol_sep();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f8(s1);\n        }\n        s0 = s1;\n      }\n      return s0;\n    }\n    function peg$parserow_items() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$parsecell();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseseparated_cell();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseseparated_cell();\n        }\n        peg$savedPos = s0;\n        s0 = peg$f9(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseseparated_cell();\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parseseparated_cell();\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f10(s1);\n        }\n        s0 = s1;\n      }\n      return s0;\n    }\n    function peg$parsesame_line_comment() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f11(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f12(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseown_line_comment() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f13(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f12(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsewhitespace() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f14(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f12(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parserow_sep() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f15(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f12(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsecol_sep() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f16(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f12(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseEOL() {\n      var s0, s1;\n      s0 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      peg$silentFails--;\n      if (s1 === peg$FAILED) {\n        s0 = void 0;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function processRow(leadCell, otherCells) {\n      const cells = [leadCell || []];\n      const seps = [];\n      for (const x of otherCells) {\n        cells.push(x.cell || []);\n        seps.push(x.colSep);\n      }\n      return { cells, colSeps: seps };\n    }\n    if (!options.isWhitespace) {\n      try {\n        Object.assign(options, createMatchers([\"\\\\\", \"hline\", \"cr\"], [\"&\"]));\n      } catch (e) {\n        console.warn(\"Error when initializing parser\", e);\n      }\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n}();\n\n// grammars/xparse-argspec.pegjs\nvar xparse_argspec_default = function() {\n  \"use strict\";\n  function peg$subclass(child, parent) {\n    function C() {\n      this.constructor = child;\n    }\n    C.prototype = parent.prototype;\n    child.prototype = new C();\n  }\n  function peg$SyntaxError(message, expected, found, location) {\n    var self = Error.call(this, message);\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n    }\n    self.expected = expected;\n    self.found = found;\n    self.location = location;\n    self.name = \"SyntaxError\";\n    return self;\n  }\n  peg$subclass(peg$SyntaxError, Error);\n  function peg$padEnd(str, targetLength, padString) {\n    padString = padString || \" \";\n    if (str.length > targetLength) {\n      return str;\n    }\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n  }\n  peg$SyntaxError.prototype.format = function(sources) {\n    var str = \"Error: \" + this.message;\n    if (this.location) {\n      var src = null;\n      var k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].source === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      var s = this.location.start;\n      var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n      if (src) {\n        var e = this.location.end;\n        var filler = peg$padEnd(\"\", s.line.toString().length);\n        var line = src[s.line - 1];\n        var last = s.line === e.line ? e.column : line.length + 1;\n        str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1) + peg$padEnd(\"\", last - s.column, \"^\");\n      } else {\n        str += \"\\n at \" + loc;\n      }\n    }\n    return str;\n  };\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n      literal: function(expectation) {\n        return '\"' + literalEscape(expectation.text) + '\"';\n      },\n      class: function(expectation) {\n        var escapedParts = expectation.parts.map(function(part) {\n          return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n        });\n        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n      },\n      any: function() {\n        return \"any character\";\n      },\n      end: function() {\n        return \"end of input\";\n      },\n      other: function(expectation) {\n        return expectation.description;\n      }\n    };\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    function literalEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function classEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n    function describeExpected(expected2) {\n      var descriptions = expected2.map(describeExpectation);\n      var i, j;\n      descriptions.sort();\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n        default:\n          return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n      }\n    }\n    function describeFound(found2) {\n      return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n    }\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n    var peg$FAILED = {};\n    var peg$source = options.grammarSource;\n    var peg$startRuleFunctions = { args_spec_list: peg$parseargs_spec_list };\n    var peg$startRuleFunction = peg$parseargs_spec_list;\n    var peg$c0 = \"+\";\n    var peg$c1 = \"v\";\n    var peg$c2 = \"b\";\n    var peg$c3 = \"!\";\n    var peg$c4 = \"D\";\n    var peg$c5 = \"d\";\n    var peg$c6 = \"s\";\n    var peg$c7 = \"O\";\n    var peg$c8 = \"o\";\n    var peg$c9 = \"e\";\n    var peg$c10 = \"E\";\n    var peg$c11 = \"t\";\n    var peg$c12 = \"R\";\n    var peg$c13 = \"r\";\n    var peg$c14 = \"m\";\n    var peg$c15 = \"{\";\n    var peg$c16 = \"}\";\n    var peg$c17 = \" \";\n    var peg$c18 = \"\\n\";\n    var peg$c19 = \"\\r\";\n    var peg$e0 = peg$literalExpectation(\"+\", false);\n    var peg$e1 = peg$literalExpectation(\"v\", false);\n    var peg$e2 = peg$anyExpectation();\n    var peg$e3 = peg$literalExpectation(\"b\", false);\n    var peg$e4 = peg$literalExpectation(\"!\", false);\n    var peg$e5 = peg$literalExpectation(\"D\", false);\n    var peg$e6 = peg$literalExpectation(\"d\", false);\n    var peg$e7 = peg$literalExpectation(\"s\", false);\n    var peg$e8 = peg$literalExpectation(\"O\", false);\n    var peg$e9 = peg$literalExpectation(\"o\", false);\n    var peg$e10 = peg$literalExpectation(\"e\", false);\n    var peg$e11 = peg$literalExpectation(\"E\", false);\n    var peg$e12 = peg$literalExpectation(\"t\", false);\n    var peg$e13 = peg$literalExpectation(\"R\", false);\n    var peg$e14 = peg$literalExpectation(\"r\", false);\n    var peg$e15 = peg$literalExpectation(\"m\", false);\n    var peg$e16 = peg$literalExpectation(\"{\", false);\n    var peg$e17 = peg$literalExpectation(\"}\", false);\n    var peg$e18 = peg$literalExpectation(\" \", false);\n    var peg$e19 = peg$literalExpectation(\"\\n\", false);\n    var peg$e20 = peg$literalExpectation(\"\\r\", false);\n    var peg$f0 = function(x) {\n      return x;\n    };\n    var peg$f1 = function(spec) {\n      return spec;\n    };\n    var peg$f2 = function(spec) {\n      return spec;\n    };\n    var peg$f3 = function(openBrace) {\n      return createNode(\"verbatim\", { openBrace, closeBrace: openBrace });\n    };\n    var peg$f4 = function() {\n      return createNode(\"body\");\n    };\n    var peg$f5 = function(leading_bang, spec) {\n      return leading_bang ? __spreadProps(__spreadValues({}, spec), { noLeadingWhitespace: true }) : spec;\n    };\n    var peg$f6 = function(braceSpec, defaultArg) {\n      return createNode(\"optional\", __spreadProps(__spreadValues({}, braceSpec), { defaultArg }));\n    };\n    var peg$f7 = function(braceSpec) {\n      return createNode(\"optional\", braceSpec);\n    };\n    var peg$f8 = function() {\n      return createNode(\"optionalStar\");\n    };\n    var peg$f9 = function(g) {\n      return createNode(\"optional\", { defaultArg: g });\n    };\n    var peg$f10 = function() {\n      return createNode(\"optional\");\n    };\n    var peg$f11 = function(args) {\n      return createNode(\"embellishment\", {\n        embellishmentTokens: args.content\n      });\n    };\n    var peg$f12 = function(args, g) {\n      return createNode(\"embellishment\", {\n        embellishmentTokens: args.content,\n        defaultArg: g\n      });\n    };\n    var peg$f13 = function(tok) {\n      return createNode(\"optionalToken\", { token: tok });\n    };\n    var peg$f14 = function(braceSpec, defaultArg) {\n      return createNode(\"mandatory\", __spreadProps(__spreadValues({}, braceSpec), { defaultArg }));\n    };\n    var peg$f15 = function(braceSpec) {\n      return createNode(\"mandatory\", braceSpec);\n    };\n    var peg$f16 = function() {\n      return createNode(\"mandatory\");\n    };\n    var peg$f17 = function(openBrace, closeBrace) {\n      return { openBrace, closeBrace };\n    };\n    var peg$f18 = function(content) {\n      return { type: \"group\", content };\n    };\n    var peg$f19 = function() {\n      return \"\";\n    };\n    var peg$currPos = 0;\n    var peg$savedPos = 0;\n    var peg$posDetailsCache = [{ line: 1, column: 1 }];\n    var peg$maxFailPos = 0;\n    var peg$maxFailExpected = [];\n    var peg$silentFails = 0;\n    var peg$result;\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n      }\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n    function offset() {\n      return peg$savedPos;\n    }\n    function range() {\n      return {\n        source: peg$source,\n        start: peg$savedPos,\n        end: peg$currPos\n      };\n    }\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);\n    }\n    function error(message, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildSimpleError(message, location2);\n    }\n    function peg$literalExpectation(text2, ignoreCase) {\n      return { type: \"literal\", text: text2, ignoreCase };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts, inverted, ignoreCase };\n    }\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description };\n    }\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos];\n      var p;\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column\n        };\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n          p++;\n        }\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos);\n      var endPosDetails = peg$computePosDetails(endPos);\n      return {\n        source: peg$source,\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n    function peg$fail(expected2) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n      peg$maxFailExpected.push(expected2);\n    }\n    function peg$buildSimpleError(message, location2) {\n      return new peg$SyntaxError(message, null, null, location2);\n    }\n    function peg$buildStructuredError(expected2, found, location2) {\n      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);\n    }\n    function peg$parseargs_spec_list() {\n      var s0, s1, s2, s3, s4;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$parsewhitespace();\n      s4 = peg$parsearg_spec();\n      if (s4 !== peg$FAILED) {\n        peg$savedPos = s2;\n        s2 = peg$f0(s4);\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$parsewhitespace();\n        s4 = peg$parsearg_spec();\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s2;\n          s2 = peg$f0(s4);\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n      s2 = peg$parsewhitespace();\n      peg$savedPos = s0;\n      s0 = peg$f1(s1);\n      return s0;\n    }\n    function peg$parsearg_spec() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s1 = peg$c0;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      s2 = peg$parseoptional();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsemandatory();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseverbatim();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parserequired();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parsebody();\n            }\n          }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f2(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseverbatim() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 118) {\n        s1 = peg$c1;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e1);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f3(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsebody() {\n      var s0, s1;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 98) {\n        s1 = peg$c2;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f4();\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parseoptional() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c3;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e4);\n        }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      s2 = peg$parseoptional_star();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseoptional_standard();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseoptional_delimited();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseoptional_embellishment();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parseoptional_token();\n            }\n          }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f5(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseoptional_delimited() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 68) {\n        s1 = peg$c4;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e5);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebrace_spec();\n        s3 = peg$parsebraced_group();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f6(s2, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 100) {\n          s1 = peg$c5;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e6);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsebrace_spec();\n          peg$savedPos = s0;\n          s0 = peg$f7(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      return s0;\n    }\n    function peg$parseoptional_star() {\n      var s0, s1;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 115) {\n        s1 = peg$c6;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e7);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f8();\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parseoptional_standard() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 79) {\n        s1 = peg$c7;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e8);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebraced_group();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f9(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 111) {\n          s1 = peg$c8;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e9);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f10();\n        }\n        s0 = s1;\n      }\n      return s0;\n    }\n    function peg$parseoptional_embellishment() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 101) {\n        s1 = peg$c9;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e10);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebraced_group();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f11(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 69) {\n          s1 = peg$c10;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e11);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsebraced_group();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsebraced_group();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f12(s2, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      return s0;\n    }\n    function peg$parseoptional_token() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 116) {\n        s1 = peg$c11;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e12);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f13(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parserequired() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 82) {\n        s1 = peg$c12;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e13);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebrace_spec();\n        s3 = peg$parsebraced_group();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f14(s2, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 114) {\n          s1 = peg$c13;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e14);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsebrace_spec();\n          peg$savedPos = s0;\n          s0 = peg$f15(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      return s0;\n    }\n    function peg$parsemandatory() {\n      var s0, s1;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 109) {\n        s1 = peg$c14;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e15);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f16();\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parsebrace_spec() {\n      var s0, s1, s2, s3, s4, s5;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      peg$silentFails++;\n      s4 = peg$parsewhitespace_token();\n      peg$silentFails--;\n      if (s4 === peg$FAILED) {\n        s3 = void 0;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s1 = input.substring(s1, peg$currPos);\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parsewhitespace_token();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s2 = input.substring(s2, peg$currPos);\n      peg$savedPos = s0;\n      s0 = peg$f17(s1, s2);\n      return s0;\n    }\n    function peg$parsebraced_group() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c15;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e16);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        s5 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s6 = peg$c16;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e17);\n          }\n        }\n        peg$silentFails--;\n        if (s6 === peg$FAILED) {\n          s5 = void 0;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsebraced_group();\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = void 0;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s7 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e2);\n              }\n            }\n            if (s7 !== peg$FAILED) {\n              s5 = [s5, s6, s7];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsebraced_group();\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          peg$silentFails++;\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s6 = peg$c16;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e17);\n            }\n          }\n          peg$silentFails--;\n          if (s6 === peg$FAILED) {\n            s5 = void 0;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsebraced_group();\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = void 0;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s7 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e2);\n                }\n              }\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = input.substring(s3, peg$currPos);\n          } else {\n            s3 = s4;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsebraced_group();\n          }\n        }\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s3 = peg$c16;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e17);\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f18(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsewhitespace() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsewhitespace_token();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewhitespace_token();\n      }\n      peg$savedPos = s0;\n      s1 = peg$f19();\n      s0 = s1;\n      return s0;\n    }\n    function peg$parsewhitespace_token() {\n      var s0;\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s0 = peg$c17;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e18);\n        }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 10) {\n          s0 = peg$c18;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e19);\n          }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 13) {\n            s0 = peg$c19;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e20);\n            }\n          }\n        }\n      }\n      return s0;\n    }\n    const DEFAULT_OPTIONS = {\n      optional: { openBrace: \"[\", closeBrace: \"]\" },\n      mandatory: { openBrace: \"{\", closeBrace: \"}\" }\n    };\n    function createNode(type, options2) {\n      const computedOptions = DEFAULT_OPTIONS[type] || {};\n      return __spreadValues(__spreadValues({ type }, computedOptions), options2);\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n}();\n\n// grammars/pgfkeys.pegjs\nvar pgfkeys_default = function() {\n  \"use strict\";\n  function peg$subclass(child, parent) {\n    function C() {\n      this.constructor = child;\n    }\n    C.prototype = parent.prototype;\n    child.prototype = new C();\n  }\n  function peg$SyntaxError(message, expected, found, location) {\n    var self = Error.call(this, message);\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n    }\n    self.expected = expected;\n    self.found = found;\n    self.location = location;\n    self.name = \"SyntaxError\";\n    return self;\n  }\n  peg$subclass(peg$SyntaxError, Error);\n  function peg$padEnd(str, targetLength, padString) {\n    padString = padString || \" \";\n    if (str.length > targetLength) {\n      return str;\n    }\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n  }\n  peg$SyntaxError.prototype.format = function(sources) {\n    var str = \"Error: \" + this.message;\n    if (this.location) {\n      var src = null;\n      var k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].source === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      var s = this.location.start;\n      var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n      if (src) {\n        var e = this.location.end;\n        var filler = peg$padEnd(\"\", s.line.toString().length);\n        var line = src[s.line - 1];\n        var last = s.line === e.line ? e.column : line.length + 1;\n        str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1) + peg$padEnd(\"\", last - s.column, \"^\");\n      } else {\n        str += \"\\n at \" + loc;\n      }\n    }\n    return str;\n  };\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n      literal: function(expectation) {\n        return '\"' + literalEscape(expectation.text) + '\"';\n      },\n      class: function(expectation) {\n        var escapedParts = expectation.parts.map(function(part) {\n          return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n        });\n        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n      },\n      any: function() {\n        return \"any character\";\n      },\n      end: function() {\n        return \"end of input\";\n      },\n      other: function(expectation) {\n        return expectation.description;\n      }\n    };\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    function literalEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function classEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n    function describeExpected(expected2) {\n      var descriptions = expected2.map(describeExpectation);\n      var i, j;\n      descriptions.sort();\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n        default:\n          return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n      }\n    }\n    function describeFound(found2) {\n      return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n    }\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n    var peg$FAILED = {};\n    var peg$source = options.grammarSource;\n    var peg$startRuleFunctions = { body: peg$parsebody };\n    var peg$startRuleFunction = peg$parsebody;\n    var peg$e0 = peg$anyExpectation();\n    var peg$f0 = function() {\n      return [];\n    };\n    var peg$f1 = function(x) {\n      return x;\n    };\n    var peg$f2 = function(rowItems, trailingComment) {\n      return __spreadProps(__spreadValues({\n        itemParts: []\n      }, rowItems), {\n        trailingComment,\n        trailingComma: true\n      });\n    };\n    var peg$f3 = function(rowItems, trailingComment) {\n      return __spreadProps(__spreadValues({}, rowItems), { trailingComment });\n    };\n    var peg$f4 = function(a, b) {\n      return processItem(a, b);\n    };\n    var peg$f5 = function(b) {\n      return processItem(null, b);\n    };\n    var peg$f6 = function(cell) {\n      return { cell };\n    };\n    var peg$f7 = function() {\n      return {};\n    };\n    var peg$f8 = function(part) {\n      return part;\n    };\n    var peg$f9 = function(space, x) {\n      return {\n        trailingComment: x,\n        leadingParbreak: space.parbreak > 0\n      };\n    };\n    var peg$f10 = function(list) {\n      return {\n        whitespace: list.filter((x) => options.isWhitespace(x)).length,\n        parbreak: list.filter((x) => options.isParbreak(x)).length\n      };\n    };\n    var peg$f11 = function(tok) {\n      return options.isSameLineComment(tok);\n    };\n    var peg$f12 = function(tok) {\n      return tok;\n    };\n    var peg$f13 = function(tok) {\n      return options.isOwnLineComment(tok);\n    };\n    var peg$f14 = function(tok) {\n      return options.isWhitespace(tok);\n    };\n    var peg$f15 = function(tok) {\n      return options.isParbreak(tok);\n    };\n    var peg$f16 = function(tok) {\n      return options.isComma(tok);\n    };\n    var peg$f17 = function(tok) {\n      return options.isEquals(tok);\n    };\n    var peg$currPos = 0;\n    var peg$savedPos = 0;\n    var peg$posDetailsCache = [{ line: 1, column: 1 }];\n    var peg$maxFailPos = 0;\n    var peg$maxFailExpected = [];\n    var peg$silentFails = 0;\n    var peg$result;\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n      }\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n    function offset() {\n      return peg$savedPos;\n    }\n    function range() {\n      return {\n        source: peg$source,\n        start: peg$savedPos,\n        end: peg$currPos\n      };\n    }\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);\n    }\n    function error(message, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildSimpleError(message, location2);\n    }\n    function peg$literalExpectation(text2, ignoreCase) {\n      return { type: \"literal\", text: text2, ignoreCase };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts, inverted, ignoreCase };\n    }\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description };\n    }\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos];\n      var p;\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column\n        };\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n          p++;\n        }\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos);\n      var endPosDetails = peg$computePosDetails(endPos);\n      return {\n        source: peg$source,\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n    function peg$fail(expected2) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n      peg$maxFailExpected.push(expected2);\n    }\n    function peg$buildSimpleError(message, location2) {\n      return new peg$SyntaxError(message, null, null, location2);\n    }\n    function peg$buildStructuredError(expected2, found, location2) {\n      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);\n    }\n    function peg$parsebody() {\n      var s0, s1, s2;\n      s0 = [];\n      s1 = peg$parsecomment_only_line();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseitem_with_end();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseitem_without_end();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          s1 = peg$parsecomment_only_line();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseitem_with_end();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parseitem_without_end();\n            }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsewhitespace();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsewhitespace();\n        }\n        s2 = peg$parseEOL();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f0();\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      return s0;\n    }\n    function peg$parseitem() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsetoken();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsetoken();\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseitem_sep();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f1(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseitem_with_end() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n      s0 = peg$currPos;\n      s1 = peg$parsewhitespace_or_parbreaks();\n      s2 = peg$parserow_items();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parsewhitespace_or_parbreaks();\n      s4 = peg$parseitem_sep();\n      if (s4 !== peg$FAILED) {\n        s5 = [];\n        s6 = peg$parsewhitespace();\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          s6 = peg$parsewhitespace();\n        }\n        s6 = peg$parsetrailing_comment();\n        if (s6 === peg$FAILED) {\n          s6 = null;\n        }\n        s7 = [];\n        s8 = peg$parsewhitespace();\n        while (s8 !== peg$FAILED) {\n          s7.push(s8);\n          s8 = peg$parsewhitespace();\n        }\n        peg$savedPos = s0;\n        s0 = peg$f2(s2, s6);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseitem_without_end() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$parsewhitespace_or_parbreaks();\n      s2 = peg$parserow_items();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetrailing_comment();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f3(s2, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parserow_items() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$parseitem_part();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseseparated_part();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseseparated_part();\n        }\n        peg$savedPos = s0;\n        s0 = peg$f4(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseseparated_part();\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parseseparated_part();\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f5(s1);\n        }\n        s0 = s1;\n      }\n      return s0;\n    }\n    function peg$parseseparated_part() {\n      var s0, s1, s2, s3, s4;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseparbreak();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseparbreak();\n      }\n      s2 = peg$parseequals();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parseparbreak();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parseparbreak();\n        }\n        s4 = peg$parseitem_part();\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f6(s4);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseparbreak();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseparbreak();\n        }\n        s2 = peg$parseequals();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f7();\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      return s0;\n    }\n    function peg$parseitem_part() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsewhitespace();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewhitespace();\n      }\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parsenon_whitespace_non_parbreak_token();\n      if (s4 === peg$FAILED) {\n        s4 = peg$currPos;\n        s5 = peg$parsewhitespace();\n        if (s5 === peg$FAILED) {\n          s5 = peg$parseparbreak();\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$currPos;\n          s8 = [];\n          s9 = peg$parsewhitespace();\n          if (s9 === peg$FAILED) {\n            s9 = peg$parseparbreak();\n          }\n          while (s9 !== peg$FAILED) {\n            s8.push(s9);\n            s9 = peg$parsewhitespace();\n            if (s9 === peg$FAILED) {\n              s9 = peg$parseparbreak();\n            }\n          }\n          s9 = peg$parsenon_whitespace_non_parbreak_token();\n          if (s9 !== peg$FAILED) {\n            s8 = [s8, s9];\n            s7 = s8;\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = void 0;\n          } else {\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      }\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsenon_whitespace_non_parbreak_token();\n          if (s4 === peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = peg$parsewhitespace();\n            if (s5 === peg$FAILED) {\n              s5 = peg$parseparbreak();\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$currPos;\n              s8 = [];\n              s9 = peg$parsewhitespace();\n              if (s9 === peg$FAILED) {\n                s9 = peg$parseparbreak();\n              }\n              while (s9 !== peg$FAILED) {\n                s8.push(s9);\n                s9 = peg$parsewhitespace();\n                if (s9 === peg$FAILED) {\n                  s9 = peg$parseparbreak();\n                }\n              }\n              s9 = peg$parsenon_whitespace_non_parbreak_token();\n              if (s9 !== peg$FAILED) {\n                s8 = [s8, s9];\n                s7 = s8;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              peg$silentFails--;\n              if (s7 !== peg$FAILED) {\n                peg$currPos = s6;\n                s6 = void 0;\n              } else {\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewhitespace();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewhitespace();\n        }\n        peg$savedPos = s0;\n        s0 = peg$f8(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsetrailing_comment() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsewhitespace();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewhitespace();\n      }\n      s2 = peg$parsesame_line_comment();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f1(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsecomment_only_line() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parsewhitespace_or_parbreaks();\n      s2 = peg$parseown_line_comment();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f9(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsetoken() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsenon_token();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n      return s0;\n    }\n    function peg$parsenon_whitespace_non_parbreak_token() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsewhitespace();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseparbreak();\n      }\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetoken();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n      return s0;\n    }\n    function peg$parsenon_token() {\n      var s0;\n      s0 = peg$parseitem_sep();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseequals();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsetrailing_comment();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseown_line_comment();\n          }\n        }\n      }\n      return s0;\n    }\n    function peg$parsewhitespace_or_parbreaks() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsewhitespace();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseparbreak();\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewhitespace();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseparbreak();\n        }\n      }\n      peg$savedPos = s0;\n      s1 = peg$f10(s1);\n      s0 = s1;\n      return s0;\n    }\n    function peg$parsesame_line_comment() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f11(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f12(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseown_line_comment() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f13(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f12(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsewhitespace() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f14(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f12(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseparbreak() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f15(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f12(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseitem_sep() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f16(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f12(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseequals() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f17(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f12(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseEOL() {\n      var s0, s1;\n      s0 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      peg$silentFails--;\n      if (s1 === peg$FAILED) {\n        s0 = void 0;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function processItem(leadCell, otherCells) {\n      const cells = [leadCell || []];\n      for (const x of otherCells) {\n        cells.push(x.cell || []);\n      }\n      return { itemParts: cells };\n    }\n    if (!options.isWhitespace) {\n      try {\n        Object.assign(options, createMatchers([\"\\\\\", \"hline\", \"cr\"], [\"&\"]));\n        Object.assign(options, {\n          isComma(node) {\n            return node.type === \"string\" && node.content === \",\";\n          },\n          isEquals(node) {\n            return node.type === \"string\" && node.content === \"=\";\n          },\n          isParbreak(node) {\n            return node.type === \"parbreak\";\n          }\n        });\n      } catch (e) {\n        console.warn(\"Error when initializing parser\", e);\n      }\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n}();\n\n// grammars/macro-substitutions.pegjs\nvar macro_substitutions_default = function() {\n  \"use strict\";\n  function peg$subclass(child, parent) {\n    function C() {\n      this.constructor = child;\n    }\n    C.prototype = parent.prototype;\n    child.prototype = new C();\n  }\n  function peg$SyntaxError(message, expected, found, location) {\n    var self = Error.call(this, message);\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n    }\n    self.expected = expected;\n    self.found = found;\n    self.location = location;\n    self.name = \"SyntaxError\";\n    return self;\n  }\n  peg$subclass(peg$SyntaxError, Error);\n  function peg$padEnd(str, targetLength, padString) {\n    padString = padString || \" \";\n    if (str.length > targetLength) {\n      return str;\n    }\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n  }\n  peg$SyntaxError.prototype.format = function(sources) {\n    var str = \"Error: \" + this.message;\n    if (this.location) {\n      var src = null;\n      var k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].source === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      var s = this.location.start;\n      var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n      if (src) {\n        var e = this.location.end;\n        var filler = peg$padEnd(\"\", s.line.toString().length);\n        var line = src[s.line - 1];\n        var last = s.line === e.line ? e.column : line.length + 1;\n        str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1) + peg$padEnd(\"\", last - s.column, \"^\");\n      } else {\n        str += \"\\n at \" + loc;\n      }\n    }\n    return str;\n  };\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n      literal: function(expectation) {\n        return '\"' + literalEscape(expectation.text) + '\"';\n      },\n      class: function(expectation) {\n        var escapedParts = expectation.parts.map(function(part) {\n          return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n        });\n        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n      },\n      any: function() {\n        return \"any character\";\n      },\n      end: function() {\n        return \"end of input\";\n      },\n      other: function(expectation) {\n        return expectation.description;\n      }\n    };\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    function literalEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function classEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n    function describeExpected(expected2) {\n      var descriptions = expected2.map(describeExpectation);\n      var i, j;\n      descriptions.sort();\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n        default:\n          return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n      }\n    }\n    function describeFound(found2) {\n      return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n    }\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n    var peg$FAILED = {};\n    var peg$source = options.grammarSource;\n    var peg$startRuleFunctions = { body: peg$parsebody };\n    var peg$startRuleFunction = peg$parsebody;\n    var peg$e0 = peg$anyExpectation();\n    var peg$f0 = function(e) {\n      return [].concat(...e).filter((n) => !!n);\n    };\n    var peg$f1 = function() {\n      return [];\n    };\n    var peg$f2 = function(tok) {\n      return options.isHash(tok);\n    };\n    var peg$f3 = function(tok) {\n      return tok;\n    };\n    var peg$f4 = function(tok) {\n      return options.isNumber(tok);\n    };\n    var peg$f5 = function() {\n      return { type: \"string\", content: \"#\" };\n    };\n    var peg$f6 = function(num) {\n      const split = options.splitNumber(num);\n      return [{ type: \"hash_number\", number: split.number }, split.rest];\n    };\n    var peg$currPos = 0;\n    var peg$savedPos = 0;\n    var peg$posDetailsCache = [{ line: 1, column: 1 }];\n    var peg$maxFailPos = 0;\n    var peg$maxFailExpected = [];\n    var peg$silentFails = 0;\n    var peg$result;\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n      }\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n    function offset() {\n      return peg$savedPos;\n    }\n    function range() {\n      return {\n        source: peg$source,\n        start: peg$savedPos,\n        end: peg$currPos\n      };\n    }\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);\n    }\n    function error(message, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildSimpleError(message, location2);\n    }\n    function peg$literalExpectation(text2, ignoreCase) {\n      return { type: \"literal\", text: text2, ignoreCase };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts, inverted, ignoreCase };\n    }\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description };\n    }\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos];\n      var p;\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column\n        };\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n          p++;\n        }\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos);\n      var endPosDetails = peg$computePosDetails(endPos);\n      return {\n        source: peg$source,\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n    function peg$fail(expected2) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n      peg$maxFailExpected.push(expected2);\n    }\n    function peg$buildSimpleError(message, location2) {\n      return new peg$SyntaxError(message, null, null, location2);\n    }\n    function peg$buildStructuredError(expected2, found, location2) {\n      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);\n    }\n    function peg$parsebody() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsedouble_hash();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsehash_number();\n        if (s2 === peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e0);\n            }\n          }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsedouble_hash();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsehash_number();\n            if (s2 === peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e0);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f0(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseEOL();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f1();\n        }\n        s0 = s1;\n      }\n      return s0;\n    }\n    function peg$parsehash() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f2(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f3(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsenumber() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f4(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f3(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsedouble_hash() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parsehash();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsehash();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f5();\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsehash_number() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parsehash();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsenumber();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f6(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseEOL() {\n      var s0, s1;\n      s0 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      peg$silentFails--;\n      if (s1 === peg$FAILED) {\n        s0 = void 0;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    if (!options.isHash) {\n      try {\n        Object.assign(options, {\n          isHash: (node) => node.type === \"string\" && node.content === \"#\",\n          isNumber: (node) => node.type === \"string\" && 0 < +node.content.charAt(0),\n          splitNumber: (node) => {\n            const number = +node.content.charAt(0);\n            if (node.content.length > 1) {\n              return {\n                number,\n                rest: {\n                  type: \"string\",\n                  content: node.content.slice(1)\n                }\n              };\n            }\n            return { number };\n          }\n        });\n      } catch (e) {\n        console.warn(\"Error when initializing parser\", e);\n      }\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n}();\n\n// grammars/ligatures.pegjs\nvar ligatures_default = function() {\n  \"use strict\";\n  function peg$subclass(child, parent) {\n    function C() {\n      this.constructor = child;\n    }\n    C.prototype = parent.prototype;\n    child.prototype = new C();\n  }\n  function peg$SyntaxError(message, expected, found, location) {\n    var self = Error.call(this, message);\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n    }\n    self.expected = expected;\n    self.found = found;\n    self.location = location;\n    self.name = \"SyntaxError\";\n    return self;\n  }\n  peg$subclass(peg$SyntaxError, Error);\n  function peg$padEnd(str, targetLength, padString) {\n    padString = padString || \" \";\n    if (str.length > targetLength) {\n      return str;\n    }\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n  }\n  peg$SyntaxError.prototype.format = function(sources) {\n    var str = \"Error: \" + this.message;\n    if (this.location) {\n      var src = null;\n      var k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].source === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      var s = this.location.start;\n      var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n      if (src) {\n        var e = this.location.end;\n        var filler = peg$padEnd(\"\", s.line.toString().length);\n        var line = src[s.line - 1];\n        var last = s.line === e.line ? e.column : line.length + 1;\n        str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1) + peg$padEnd(\"\", last - s.column, \"^\");\n      } else {\n        str += \"\\n at \" + loc;\n      }\n    }\n    return str;\n  };\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n      literal: function(expectation) {\n        return '\"' + literalEscape(expectation.text) + '\"';\n      },\n      class: function(expectation) {\n        var escapedParts = expectation.parts.map(function(part) {\n          return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n        });\n        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n      },\n      any: function() {\n        return \"any character\";\n      },\n      end: function() {\n        return \"end of input\";\n      },\n      other: function(expectation) {\n        return expectation.description;\n      }\n    };\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    function literalEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function classEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n    function describeExpected(expected2) {\n      var descriptions = expected2.map(describeExpectation);\n      var i, j;\n      descriptions.sort();\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n        default:\n          return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n      }\n    }\n    function describeFound(found2) {\n      return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n    }\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n    var peg$FAILED = {};\n    var peg$source = options.grammarSource;\n    var peg$startRuleFunctions = { body: peg$parsebody };\n    var peg$startRuleFunction = peg$parsebody;\n    var peg$e0 = peg$anyExpectation();\n    var peg$f0 = function(e) {\n      return [].concat(...e).filter((n) => !!n);\n    };\n    var peg$f1 = function() {\n      return [];\n    };\n    var peg$f2 = function(toks) {\n      return options.isRecognized(toks);\n    };\n    var peg$f3 = function(toks) {\n      return options.isRecognized(toks);\n    };\n    var peg$f4 = function(tok1, tok2) {\n      const split = options.split(tok2);\n      return options.isRecognized([tok1, split[0]]);\n    };\n    var peg$f5 = function(tok1, tok2) {\n      const split = options.split(tok2);\n      return [options.isRecognized([tok1, split[0]]), split[1]];\n    };\n    var peg$f6 = function(tok1, tok2) {\n      return options.isRecognized([tok1, tok2]);\n    };\n    var peg$f7 = function(tok1, tok2) {\n      return options.isRecognized([tok1, tok2]);\n    };\n    var peg$f8 = function(tok) {\n      return options.isRecognized([tok]);\n    };\n    var peg$f9 = function(tok) {\n      return options.isRecognized([tok]);\n    };\n    var peg$f10 = function(tok) {\n      return options.isMacro(tok);\n    };\n    var peg$f11 = function(tok) {\n      return tok;\n    };\n    var peg$f12 = function(tok) {\n      return options.isWhitespace(tok);\n    };\n    var peg$f13 = function(tok) {\n      return options.isSplitable(tok);\n    };\n    var peg$currPos = 0;\n    var peg$savedPos = 0;\n    var peg$posDetailsCache = [{ line: 1, column: 1 }];\n    var peg$maxFailPos = 0;\n    var peg$maxFailExpected = [];\n    var peg$silentFails = 0;\n    var peg$result;\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n      }\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n    function offset() {\n      return peg$savedPos;\n    }\n    function range() {\n      return {\n        source: peg$source,\n        start: peg$savedPos,\n        end: peg$currPos\n      };\n    }\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);\n    }\n    function error(message, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildSimpleError(message, location2);\n    }\n    function peg$literalExpectation(text2, ignoreCase) {\n      return { type: \"literal\", text: text2, ignoreCase };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts, inverted, ignoreCase };\n    }\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description };\n    }\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos];\n      var p;\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column\n        };\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n          p++;\n        }\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos);\n      var endPosDetails = peg$computePosDetails(endPos);\n      return {\n        source: peg$source,\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n    function peg$fail(expected2) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n      peg$maxFailExpected.push(expected2);\n    }\n    function peg$buildSimpleError(message, location2) {\n      return new peg$SyntaxError(message, null, null, location2);\n    }\n    function peg$buildStructuredError(expected2, found, location2) {\n      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);\n    }\n    function peg$parsebody() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsetriple_ligature();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsedouble_ligature();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsemono_ligature();\n          if (s2 === peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e0);\n              }\n            }\n          }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsetriple_ligature();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsedouble_ligature();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parsemono_ligature();\n              if (s2 === peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s2 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s2 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e0);\n                  }\n                }\n              }\n            }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f0(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseEOL();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f1();\n        }\n        s0 = s1;\n      }\n      return s0;\n    }\n    function peg$parsetriple_ligature() {\n      var s0, s1, s2, s3, s4;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e0);\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f2(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f3(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsedouble_ligature() {\n      var s0;\n      s0 = peg$parsedouble_macro_ligature();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsedouble_macro_ligature_extracted();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsedouble_char_ligature();\n        }\n      }\n      return s0;\n    }\n    function peg$parsedouble_macro_ligature_extracted() {\n      var s0, s1, s2, s3, s4;\n      s0 = peg$currPos;\n      s1 = peg$parsemacro();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsewhitespace();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsewhitespace();\n        }\n        s3 = peg$parsesplitable();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s4 = peg$f4(s1, s3);\n          if (s4) {\n            s4 = void 0;\n          } else {\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f5(s1, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsedouble_macro_ligature() {\n      var s0, s1, s2, s3, s4;\n      s0 = peg$currPos;\n      s1 = peg$parsemacro();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsewhitespace();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsewhitespace();\n        }\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s4 = peg$f6(s1, s3);\n          if (s4) {\n            s4 = void 0;\n          } else {\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f7(s1, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsedouble_char_ligature() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f2(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f3(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsemono_ligature() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f8(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f9(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsemacro() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f10(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f11(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsewhitespace() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f12(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f11(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsesplitable() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f13(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f11(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseEOL() {\n      var s0, s1;\n      s0 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      peg$silentFails--;\n      if (s1 === peg$FAILED) {\n        s0 = void 0;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    if (!options.isWhitespace) {\n      try {\n        Object.assign(options, {\n          isMacro: (node) => node.type === \"macro\",\n          isWhitespace: (node) => node.type === \"whitespace\",\n          isRecognized: (nodes) => {\n            if (nodes.length == 2 && nodes[0].content === \"^\" && nodes[1].content === \"o\") {\n              return { type: \"string\", content: \"\\xF4\" };\n            }\n            return null;\n          },\n          isSplitable: (node) => node.type === \"string\" && node.content.length > 1,\n          split: (node) => [\n            { type: \"string\", content: node.content.charAt(0) },\n            { type: \"string\", content: node.content.slice(1) }\n          ]\n        });\n      } catch (e) {\n        console.warn(\"Error when initializing parser\", e);\n      }\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n}();\n\n// grammars/xcolor-expressions.pegjs\nvar xcolor_expressions_default = function() {\n  \"use strict\";\n  function peg$subclass(child, parent) {\n    function C() {\n      this.constructor = child;\n    }\n    C.prototype = parent.prototype;\n    child.prototype = new C();\n  }\n  function peg$SyntaxError(message, expected, found, location) {\n    var self = Error.call(this, message);\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n    }\n    self.expected = expected;\n    self.found = found;\n    self.location = location;\n    self.name = \"SyntaxError\";\n    return self;\n  }\n  peg$subclass(peg$SyntaxError, Error);\n  function peg$padEnd(str, targetLength, padString) {\n    padString = padString || \" \";\n    if (str.length > targetLength) {\n      return str;\n    }\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n  }\n  peg$SyntaxError.prototype.format = function(sources) {\n    var str = \"Error: \" + this.message;\n    if (this.location) {\n      var src = null;\n      var k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].source === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      var s = this.location.start;\n      var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n      if (src) {\n        var e = this.location.end;\n        var filler = peg$padEnd(\"\", s.line.toString().length);\n        var line = src[s.line - 1];\n        var last = s.line === e.line ? e.column : line.length + 1;\n        str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1) + peg$padEnd(\"\", last - s.column, \"^\");\n      } else {\n        str += \"\\n at \" + loc;\n      }\n    }\n    return str;\n  };\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n      literal: function(expectation) {\n        return '\"' + literalEscape(expectation.text) + '\"';\n      },\n      class: function(expectation) {\n        var escapedParts = expectation.parts.map(function(part) {\n          return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n        });\n        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n      },\n      any: function() {\n        return \"any character\";\n      },\n      end: function() {\n        return \"end of input\";\n      },\n      other: function(expectation) {\n        return expectation.description;\n      }\n    };\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    function literalEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function classEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n    function describeExpected(expected2) {\n      var descriptions = expected2.map(describeExpectation);\n      var i, j;\n      descriptions.sort();\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n        default:\n          return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n      }\n    }\n    function describeFound(found2) {\n      return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n    }\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n    var peg$FAILED = {};\n    var peg$source = options.grammarSource;\n    var peg$startRuleFunctions = { start: peg$parsestart };\n    var peg$startRuleFunction = peg$parsestart;\n    var peg$c0 = \";\";\n    var peg$c1 = \",\";\n    var peg$c2 = \":\";\n    var peg$c3 = \"/\";\n    var peg$c4 = \">\";\n    var peg$c5 = \"!\";\n    var peg$c6 = \".\";\n    var peg$c7 = \"!![\";\n    var peg$c8 = \"]\";\n    var peg$c9 = \"!!\";\n    var peg$c10 = \"+\";\n    var peg$c11 = \"-\";\n    var peg$r0 = /^[a-zA-Z0-9]/;\n    var peg$r1 = /^[0-9]/;\n    var peg$r2 = /^[ \\t\\n\\r]/;\n    var peg$r3 = /^[0-9a-fA-F]/;\n    var peg$e0 = peg$anyExpectation();\n    var peg$e1 = peg$literalExpectation(\";\", false);\n    var peg$e2 = peg$literalExpectation(\",\", false);\n    var peg$e3 = peg$otherExpectation(\"model list\");\n    var peg$e4 = peg$literalExpectation(\":\", false);\n    var peg$e5 = peg$literalExpectation(\"/\", false);\n    var peg$e6 = peg$otherExpectation(\"model\");\n    var peg$e7 = peg$otherExpectation(\"color spec list\");\n    var peg$e8 = peg$otherExpectation(\"color spec\");\n    var peg$e9 = peg$otherExpectation(\"color\");\n    var peg$e10 = peg$otherExpectation(\"function expression\");\n    var peg$e11 = peg$literalExpectation(\">\", false);\n    var peg$e12 = peg$otherExpectation(\"function\");\n    var peg$e13 = peg$otherExpectation(\"extended expression\");\n    var peg$e14 = peg$otherExpectation(\"core model\");\n    var peg$e15 = peg$otherExpectation(\"expr\");\n    var peg$e16 = peg$literalExpectation(\"!\", false);\n    var peg$e17 = peg$otherExpectation(\"mix expr\");\n    var peg$e18 = peg$otherExpectation(\"name\");\n    var peg$e19 = peg$literalExpectation(\".\", false);\n    var peg$e20 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"]], false, false);\n    var peg$e21 = peg$otherExpectation(\"postfix\");\n    var peg$e22 = peg$literalExpectation(\"!![\", false);\n    var peg$e23 = peg$literalExpectation(\"]\", false);\n    var peg$e24 = peg$literalExpectation(\"!!\", false);\n    var peg$e25 = peg$otherExpectation(\"prefix\");\n    var peg$e26 = peg$otherExpectation(\"plus\");\n    var peg$e27 = peg$literalExpectation(\"+\", false);\n    var peg$e28 = peg$otherExpectation(\"minus\");\n    var peg$e29 = peg$literalExpectation(\"-\", false);\n    var peg$e30 = peg$otherExpectation(\"num\");\n    var peg$e31 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n    var peg$e32 = peg$otherExpectation(\"positive float\");\n    var peg$e33 = peg$otherExpectation(\"divisor\");\n    var peg$e34 = peg$otherExpectation(\"int\");\n    var peg$e35 = peg$otherExpectation(\"whitespace\");\n    var peg$e36 = peg$classExpectation([\" \", \"\t\", \"\\n\", \"\\r\"], false, false);\n    var peg$e37 = peg$classExpectation([[\"0\", \"9\"], [\"a\", \"f\"], [\"A\", \"F\"]], false, false);\n    var peg$f0 = function(m) {\n      return m;\n    };\n    var peg$f1 = function(a) {\n      return { type: \"invalid_spec\", content: a };\n    };\n    var peg$f2 = function(f, c) {\n      return c;\n    };\n    var peg$f3 = function(f, r) {\n      return { type: \"color_set\", content: [f].concat(r) };\n    };\n    var peg$f4 = function(n, s) {\n      return { type: \"color_set_item\", name: n, spec_list: s };\n    };\n    var peg$f5 = function(c, m) {\n      return { type: \"model_list\", contents: m, core_model: c };\n    };\n    var peg$f6 = function(m) {\n      return { type: \"model_list\", contents: m, core_model: null };\n    };\n    var peg$f7 = function(m, a) {\n      return a;\n    };\n    var peg$f8 = function(m, r) {\n      return [m].concat(r);\n    };\n    var peg$f9 = function(s, a) {\n      return a;\n    };\n    var peg$f10 = function(s, r) {\n      return { type: \"spec_list\", content: [s].concat(r) };\n    };\n    var peg$f11 = function(c) {\n      return { type: \"hex_spec\", content: [c] };\n    };\n    var peg$f12 = function(c, d) {\n      return d;\n    };\n    var peg$f13 = function(c, r) {\n      return { type: \"num_spec\", content: r ? [c].concat(r) : [c] };\n    };\n    var peg$f14 = function(c, fs) {\n      return { type: \"color\", color: c, functions: fs };\n    };\n    var peg$f15 = function(f, n) {\n      return n;\n    };\n    var peg$f16 = function(f, args) {\n      return { type: \"function\", name: f, args };\n    };\n    var peg$f17 = function(core, d, e, es) {\n      return {\n        type: \"extended_expr\",\n        core_model: core,\n        div: d,\n        expressions: [e].concat(es)\n      };\n    };\n    var peg$f18 = function(core, e, es) {\n      return {\n        type: \"extended_expr\",\n        core_model: core,\n        div: null,\n        expressions: [e].concat(es)\n      };\n    };\n    var peg$f19 = function(e, d) {\n      return { type: \"weighted_expr\", color: e, weight: d };\n    };\n    var peg$f20 = function(e) {\n      return e;\n    };\n    var peg$f21 = function(p, n, e, po) {\n      return {\n        type: \"expr\",\n        prefix: p,\n        name: n,\n        mix_expr: e,\n        postfix: po\n      };\n    };\n    var peg$f22 = function(p, n) {\n      return { type: \"complete_mix\", mix_percent: p, name: n };\n    };\n    var peg$f23 = function(p) {\n      return { type: \"partial_mix\", mix_percent: p };\n    };\n    var peg$f24 = function(c, p) {\n      return c.concat(p || []);\n    };\n    var peg$f25 = function(n) {\n      return { type: \"postfix\", num: n };\n    };\n    var peg$f26 = function(p) {\n      return { type: \"postfix\", plusses: p };\n    };\n    var peg$f27 = function(n) {\n      return parseInt(n, 10);\n    };\n    var peg$f28 = function(n) {\n      return parseFloat(n);\n    };\n    var peg$f29 = function(n) {\n      return n;\n    };\n    var peg$f30 = function(n) {\n      return -n;\n    };\n    var peg$f31 = function(m, n) {\n      return m ? -n : n;\n    };\n    var peg$f32 = function(h) {\n      return h.toUpperCase();\n    };\n    var peg$currPos = 0;\n    var peg$savedPos = 0;\n    var peg$posDetailsCache = [{ line: 1, column: 1 }];\n    var peg$maxFailPos = 0;\n    var peg$maxFailExpected = [];\n    var peg$silentFails = 0;\n    var peg$result;\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n      }\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n    function offset() {\n      return peg$savedPos;\n    }\n    function range() {\n      return {\n        source: peg$source,\n        start: peg$savedPos,\n        end: peg$currPos\n      };\n    }\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);\n    }\n    function error(message, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildSimpleError(message, location2);\n    }\n    function peg$literalExpectation(text2, ignoreCase) {\n      return { type: \"literal\", text: text2, ignoreCase };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts, inverted, ignoreCase };\n    }\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description };\n    }\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos];\n      var p;\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column\n        };\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n          p++;\n        }\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos);\n      var endPosDetails = peg$computePosDetails(endPos);\n      return {\n        source: peg$source,\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n    function peg$fail(expected2) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n      peg$maxFailExpected.push(expected2);\n    }\n    function peg$buildSimpleError(message, location2) {\n      return new peg$SyntaxError(message, null, null, location2);\n    }\n    function peg$buildStructuredError(expected2, found, location2) {\n      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);\n    }\n    function peg$parsestart() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$parsespec();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEOL();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f0(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsespec_list();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseEOL();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f0(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsecolor();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseEOL();\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f0(s1);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsemodel_list();\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parseEOL();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f0(s1);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parsecolor_set_spec();\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parseEOL();\n                if (s2 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s0 = peg$f0(s1);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$currPos;\n                s2 = [];\n                if (input.length > peg$currPos) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e0);\n                  }\n                }\n                while (s3 !== peg$FAILED) {\n                  s2.push(s3);\n                  if (input.length > peg$currPos) {\n                    s3 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$e0);\n                    }\n                  }\n                }\n                s1 = input.substring(s1, peg$currPos);\n                peg$savedPos = s0;\n                s1 = peg$f1(s1);\n                s0 = s1;\n              }\n            }\n          }\n        }\n      }\n      return s0;\n    }\n    function peg$parsecolor_set_spec() {\n      var s0, s1, s2, s3, s4, s5;\n      s0 = peg$currPos;\n      s1 = peg$parsecolor_set_item();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 59) {\n          s4 = peg$c0;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e1);\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecolor_set_item();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f2(s1, s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 59) {\n            s4 = peg$c0;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e1);\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecolor_set_item();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f2(s1, s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        peg$savedPos = s0;\n        s0 = peg$f3(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsecolor_set_item() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$parsename();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c1;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsespec_list();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f4(s1, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsemodel_list() {\n      var s0, s1, s2, s3;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsecore_model();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s2 = peg$c2;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e4);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsemodel_list_tail();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f5(s1, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsemodel_list_tail();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f6(s1);\n        }\n        s0 = s1;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      return s0;\n    }\n    function peg$parsemodel_list_tail() {\n      var s0, s1, s2, s3, s4, s5;\n      s0 = peg$currPos;\n      s1 = peg$parsemodel();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s4 = peg$c3;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e5);\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsemodel();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f7(s1, s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s4 = peg$c3;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e5);\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemodel();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f7(s1, s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        peg$savedPos = s0;\n        s0 = peg$f8(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsemodel() {\n      var s0, s1;\n      peg$silentFails++;\n      s0 = peg$parsecore_model();\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e6);\n        }\n      }\n      return s0;\n    }\n    function peg$parsespec_list() {\n      var s0, s1, s2, s3, s4, s5;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsespec();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s4 = peg$c3;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e5);\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsespec();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f9(s1, s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s4 = peg$c3;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e5);\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsespec();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f9(s1, s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        peg$savedPos = s0;\n        s0 = peg$f10(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e7);\n        }\n      }\n      return s0;\n    }\n    function peg$parsespec() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      s3 = peg$parsehex();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsehex();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehex();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehex();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehex();\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parsehex();\n                if (s8 !== peg$FAILED) {\n                  s3 = [s3, s4, s5, s6, s7, s8];\n                  s2 = s3;\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f11(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsedec();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s4 = peg$c1;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e2);\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsedec();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f12(s1, s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s4 = peg$c1;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e2);\n                }\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsedec();\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s3 = peg$f12(s1, s5);\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 === peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$parsesp();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsedec();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f12(s1, s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$currPos;\n                s4 = peg$parsesp();\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsedec();\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s3;\n                    s3 = peg$f12(s1, s5);\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n          }\n          if (s2 === peg$FAILED) {\n            s2 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f13(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e8);\n        }\n      }\n      return s0;\n    }\n    function peg$parsecolor() {\n      var s0, s1, s2, s3;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsecolor_expr();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsefunc_expr();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefunc_expr();\n        }\n        peg$savedPos = s0;\n        s0 = peg$f14(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e9);\n        }\n      }\n      return s0;\n    }\n    function peg$parsecolor_expr() {\n      var s0;\n      s0 = peg$parseext_expr();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsename();\n        }\n      }\n      return s0;\n    }\n    function peg$parsefunc_expr() {\n      var s0, s1, s2, s3, s4, s5, s6;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 62) {\n        s1 = peg$c4;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e11);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsefunction();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c1;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e2);\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseint();\n            if (s6 !== peg$FAILED) {\n              peg$savedPos = s4;\n              s4 = peg$f15(s2, s6);\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e2);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseint();\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s4;\n                s4 = peg$f15(s2, s6);\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n          peg$savedPos = s0;\n          s0 = peg$f16(s2, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e10);\n        }\n      }\n      return s0;\n    }\n    function peg$parsefunction() {\n      var s0, s1;\n      peg$silentFails++;\n      s0 = peg$parsename();\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e12);\n        }\n      }\n      return s0;\n    }\n    function peg$parseext_expr() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsecore_model();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c1;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsediv();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s4 = peg$c2;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e4);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseweighted_expr();\n              if (s5 !== peg$FAILED) {\n                s6 = [];\n                s7 = peg$parseadditional_weighted_expr();\n                while (s7 !== peg$FAILED) {\n                  s6.push(s7);\n                  s7 = peg$parseadditional_weighted_expr();\n                }\n                peg$savedPos = s0;\n                s0 = peg$f17(s1, s3, s5, s6);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsecore_model();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s2 = peg$c2;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e4);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseweighted_expr();\n            if (s3 !== peg$FAILED) {\n              s4 = [];\n              s5 = peg$parseadditional_weighted_expr();\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$parseadditional_weighted_expr();\n              }\n              peg$savedPos = s0;\n              s0 = peg$f18(s1, s3, s4);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e13);\n        }\n      }\n      return s0;\n    }\n    function peg$parseweighted_expr() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$parseexpr();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c1;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsedec();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f19(s1, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseadditional_weighted_expr() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 59) {\n        s1 = peg$c0;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e1);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseweighted_expr();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f20(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsecore_model() {\n      var s0, s1;\n      peg$silentFails++;\n      s0 = peg$parsename();\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e14);\n        }\n      }\n      return s0;\n    }\n    function peg$parseexpr() {\n      var s0, s1, s2, s3, s4;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseprefix();\n      s2 = peg$parsename();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemix_expr();\n        s4 = peg$parsepostfix();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f21(s1, s2, s3, s4);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e15);\n        }\n      }\n      return s0;\n    }\n    function peg$parsecomplete_mix() {\n      var s0, s1, s2, s3, s4;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e16);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsepct();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 33) {\n            s3 = peg$c5;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e16);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsename();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f22(s2, s4);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsepartial_mix() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e16);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsepct();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f23(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsemix_expr() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsecomplete_mix();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsecomplete_mix();\n      }\n      s2 = peg$parsepartial_mix();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f24(s1, s2);\n      peg$silentFails--;\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$e17);\n      }\n      return s0;\n    }\n    function peg$parsename() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s0 = peg$c6;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e19);\n        }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        if (peg$r0.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e20);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            if (peg$r0.test(input.charAt(peg$currPos))) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e20);\n              }\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e18);\n        }\n      }\n      return s0;\n    }\n    function peg$parsepostfix() {\n      var s0, s1, s2, s3, s4;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 3) === peg$c7) {\n        s1 = peg$c7;\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e22);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsenum();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s3 = peg$c8;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e23);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f25(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c9) {\n          s1 = peg$c9;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e24);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$currPos;\n          s3 = [];\n          s4 = peg$parseplus();\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parseplus();\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = input.substring(s2, peg$currPos);\n          } else {\n            s2 = s3;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f26(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e21);\n        }\n      }\n      return s0;\n    }\n    function peg$parseprefix() {\n      var s0, s1;\n      peg$silentFails++;\n      s0 = peg$parseminus();\n      if (s0 === peg$FAILED) {\n        s0 = null;\n      }\n      peg$silentFails--;\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$e25);\n      }\n      return s0;\n    }\n    function peg$parseplus() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s2 = peg$c10;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e27);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (input.charCodeAt(peg$currPos) === 43) {\n            s2 = peg$c10;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e27);\n            }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e26);\n        }\n      }\n      return s0;\n    }\n    function peg$parseminus() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s2 = peg$c11;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e29);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (input.charCodeAt(peg$currPos) === 45) {\n            s2 = peg$c11;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e29);\n            }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e28);\n        }\n      }\n      return s0;\n    }\n    function peg$parsenum() {\n      var s0, s1, s2, s3;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$r1.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e31);\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$r1.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e31);\n            }\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f27(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e30);\n        }\n      }\n      return s0;\n    }\n    function peg$parsepct() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = [];\n      if (peg$r1.test(input.charAt(peg$currPos))) {\n        s5 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e31);\n        }\n      }\n      if (s5 !== peg$FAILED) {\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          if (peg$r1.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e31);\n            }\n          }\n        }\n      } else {\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s3 = input.substring(s3, peg$currPos);\n      } else {\n        s3 = s4;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$currPos;\n        s5 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s6 = peg$c6;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e19);\n          }\n        }\n        if (s6 !== peg$FAILED) {\n          s7 = peg$currPos;\n          s8 = [];\n          if (peg$r1.test(input.charAt(peg$currPos))) {\n            s9 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s9 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e31);\n            }\n          }\n          while (s9 !== peg$FAILED) {\n            s8.push(s9);\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s9 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s9 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e31);\n              }\n            }\n          }\n          s7 = input.substring(s7, peg$currPos);\n          s6 = [s6, s7];\n          s5 = s6;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        if (s5 === peg$FAILED) {\n          s5 = null;\n        }\n        s4 = input.substring(s4, peg$currPos);\n        s3 = [s3, s4];\n        s2 = s3;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c6;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e19);\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = [];\n          if (peg$r1.test(input.charAt(peg$currPos))) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e31);\n            }\n          }\n          if (s6 !== peg$FAILED) {\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              if (peg$r1.test(input.charAt(peg$currPos))) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e31);\n                }\n              }\n            }\n          } else {\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = input.substring(s4, peg$currPos);\n          } else {\n            s4 = s5;\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = input.substring(s1, peg$currPos);\n        } else {\n          s1 = s2;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f28(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e32);\n        }\n      }\n      return s0;\n    }\n    function peg$parsediv() {\n      var s0, s1;\n      peg$silentFails++;\n      s0 = peg$parsepct();\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e33);\n        }\n      }\n      return s0;\n    }\n    function peg$parsedec() {\n      var s0, s1, s2;\n      s0 = peg$parsepct();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s1 = peg$c10;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e27);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsepct();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f29(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 45) {\n            s1 = peg$c11;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e29);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsepct();\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f30(s2);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n      return s0;\n    }\n    function peg$parseint() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseminus();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      s2 = peg$parsenum();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f31(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e34);\n        }\n      }\n      return s0;\n    }\n    function peg$parse_() {\n      var s0, s1;\n      peg$silentFails++;\n      s0 = [];\n      if (peg$r2.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e36);\n        }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$r2.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e36);\n          }\n        }\n      }\n      peg$silentFails--;\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$e35);\n      }\n      return s0;\n    }\n    function peg$parsesp() {\n      var s0, s1;\n      s0 = [];\n      if (peg$r2.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e36);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$r2.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e36);\n            }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsehex() {\n      var s0, s1;\n      s0 = peg$currPos;\n      if (peg$r3.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e37);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f32(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parseEOL() {\n      var s0, s1;\n      s0 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      peg$silentFails--;\n      if (s1 === peg$FAILED) {\n        s0 = void 0;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n}();\n\n// grammars/tabular-spec.pegjs\nvar tabular_spec_default = function() {\n  \"use strict\";\n  function peg$subclass(child, parent) {\n    function C() {\n      this.constructor = child;\n    }\n    C.prototype = parent.prototype;\n    child.prototype = new C();\n  }\n  function peg$SyntaxError(message, expected, found, location) {\n    var self = Error.call(this, message);\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n    }\n    self.expected = expected;\n    self.found = found;\n    self.location = location;\n    self.name = \"SyntaxError\";\n    return self;\n  }\n  peg$subclass(peg$SyntaxError, Error);\n  function peg$padEnd(str, targetLength, padString) {\n    padString = padString || \" \";\n    if (str.length > targetLength) {\n      return str;\n    }\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n  }\n  peg$SyntaxError.prototype.format = function(sources) {\n    var str = \"Error: \" + this.message;\n    if (this.location) {\n      var src = null;\n      var k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].source === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      var s = this.location.start;\n      var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n      if (src) {\n        var e = this.location.end;\n        var filler = peg$padEnd(\"\", s.line.toString().length);\n        var line = src[s.line - 1];\n        var last = s.line === e.line ? e.column : line.length + 1;\n        str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1) + peg$padEnd(\"\", last - s.column, \"^\");\n      } else {\n        str += \"\\n at \" + loc;\n      }\n    }\n    return str;\n  };\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n      literal: function(expectation) {\n        return '\"' + literalEscape(expectation.text) + '\"';\n      },\n      class: function(expectation) {\n        var escapedParts = expectation.parts.map(function(part) {\n          return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n        });\n        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n      },\n      any: function() {\n        return \"any character\";\n      },\n      end: function() {\n        return \"end of input\";\n      },\n      other: function(expectation) {\n        return expectation.description;\n      }\n    };\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    function literalEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function classEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n    function describeExpected(expected2) {\n      var descriptions = expected2.map(describeExpectation);\n      var i, j;\n      descriptions.sort();\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n        default:\n          return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n      }\n    }\n    function describeFound(found2) {\n      return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n    }\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n    var peg$FAILED = {};\n    var peg$source = options.grammarSource;\n    var peg$startRuleFunctions = { body: peg$parsebody };\n    var peg$startRuleFunction = peg$parsebody;\n    var peg$e0 = peg$otherExpectation(\"decl_start\");\n    var peg$e1 = peg$otherExpectation(\"decl_end\");\n    var peg$e2 = peg$otherExpectation(\"vert\");\n    var peg$e3 = peg$anyExpectation();\n    var peg$e4 = peg$otherExpectation(\"l\");\n    var peg$e5 = peg$otherExpectation(\"r\");\n    var peg$e6 = peg$otherExpectation(\"c\");\n    var peg$e7 = peg$otherExpectation(\"p\");\n    var peg$e8 = peg$otherExpectation(\"m\");\n    var peg$e9 = peg$otherExpectation(\"b\");\n    var peg$e10 = peg$otherExpectation(\"w\");\n    var peg$e11 = peg$otherExpectation(\"W\");\n    var peg$e12 = peg$otherExpectation(\"X\");\n    var peg$e13 = peg$otherExpectation(\"!\");\n    var peg$e14 = peg$otherExpectation(\"@\");\n    var peg$e15 = peg$otherExpectation(\"<\");\n    var peg$e16 = peg$otherExpectation(\">\");\n    var peg$e17 = peg$otherExpectation(\"group\");\n    var peg$e18 = peg$otherExpectation(\"whitespace\");\n    var peg$f0 = function(c) {\n      return c;\n    };\n    var peg$f1 = function(cols) {\n      return cols;\n    };\n    var peg$f2 = function() {\n      return [];\n    };\n    var peg$f3 = function(divs1, start, a, end, divs2) {\n      return {\n        type: \"column\",\n        pre_dividers: divs1,\n        post_dividers: divs2,\n        before_start_code: start,\n        before_end_code: end,\n        alignment: a\n      };\n    };\n    var peg$f4 = function() {\n      return {\n        type: \"vert_divider\"\n      };\n    };\n    var peg$f5 = function(b, g) {\n      return {\n        type: \"bang_divider\",\n        content: g[0].content\n      };\n    };\n    var peg$f6 = function(g) {\n      return {\n        type: \"at_divider\",\n        content: g[0].content\n      };\n    };\n    var peg$f7 = function(div) {\n      return div;\n    };\n    var peg$f8 = function(g) {\n      return { type: \"decl_code\", code: g[0].content };\n    };\n    var peg$f9 = function() {\n      return { type: \"alignment\", alignment: \"left\" };\n    };\n    var peg$f10 = function() {\n      return { type: \"alignment\", alignment: \"center\" };\n    };\n    var peg$f11 = function() {\n      return { type: \"alignment\", alignment: \"right\" };\n    };\n    var peg$f12 = function() {\n      return { type: \"alignment\", alignment: \"X\" };\n    };\n    var peg$f13 = function() {\n      return \"top\";\n    };\n    var peg$f14 = function() {\n      return \"default\";\n    };\n    var peg$f15 = function() {\n      return \"bottom\";\n    };\n    var peg$f16 = function(a, g) {\n      return {\n        type: \"alignment\",\n        alignment: \"parbox\",\n        baseline: a,\n        size: g[0].content\n      };\n    };\n    var peg$f17 = function(g1, g2) {\n      return {\n        type: \"alignment\",\n        alignment: \"parbox\",\n        baseline: g1[0].content,\n        size: g2[0].content\n      };\n    };\n    var peg$f18 = function(tok) {\n      return options.matchChar(tok, \"|\");\n    };\n    var peg$f19 = function(tok) {\n      return options.matchChar(tok, \"l\");\n    };\n    var peg$f20 = function(tok) {\n      return options.matchChar(tok, \"r\");\n    };\n    var peg$f21 = function(tok) {\n      return options.matchChar(tok, \"c\");\n    };\n    var peg$f22 = function(tok) {\n      return options.matchChar(tok, \"p\");\n    };\n    var peg$f23 = function(tok) {\n      return options.matchChar(tok, \"m\");\n    };\n    var peg$f24 = function(tok) {\n      return options.matchChar(tok, \"b\");\n    };\n    var peg$f25 = function(tok) {\n      return options.matchChar(tok, \"w\");\n    };\n    var peg$f26 = function(tok) {\n      return options.matchChar(tok, \"W\");\n    };\n    var peg$f27 = function(tok) {\n      return options.matchChar(tok, \"X\");\n    };\n    var peg$f28 = function(tok) {\n      return options.matchChar(tok, \"!\");\n    };\n    var peg$f29 = function(tok) {\n      return options.matchChar(tok, \"@\");\n    };\n    var peg$f30 = function(tok) {\n      return options.matchChar(tok, \"<\");\n    };\n    var peg$f31 = function(tok) {\n      return options.matchChar(tok, \">\");\n    };\n    var peg$f32 = function(tok) {\n      return options.isGroup(tok);\n    };\n    var peg$f33 = function(tok) {\n      return options.isWhitespace(tok);\n    };\n    var peg$currPos = 0;\n    var peg$savedPos = 0;\n    var peg$posDetailsCache = [{ line: 1, column: 1 }];\n    var peg$maxFailPos = 0;\n    var peg$maxFailExpected = [];\n    var peg$silentFails = 0;\n    var peg$result;\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n      }\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n    function offset() {\n      return peg$savedPos;\n    }\n    function range() {\n      return {\n        source: peg$source,\n        start: peg$savedPos,\n        end: peg$currPos\n      };\n    }\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);\n    }\n    function error(message, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildSimpleError(message, location2);\n    }\n    function peg$literalExpectation(text2, ignoreCase) {\n      return { type: \"literal\", text: text2, ignoreCase };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts, inverted, ignoreCase };\n    }\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description };\n    }\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos];\n      var p;\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column\n        };\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n          p++;\n        }\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos);\n      var endPosDetails = peg$computePosDetails(endPos);\n      return {\n        source: peg$source,\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n    function peg$fail(expected2) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n      peg$maxFailExpected.push(expected2);\n    }\n    function peg$buildSimpleError(message, location2) {\n      return new peg$SyntaxError(message, null, null, location2);\n    }\n    function peg$buildStructuredError(expected2, found, location2) {\n      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);\n    }\n    function peg$parsebody() {\n      var s0, s1, s2, s3, s4, s5;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$parsecolumn();\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parse_();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parse_();\n        }\n        peg$savedPos = s2;\n        s2 = peg$f0(s3);\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$parsecolumn();\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parse_();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parse_();\n            }\n            peg$savedPos = s2;\n            s2 = peg$f0(s3);\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f1(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseEOL();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f2();\n        }\n        s0 = s1;\n      }\n      return s0;\n    }\n    function peg$parsecolumn() {\n      var s0, s1, s2, s3, s4, s5, s6;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsecolumn_divider();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsecolumn_divider();\n      }\n      s2 = peg$parsedecl_start();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parsealignment();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsedecl_end();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        s5 = [];\n        s6 = peg$parsecolumn_divider();\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          s6 = peg$parsecolumn_divider();\n        }\n        peg$savedPos = s0;\n        s0 = peg$f3(s1, s2, s3, s4, s5);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsecolumn_divider() {\n      var s0, s1, s2, s3, s4;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parse_();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parse_();\n      }\n      s2 = peg$currPos;\n      s3 = peg$parsevert();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s2;\n        s3 = peg$f4();\n      }\n      s2 = s3;\n      if (s2 === peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parsebang();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsegroup();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s2;\n            s2 = peg$f5(s3, s4);\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = peg$currPos;\n          s3 = peg$parseat();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsegroup();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s2;\n              s2 = peg$f6(s4);\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parse_();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parse_();\n        }\n        peg$savedPos = s0;\n        s0 = peg$f7(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsedecl_start() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsegreater();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsegroup();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f8(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      return s0;\n    }\n    function peg$parsedecl_end() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseless();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsegroup();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f8(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e1);\n        }\n      }\n      return s0;\n    }\n    function peg$parsealignment() {\n      var s0, s1, s2, s3, s4, s5;\n      s0 = peg$currPos;\n      s1 = peg$parsel();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f9();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsec();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f10();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parser();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f11();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseX();\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$f12();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$currPos;\n              s2 = peg$parsep();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s1;\n                s2 = peg$f13();\n              }\n              s1 = s2;\n              if (s1 === peg$FAILED) {\n                s1 = peg$currPos;\n                s2 = peg$parsem();\n                if (s2 !== peg$FAILED) {\n                  peg$savedPos = s1;\n                  s2 = peg$f14();\n                }\n                s1 = s2;\n                if (s1 === peg$FAILED) {\n                  s1 = peg$currPos;\n                  s2 = peg$parseb();\n                  if (s2 !== peg$FAILED) {\n                    peg$savedPos = s1;\n                    s2 = peg$f15();\n                  }\n                  s1 = s2;\n                }\n              }\n              if (s1 !== peg$FAILED) {\n                s2 = [];\n                s3 = peg$parse_();\n                while (s3 !== peg$FAILED) {\n                  s2.push(s3);\n                  s3 = peg$parse_();\n                }\n                s3 = peg$parsegroup();\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s0 = peg$f16(s1, s3);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parsew();\n                if (s1 === peg$FAILED) {\n                  s1 = peg$parseW();\n                }\n                if (s1 !== peg$FAILED) {\n                  s2 = [];\n                  s3 = peg$parse_();\n                  while (s3 !== peg$FAILED) {\n                    s2.push(s3);\n                    s3 = peg$parse_();\n                  }\n                  s3 = peg$parsegroup();\n                  if (s3 !== peg$FAILED) {\n                    s4 = [];\n                    s5 = peg$parse_();\n                    while (s5 !== peg$FAILED) {\n                      s4.push(s5);\n                      s5 = peg$parse_();\n                    }\n                    s5 = peg$parsegroup();\n                    if (s5 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s0 = peg$f17(s3, s5);\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              }\n            }\n          }\n        }\n      }\n      return s0;\n    }\n    function peg$parsevert() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f18(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      return s0;\n    }\n    function peg$parsel() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f19(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e4);\n        }\n      }\n      return s0;\n    }\n    function peg$parser() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f20(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e5);\n        }\n      }\n      return s0;\n    }\n    function peg$parsec() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f21(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e6);\n        }\n      }\n      return s0;\n    }\n    function peg$parsep() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f22(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e7);\n        }\n      }\n      return s0;\n    }\n    function peg$parsem() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f23(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e8);\n        }\n      }\n      return s0;\n    }\n    function peg$parseb() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f24(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e9);\n        }\n      }\n      return s0;\n    }\n    function peg$parsew() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f25(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e10);\n        }\n      }\n      return s0;\n    }\n    function peg$parseW() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f26(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e11);\n        }\n      }\n      return s0;\n    }\n    function peg$parseX() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f27(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e12);\n        }\n      }\n      return s0;\n    }\n    function peg$parsebang() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f28(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e13);\n        }\n      }\n      return s0;\n    }\n    function peg$parseat() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f29(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e14);\n        }\n      }\n      return s0;\n    }\n    function peg$parseless() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f30(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e15);\n        }\n      }\n      return s0;\n    }\n    function peg$parsegreater() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f31(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e16);\n        }\n      }\n      return s0;\n    }\n    function peg$parsegroup() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f32(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e17);\n        }\n      }\n      return s0;\n    }\n    function peg$parse_() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f33(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e18);\n        }\n      }\n      return s0;\n    }\n    function peg$parseEOL() {\n      var s0, s1;\n      s0 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      peg$silentFails--;\n      if (s1 === peg$FAILED) {\n        s0 = void 0;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    if (!options.isHash) {\n      try {\n        Object.assign(options, {\n          matchChar: (node, char) => node.type === \"string\" && node.content === char,\n          isGroup: (node) => node.type === \"group\",\n          isWhitespace: (node) => node.type === \"whitespace\"\n        });\n      } catch (e) {\n        console.warn(\"Error when initializing parser\", e);\n      }\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n}();\n\n// grammars/systeme-environment.pegjs\nvar systeme_environment_default = function() {\n  \"use strict\";\n  function peg$subclass(child, parent) {\n    function C() {\n      this.constructor = child;\n    }\n    C.prototype = parent.prototype;\n    child.prototype = new C();\n  }\n  function peg$SyntaxError(message, expected, found, location) {\n    var self = Error.call(this, message);\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n    }\n    self.expected = expected;\n    self.found = found;\n    self.location = location;\n    self.name = \"SyntaxError\";\n    return self;\n  }\n  peg$subclass(peg$SyntaxError, Error);\n  function peg$padEnd(str, targetLength, padString) {\n    padString = padString || \" \";\n    if (str.length > targetLength) {\n      return str;\n    }\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n  }\n  peg$SyntaxError.prototype.format = function(sources) {\n    var str = \"Error: \" + this.message;\n    if (this.location) {\n      var src = null;\n      var k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].source === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      var s = this.location.start;\n      var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n      if (src) {\n        var e = this.location.end;\n        var filler = peg$padEnd(\"\", s.line.toString().length);\n        var line = src[s.line - 1];\n        var last = s.line === e.line ? e.column : line.length + 1;\n        str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1) + peg$padEnd(\"\", last - s.column, \"^\");\n      } else {\n        str += \"\\n at \" + loc;\n      }\n    }\n    return str;\n  };\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n      literal: function(expectation) {\n        return '\"' + literalEscape(expectation.text) + '\"';\n      },\n      class: function(expectation) {\n        var escapedParts = expectation.parts.map(function(part) {\n          return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n        });\n        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n      },\n      any: function() {\n        return \"any character\";\n      },\n      end: function() {\n        return \"end of input\";\n      },\n      other: function(expectation) {\n        return expectation.description;\n      }\n    };\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    function literalEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function classEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n    function describeExpected(expected2) {\n      var descriptions = expected2.map(describeExpectation);\n      var i, j;\n      descriptions.sort();\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n        default:\n          return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n      }\n    }\n    function describeFound(found2) {\n      return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n    }\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n    var peg$FAILED = {};\n    var peg$source = options.grammarSource;\n    var peg$startRuleFunctions = { body: peg$parsebody };\n    var peg$startRuleFunction = peg$parsebody;\n    var peg$e0 = peg$otherExpectation(\"partial item\");\n    var peg$e1 = peg$otherExpectation(\"item\");\n    var peg$e2 = peg$anyExpectation();\n    var peg$e3 = peg$otherExpectation(\"equation\");\n    var peg$e4 = peg$otherExpectation(\"trailing comment\");\n    var peg$e5 = peg$otherExpectation(\"comment only line\");\n    var peg$e6 = peg$otherExpectation(\"non-var token\");\n    var peg$e7 = peg$otherExpectation(\"token\");\n    var peg$e8 = peg$otherExpectation(\"same line comment\");\n    var peg$e9 = peg$otherExpectation(\"own line comment\");\n    var peg$e10 = peg$otherExpectation(\",\");\n    var peg$e11 = peg$otherExpectation(\"@\");\n    var peg$e12 = peg$otherExpectation(\"variable token\");\n    var peg$e13 = peg$otherExpectation(\"+/-\");\n    var peg$e14 = peg$otherExpectation(\"=\");\n    var peg$f0 = function(a, b) {\n      return a.concat(b ? b : []);\n    };\n    var peg$f1 = function() {\n      return [];\n    };\n    var peg$f2 = function(a, b, c) {\n      return a.concat(b, c);\n    };\n    var peg$f3 = function(op, a, b, c) {\n      return { type: \"item\", op, variable: b, content: a.concat(b, c) };\n    };\n    var peg$f4 = function(op, a) {\n      return { type: \"item\", op, variable: null, content: a };\n    };\n    var peg$f5 = function(line, sep, comment) {\n      return __spreadProps(__spreadValues({}, line), { sep: [].concat(sep), trailingComment: comment });\n    };\n    var peg$f6 = function(line, comment) {\n      return __spreadProps(__spreadValues({}, line), { trailingComment: comment });\n    };\n    var peg$f7 = function(eq, ann) {\n      return {\n        type: \"line\",\n        equation: eq,\n        annotation: ann,\n        sep: null\n      };\n    };\n    var peg$f8 = function(at, ann) {\n      return at ? { type: \"annotation\", marker: at, content: ann } : null;\n    };\n    var peg$f9 = function(left, eq, right) {\n      return { type: \"equation\", left, right, equals: eq };\n    };\n    var peg$f10 = function(x) {\n      return x;\n    };\n    var peg$f11 = function(x) {\n      return {\n        type: \"line\",\n        trailingComment: x\n      };\n    };\n    var peg$f12 = function(v, s) {\n      return [v].concat(s ? s : []);\n    };\n    var peg$f13 = function(t) {\n      return t;\n    };\n    var peg$f14 = function(tok) {\n      return options.isSameLineComment(tok);\n    };\n    var peg$f15 = function(tok) {\n      return tok;\n    };\n    var peg$f16 = function(tok) {\n      return options.isOwnLineComment(tok);\n    };\n    var peg$f17 = function(tok) {\n      return options.isWhitespace(tok);\n    };\n    var peg$f18 = function(tok) {\n      return options.isSep(tok);\n    };\n    var peg$f19 = function(tok) {\n      return options.isAt(tok);\n    };\n    var peg$f20 = function(tok) {\n      return options.isVar(tok);\n    };\n    var peg$f21 = function(tok) {\n      return options.isOperation(tok);\n    };\n    var peg$f22 = function(tok) {\n      return options.isEquals(tok);\n    };\n    var peg$f23 = function(tok) {\n      return options.isSubscript(tok);\n    };\n    var peg$currPos = 0;\n    var peg$savedPos = 0;\n    var peg$posDetailsCache = [{ line: 1, column: 1 }];\n    var peg$maxFailPos = 0;\n    var peg$maxFailExpected = [];\n    var peg$silentFails = 0;\n    var peg$result;\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n      }\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n    function offset() {\n      return peg$savedPos;\n    }\n    function range() {\n      return {\n        source: peg$source,\n        start: peg$savedPos,\n        end: peg$currPos\n      };\n    }\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);\n    }\n    function error(message, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildSimpleError(message, location2);\n    }\n    function peg$literalExpectation(text2, ignoreCase) {\n      return { type: \"literal\", text: text2, ignoreCase };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts, inverted, ignoreCase };\n    }\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description };\n    }\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos];\n      var p;\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column\n        };\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n          p++;\n        }\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos);\n      var endPosDetails = peg$computePosDetails(endPos);\n      return {\n        source: peg$source,\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n    function peg$fail(expected2) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n      peg$maxFailExpected.push(expected2);\n    }\n    function peg$buildSimpleError(message, location2) {\n      return new peg$SyntaxError(message, null, null, location2);\n    }\n    function peg$buildStructuredError(expected2, found, location2) {\n      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);\n    }\n    function peg$parsebody() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsecomment_only_line();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseline_with_sep();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsepartial_line_with_comment();\n        }\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsecomment_only_line();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseline_with_sep();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsepartial_line_with_comment();\n          }\n        }\n      }\n      s2 = peg$parseline_without_sep();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseEOL();\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f0(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseEOL();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f1();\n        }\n        s0 = s1;\n      }\n      return s0;\n    }\n    function peg$parsepartial_item() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parse_();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parse_();\n      }\n      s2 = [];\n      s3 = peg$parsenon_var_token();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsenon_var_token();\n      }\n      s3 = [];\n      s4 = peg$parse_();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parse_();\n      }\n      s4 = peg$parsevar();\n      if (s4 !== peg$FAILED) {\n        s5 = [];\n        s6 = peg$parse_();\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          s6 = peg$parse_();\n        }\n        s6 = [];\n        s7 = peg$parsetoken();\n        while (s7 !== peg$FAILED) {\n          s6.push(s7);\n          s7 = peg$parsetoken();\n        }\n        s7 = [];\n        s8 = peg$parse_();\n        while (s8 !== peg$FAILED) {\n          s7.push(s8);\n          s8 = peg$parse_();\n        }\n        peg$savedPos = s0;\n        s0 = peg$f2(s2, s4, s6);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      return s0;\n    }\n    function peg$parseitem() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseoperation();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      s2 = [];\n      s3 = peg$parse_();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parse_();\n      }\n      s3 = [];\n      s4 = peg$parsenon_var_token();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsenon_var_token();\n      }\n      s4 = [];\n      s5 = peg$parse_();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parse_();\n      }\n      s5 = peg$parsevar();\n      if (s5 !== peg$FAILED) {\n        s6 = [];\n        s7 = peg$parse_();\n        while (s7 !== peg$FAILED) {\n          s6.push(s7);\n          s7 = peg$parse_();\n        }\n        s7 = [];\n        s8 = peg$parsetoken();\n        while (s8 !== peg$FAILED) {\n          s7.push(s8);\n          s8 = peg$parsetoken();\n        }\n        s8 = [];\n        s9 = peg$parse_();\n        while (s9 !== peg$FAILED) {\n          s8.push(s9);\n          s9 = peg$parse_();\n        }\n        peg$savedPos = s0;\n        s0 = peg$f3(s1, s3, s5, s7);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseoperation();\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        s2 = [];\n        s3 = peg$parse_();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parse_();\n        }\n        s3 = [];\n        s4 = peg$parsenon_var_token();\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsenon_var_token();\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parse_();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parse_();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f4(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e1);\n        }\n      }\n      return s0;\n    }\n    function peg$parseline_with_sep() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$parseline_without_sep();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsesep();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsetrailing_comment();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f5(s1, s2, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsepartial_line_with_comment() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parseline_without_sep();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsetrailing_comment();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f6(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseline_without_sep() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      peg$silentFails--;\n      if (s2 !== peg$FAILED) {\n        peg$currPos = s1;\n        s1 = void 0;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseequation();\n        s3 = peg$parseannotation();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f7(s2, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseannotation() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$parseat();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsenon_sep_token();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsenon_sep_token();\n        }\n        peg$savedPos = s0;\n        s0 = peg$f8(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseequation() {\n      var s0, s1, s2, s3, s4;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseitem();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseitem();\n      }\n      s2 = peg$parseequals();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = [];\n      s4 = peg$parsetoken();\n      if (s4 === peg$FAILED) {\n        s4 = peg$parseoperation();\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsetoken();\n        if (s4 === peg$FAILED) {\n          s4 = peg$parseoperation();\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f9(s1, s2, s3);\n      peg$silentFails--;\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$e3);\n      }\n      return s0;\n    }\n    function peg$parsetrailing_comment() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parse_();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parse_();\n      }\n      s2 = peg$parsesame_line_comment();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f10(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e4);\n        }\n      }\n      return s0;\n    }\n    function peg$parsecomment_only_line() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parse_();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parse_();\n      }\n      s2 = peg$parseown_line_comment();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f11(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e5);\n        }\n      }\n      return s0;\n    }\n    function peg$parsevar() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$parsevar_token();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parse_();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parse_();\n        }\n        s3 = peg$parsesubscript();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f12(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsenon_var_token() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      s2 = peg$parsevar();\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = void 0;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsetoken();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f13(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e6);\n        }\n      }\n      return s0;\n    }\n    function peg$parsenon_sep_token() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      s2 = peg$parsesep();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsetrailing_comment();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseown_line_comment();\n        }\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = void 0;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f10(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsetoken() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      s2 = peg$parsesep();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseat();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseoperation();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseequals();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parsetrailing_comment();\n              if (s2 === peg$FAILED) {\n                s2 = peg$parseown_line_comment();\n              }\n            }\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = void 0;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f10(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e7);\n        }\n      }\n      return s0;\n    }\n    function peg$parsesame_line_comment() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f14(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f15(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e8);\n        }\n      }\n      return s0;\n    }\n    function peg$parseown_line_comment() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f16(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f15(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e9);\n        }\n      }\n      return s0;\n    }\n    function peg$parse_() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f17(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f15(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsesep() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f18(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f15(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e10);\n        }\n      }\n      return s0;\n    }\n    function peg$parseat() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f19(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f15(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e11);\n        }\n      }\n      return s0;\n    }\n    function peg$parsevar_token() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f20(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f15(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e12);\n        }\n      }\n      return s0;\n    }\n    function peg$parseoperation() {\n      var s0, s1, s2, s3, s4;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parse_();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parse_();\n      }\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parse_();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parse_();\n        }\n        peg$savedPos = peg$currPos;\n        s4 = peg$f21(s2);\n        if (s4) {\n          s4 = void 0;\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f15(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e13);\n        }\n      }\n      return s0;\n    }\n    function peg$parseequals() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f22(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f15(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e14);\n        }\n      }\n      return s0;\n    }\n    function peg$parsesubscript() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f23(s1);\n        if (s2) {\n          s2 = void 0;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f15(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseEOL() {\n      var s0, s1;\n      s0 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      peg$silentFails--;\n      if (s1 === peg$FAILED) {\n        s0 = void 0;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    if (!options.isWhitespace) {\n      try {\n        Object.assign(options, {\n          isSep: (node) => node.type === \"string\" && node.content === \",\",\n          isVar: (node) => node.type === \"string\" && node.content.match(/[a-zA-Z]/),\n          isOperation: (node) => node.type === \"string\" && node.content.match(/[+-]/),\n          isEquals: (node) => node.type === \"string\" && node.content === \"=\",\n          isAt: (node) => node.type === \"string\" && node.content === \"@\",\n          isSubscript: (node) => node.content === \"_\",\n          isWhitespace: (node) => node.type === \"whitespace\",\n          isSameLineComment: (node) => node.type === \"comment\" && node.sameline,\n          isOwnLineComment: (node) => node.type === \"comment\" && !node.sameline\n        });\n      } catch (e) {\n        console.warn(\"Error when initializing parser\", e);\n      }\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n}();\n\n// grammars/tex-glue.pegjs\nvar tex_glue_default = function() {\n  \"use strict\";\n  function peg$subclass(child, parent) {\n    function C() {\n      this.constructor = child;\n    }\n    C.prototype = parent.prototype;\n    child.prototype = new C();\n  }\n  function peg$SyntaxError(message, expected, found, location) {\n    var self = Error.call(this, message);\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n    }\n    self.expected = expected;\n    self.found = found;\n    self.location = location;\n    self.name = \"SyntaxError\";\n    return self;\n  }\n  peg$subclass(peg$SyntaxError, Error);\n  function peg$padEnd(str, targetLength, padString) {\n    padString = padString || \" \";\n    if (str.length > targetLength) {\n      return str;\n    }\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n  }\n  peg$SyntaxError.prototype.format = function(sources) {\n    var str = \"Error: \" + this.message;\n    if (this.location) {\n      var src = null;\n      var k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].source === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      var s = this.location.start;\n      var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n      if (src) {\n        var e = this.location.end;\n        var filler = peg$padEnd(\"\", s.line.toString().length);\n        var line = src[s.line - 1];\n        var last = s.line === e.line ? e.column : line.length + 1;\n        str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1) + peg$padEnd(\"\", last - s.column, \"^\");\n      } else {\n        str += \"\\n at \" + loc;\n      }\n    }\n    return str;\n  };\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n      literal: function(expectation) {\n        return '\"' + literalEscape(expectation.text) + '\"';\n      },\n      class: function(expectation) {\n        var escapedParts = expectation.parts.map(function(part) {\n          return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n        });\n        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n      },\n      any: function() {\n        return \"any character\";\n      },\n      end: function() {\n        return \"end of input\";\n      },\n      other: function(expectation) {\n        return expectation.description;\n      }\n    };\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    function literalEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function classEscape(s) {\n      return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n        return \"\\\\x0\" + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n    }\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n    function describeExpected(expected2) {\n      var descriptions = expected2.map(describeExpectation);\n      var i, j;\n      descriptions.sort();\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n        default:\n          return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n      }\n    }\n    function describeFound(found2) {\n      return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n    }\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n    var peg$FAILED = {};\n    var peg$source = options.grammarSource;\n    var peg$startRuleFunctions = { root: peg$parseroot };\n    var peg$startRuleFunction = peg$parseroot;\n    var peg$c0 = \"plus\";\n    var peg$c1 = \"minus\";\n    var peg$c2 = \"pt\";\n    var peg$c3 = \"mm\";\n    var peg$c4 = \"cm\";\n    var peg$c5 = \"in\";\n    var peg$c6 = \"ex\";\n    var peg$c7 = \"em\";\n    var peg$c8 = \"bp\";\n    var peg$c9 = \"pc\";\n    var peg$c10 = \"dd\";\n    var peg$c11 = \"cc\";\n    var peg$c12 = \"nd\";\n    var peg$c13 = \"nc\";\n    var peg$c14 = \"sp\";\n    var peg$c15 = \"filll\";\n    var peg$c16 = \"fill\";\n    var peg$c17 = \"fil\";\n    var peg$c18 = \".\";\n    var peg$c19 = \"+\";\n    var peg$c20 = \"-\";\n    var peg$r0 = /^[0-9]/;\n    var peg$e0 = peg$anyExpectation();\n    var peg$e1 = peg$literalExpectation(\"plus\", false);\n    var peg$e2 = peg$literalExpectation(\"minus\", false);\n    var peg$e3 = peg$literalExpectation(\"pt\", false);\n    var peg$e4 = peg$literalExpectation(\"mm\", false);\n    var peg$e5 = peg$literalExpectation(\"cm\", false);\n    var peg$e6 = peg$literalExpectation(\"in\", false);\n    var peg$e7 = peg$literalExpectation(\"ex\", false);\n    var peg$e8 = peg$literalExpectation(\"em\", false);\n    var peg$e9 = peg$literalExpectation(\"bp\", false);\n    var peg$e10 = peg$literalExpectation(\"pc\", false);\n    var peg$e11 = peg$literalExpectation(\"dd\", false);\n    var peg$e12 = peg$literalExpectation(\"cc\", false);\n    var peg$e13 = peg$literalExpectation(\"nd\", false);\n    var peg$e14 = peg$literalExpectation(\"nc\", false);\n    var peg$e15 = peg$literalExpectation(\"sp\", false);\n    var peg$e16 = peg$literalExpectation(\"filll\", false);\n    var peg$e17 = peg$literalExpectation(\"fill\", false);\n    var peg$e18 = peg$literalExpectation(\"fil\", false);\n    var peg$e19 = peg$otherExpectation(\"number\");\n    var peg$e20 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n    var peg$e21 = peg$literalExpectation(\".\", false);\n    var peg$e22 = peg$literalExpectation(\"+\", false);\n    var peg$e23 = peg$literalExpectation(\"-\", false);\n    var peg$f0 = function(b, st, sh) {\n      return {\n        type: \"glue\",\n        fixed: b,\n        stretchable: st,\n        shrinkable: sh,\n        position: location()\n      };\n    };\n    var peg$f1 = function(glue) {\n      return glue;\n    };\n    var peg$f2 = function(n, u) {\n      return { type: \"dim\", value: n, unit: u };\n    };\n    var peg$f3 = function(n, u) {\n      return { type: \"dim\", value: n, unit: u };\n    };\n    var peg$f4 = function(n) {\n      return parseFloat(n);\n    };\n    var peg$currPos = 0;\n    var peg$savedPos = 0;\n    var peg$posDetailsCache = [{ line: 1, column: 1 }];\n    var peg$maxFailPos = 0;\n    var peg$maxFailExpected = [];\n    var peg$silentFails = 0;\n    var peg$result;\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n      }\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n    function offset() {\n      return peg$savedPos;\n    }\n    function range() {\n      return {\n        source: peg$source,\n        start: peg$savedPos,\n        end: peg$currPos\n      };\n    }\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);\n    }\n    function error(message, location2) {\n      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildSimpleError(message, location2);\n    }\n    function peg$literalExpectation(text2, ignoreCase) {\n      return { type: \"literal\", text: text2, ignoreCase };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts, inverted, ignoreCase };\n    }\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description };\n    }\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos];\n      var p;\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column\n        };\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n          p++;\n        }\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos);\n      var endPosDetails = peg$computePosDetails(endPos);\n      return {\n        source: peg$source,\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n    function peg$fail(expected2) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n      peg$maxFailExpected.push(expected2);\n    }\n    function peg$buildSimpleError(message, location2) {\n      return new peg$SyntaxError(message, null, null, location2);\n    }\n    function peg$buildStructuredError(expected2, found, location2) {\n      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);\n    }\n    function peg$parseroot() {\n      var s0, s1, s2, s3, s4;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsebase();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsestretchable();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        s4 = peg$parseshrinkable();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        peg$savedPos = s1;\n        s1 = peg$f0(s2, s3, s4);\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (input.length > peg$currPos) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e0);\n            }\n          }\n        }\n        peg$savedPos = s0;\n        s0 = peg$f1(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsebase() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parsenumber();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseunit();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f2(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsestretchable() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c0) {\n        s1 = peg$c0;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e1);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsenumber();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parserubber_unit();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f3(s2, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseshrinkable() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c1) {\n        s1 = peg$c1;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e2);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsenumber();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parserubber_unit();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f3(s2, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseunit() {\n      var s0;\n      if (input.substr(peg$currPos, 2) === peg$c2) {\n        s0 = peg$c2;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c3) {\n          s0 = peg$c3;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e4);\n          }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c4) {\n            s0 = peg$c4;\n            peg$currPos += 2;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e5);\n            }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c5) {\n              s0 = peg$c5;\n              peg$currPos += 2;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e6);\n              }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c6) {\n                s0 = peg$c6;\n                peg$currPos += 2;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e7);\n                }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 2) === peg$c7) {\n                  s0 = peg$c7;\n                  peg$currPos += 2;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e8);\n                  }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 2) === peg$c8) {\n                    s0 = peg$c8;\n                    peg$currPos += 2;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$e9);\n                    }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 2) === peg$c9) {\n                      s0 = peg$c9;\n                      peg$currPos += 2;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$e10);\n                      }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 2) === peg$c10) {\n                        s0 = peg$c10;\n                        peg$currPos += 2;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                          peg$fail(peg$e11);\n                        }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 2) === peg$c11) {\n                          s0 = peg$c11;\n                          peg$currPos += 2;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) {\n                            peg$fail(peg$e12);\n                          }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 2) === peg$c12) {\n                            s0 = peg$c12;\n                            peg$currPos += 2;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                              peg$fail(peg$e13);\n                            }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 2) === peg$c13) {\n                              s0 = peg$c13;\n                              peg$currPos += 2;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) {\n                                peg$fail(peg$e14);\n                              }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 2) === peg$c14) {\n                                s0 = peg$c14;\n                                peg$currPos += 2;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) {\n                                  peg$fail(peg$e15);\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return s0;\n    }\n    function peg$parserubber_unit() {\n      var s0;\n      s0 = peg$parseunit();\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c15) {\n          s0 = peg$c15;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e16);\n          }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 4) === peg$c16) {\n            s0 = peg$c16;\n            peg$currPos += 4;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e17);\n            }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3) === peg$c17) {\n              s0 = peg$c17;\n              peg$currPos += 3;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e18);\n              }\n            }\n          }\n        }\n      }\n      return s0;\n    }\n    function peg$parsenumber() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      s3 = peg$parsesign();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s4 = peg$currPos;\n      s5 = [];\n      if (peg$r0.test(input.charAt(peg$currPos))) {\n        s6 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s6 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e20);\n        }\n      }\n      while (s6 !== peg$FAILED) {\n        s5.push(s6);\n        if (peg$r0.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e20);\n          }\n        }\n      }\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s6 = peg$c18;\n        peg$currPos++;\n      } else {\n        s6 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e21);\n        }\n      }\n      if (s6 !== peg$FAILED) {\n        s7 = [];\n        if (peg$r0.test(input.charAt(peg$currPos))) {\n          s8 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s8 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e20);\n          }\n        }\n        if (s8 !== peg$FAILED) {\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            if (peg$r0.test(input.charAt(peg$currPos))) {\n              s8 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s8 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e20);\n              }\n            }\n          }\n        } else {\n          s7 = peg$FAILED;\n        }\n        if (s7 !== peg$FAILED) {\n          s5 = [s5, s6, s7];\n          s4 = s5;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 === peg$FAILED) {\n        s4 = [];\n        if (peg$r0.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e20);\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$r0.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e20);\n              }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n      }\n      if (s4 !== peg$FAILED) {\n        s3 = [s3, s4];\n        s2 = s3;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f4(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e19);\n        }\n      }\n      return s0;\n    }\n    function peg$parsesign() {\n      var s0;\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s0 = peg$c19;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e22);\n        }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s0 = peg$c20;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e23);\n          }\n        }\n      }\n      return s0;\n    }\n    function peg$parseEOL() {\n      var s0, s1;\n      s0 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n      }\n      peg$silentFails--;\n      if (s1 === peg$FAILED) {\n        s0 = void 0;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n}();\n\n// libs/pegjs-parsers.ts\nvar LatexPegParser = latex_default;\nvar AlignEnvironmentPegParser = align_environment_default;\nvar ArgSpecPegParser = xparse_argspec_default;\nvar PgfkeysPegParser = pgfkeys_default;\nvar MacroSubstitutionPegParser = macro_substitutions_default;\nvar LigaturesPegParser = ligatures_default;\nvar XColorPegParser = xcolor_expressions_default;\nvar TabularPegParser = tabular_spec_default;\nvar SystemePegParser = systeme_environment_default;\nvar GluePegParser = tex_glue_default;\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-util-pegjs/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-util-print-raw/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-util-print-raw/index.js ***!
  \***************************************************************************/
/*! exports provided: linebreak, printRaw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linebreak\", function() { return linebreak; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"printRaw\", function() { return printRaw; });\n// libs/print-raw.ts\nvar linebreak = Symbol(\"linebreak\");\nvar ESCAPE = \"\\\\\";\nfunction _printRaw(node) {\n  if (typeof node === \"string\") {\n    return [node];\n  }\n  if (Array.isArray(node)) {\n    return [].concat(...node.map((n) => _printRaw(n)));\n  }\n  let argsString, escape;\n  switch (node.type) {\n    case \"root\":\n      return _printRaw(node.content);\n    case \"argument\":\n      return [node.openMark, ..._printRaw(node.content), node.closeMark];\n    case \"comment\":\n      var suffix = node.suffixParbreak ? \"\" : linebreak;\n      var leadingWhitespace = \"\";\n      if (node.sameline && node.leadingWhitespace) {\n        leadingWhitespace = \" \";\n      }\n      if (node.sameline) {\n        return [\n          leadingWhitespace,\n          \"%\",\n          ..._printRaw(node.content),\n          suffix\n        ];\n      }\n      return [linebreak, \"%\", ..._printRaw(node.content), suffix];\n    case \"environment\":\n    case \"mathenv\":\n    case \"verbatim\":\n      var env = _printRaw(node.env);\n      var envStart = [ESCAPE + \"begin{\", ...env, \"}\"];\n      var envEnd = [ESCAPE + \"end{\", ...env, \"}\"];\n      argsString = node.args == null ? [] : _printRaw(node.args);\n      return [\n        ...envStart,\n        ...argsString,\n        ..._printRaw(node.content),\n        ...envEnd\n      ];\n    case \"displaymath\":\n      return [ESCAPE + \"[\", ..._printRaw(node.content), ESCAPE + \"]\"];\n    case \"group\":\n      return [\"{\", ..._printRaw(node.content), \"}\"];\n    case \"inlinemath\":\n      return [\"$\", ..._printRaw(node.content), \"$\"];\n    case \"macro\":\n      argsString = node.args == null ? [] : _printRaw(node.args);\n      escape = node.escapeToken == null ? ESCAPE : node.escapeToken;\n      return [escape, ..._printRaw(node.content), ...argsString];\n    case \"parbreak\":\n      return [linebreak, linebreak];\n    case \"string\":\n      return [node.content];\n    case \"verb\":\n      return [\n        ESCAPE,\n        node.env,\n        node.escape,\n        ..._printRaw(node.content),\n        node.escape\n      ];\n    case \"whitespace\":\n      return [\" \"];\n    default:\n      console.warn(\"Cannot find render for node \", node, `(of type ${typeof node})`);\n      return [\"\" + node];\n  }\n}\nfunction printRaw(node, options) {\n  const asArray = options != null ? options.asArray : false;\n  const printedTokens = _printRaw(node);\n  if (asArray) {\n    return printedTokens;\n  }\n  return printedTokens.map((x) => x === linebreak ? \"\\n\" : x).join(\"\");\n}\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-util-print-raw/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-util-render-info/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-util-render-info/index.js ***!
  \*****************************************************************************/
/*! exports provided: trimRenderInfo, updateRenderInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trimRenderInfo\", function() { return trimRenderInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateRenderInfo\", function() { return updateRenderInfo; });\n/* harmony import */ var _unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @unified-latex/unified-latex-util-visit */ \"./node_modules/@unified-latex/unified-latex-util-visit/index.js\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\n\n// index.ts\n\nfunction updateRenderInfo(node, renderInfo) {\n  if (renderInfo != null) {\n    node._renderInfo = __spreadValues(__spreadValues({}, node._renderInfo || {}), renderInfo);\n  }\n  return node;\n}\nfunction trimRenderInfo(ast) {\n  Object(_unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__[\"visit\"])(ast, (node) => {\n    delete node._renderInfo;\n    delete node.position;\n  });\n  return ast;\n}\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-util-render-info/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-util-replace/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-util-replace/index.js ***!
  \*************************************************************************/
/*! exports provided: firstSignificantNode, firstSignificantNodeIndex, lastSignificantNode, lastSignificantNodeIndex, replaceNode, replaceNodeDuringVisit, replaceStreamingCommand, replaceStreamingCommandInGroup, unifiedLatexReplaceStreamingCommands */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"firstSignificantNode\", function() { return firstSignificantNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"firstSignificantNodeIndex\", function() { return firstSignificantNodeIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lastSignificantNode\", function() { return lastSignificantNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lastSignificantNodeIndex\", function() { return lastSignificantNodeIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"replaceNode\", function() { return replaceNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"replaceNodeDuringVisit\", function() { return replaceNodeDuringVisit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"replaceStreamingCommand\", function() { return replaceStreamingCommand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"replaceStreamingCommandInGroup\", function() { return replaceStreamingCommandInGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unifiedLatexReplaceStreamingCommands\", function() { return unifiedLatexReplaceStreamingCommands; });\n/* harmony import */ var _unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @unified-latex/unified-latex-util-visit */ \"./node_modules/@unified-latex/unified-latex-util-visit/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @unified-latex/unified-latex-util-match */ \"./node_modules/@unified-latex/unified-latex-util-match/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @unified-latex/unified-latex-util-trim */ \"./node_modules/@unified-latex/unified-latex-util-trim/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_split__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @unified-latex/unified-latex-util-split */ \"./node_modules/@unified-latex/unified-latex-util-split/index.js\");\n// libs/replace-node.ts\n\nfunction replaceNode(ast, visitor) {\n  Object(_unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__[\"visit\"])(ast, {\n    leave: (node, info) => {\n      let replacement = visitor(node, info.context);\n      if (typeof replacement === \"undefined\" || replacement === node) {\n        return;\n      }\n      if (!info.containingArray || info.index == null) {\n        throw new Error(\"Trying to delete node, but cannot find containing array\");\n      }\n      if (replacement === null || Array.isArray(replacement) && replacement.length === 0) {\n        info.containingArray.splice(info.index, 1);\n        return info.index;\n      }\n      if (!Array.isArray(replacement)) {\n        replacement = [replacement];\n      }\n      info.containingArray.splice(info.index, 1, ...replacement);\n      return info.index + replacement.length;\n    }\n  });\n}\n\n// libs/unified-latex-streaming-command.ts\n\n\n\n\n// libs/replace-streaming-command.ts\n\n\n\n\n// libs/utils/significant-node.ts\n\nfunction firstSignificantNode(nodes, parbreaksAreInsignificant) {\n  const index = firstSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n  if (index == null) {\n    return null;\n  }\n  return nodes[index];\n}\nfunction lastSignificantNode(nodes, parbreaksAreInsignificant) {\n  const index = lastSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n  if (index == null) {\n    return null;\n  }\n  return nodes[index];\n}\nfunction lastSignificantNodeIndex(nodes, parbreaksAreInsignificant) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    const node = nodes[i];\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespace(node) || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].comment(node) || parbreaksAreInsignificant && _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].parbreak(node)) {\n      continue;\n    }\n    return i;\n  }\n  return void 0;\n}\nfunction firstSignificantNodeIndex(nodes, parbreaksAreInsignificant) {\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespace(node) || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].comment(node) || parbreaksAreInsignificant && _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].parbreak(node)) {\n      continue;\n    }\n    return i;\n  }\n  return void 0;\n}\n\n// libs/utils/replace-streaming-command-in-array.ts\n\n\n// libs/utils/join-without-excess-whitespace.ts\n\n\nfunction isSpaceLike(node) {\n  return _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespace(node) || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].comment(node) && Boolean(node.leadingWhitespace);\n}\nfunction joinWithoutExcessWhitespace(head, tail) {\n  if (tail.length === 0) {\n    return;\n  }\n  if (head.length === 0) {\n    head.push(...tail);\n    return;\n  }\n  const headEnd = head[head.length - 1];\n  const tailStart = tail[0];\n  if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespace(headEnd) && _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespace(tailStart)) {\n    head.push(...tail.slice(1));\n    return;\n  }\n  if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespace(headEnd) && _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].comment(tailStart)) {\n      const comment2 = {\n        type: \"comment\",\n        content: tailStart.content,\n        sameline: true,\n        leadingWhitespace: true\n      };\n      tail = tail.slice(1);\n      Object(_unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__[\"trimStart\"])(tail);\n      head.pop();\n      head.push(comment2, ...tail);\n      return;\n    }\n    head.push(...tail);\n    return;\n  }\n  if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].comment(headEnd) && _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].comment(tailStart)) {\n    if (tailStart.leadingWhitespace || tailStart.sameline) {\n      head.push({ type: \"comment\", content: tailStart.content }, ...tail.slice(1));\n      return;\n    }\n    head.push(...tail);\n    return;\n  }\n  let comment = _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].comment(headEnd) ? headEnd : tailStart;\n  if (!_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].comment(comment)) {\n    throw new Error(`Expected a comment but found ${JSON.stringify(comment)}`);\n  }\n  if (!comment.leadingWhitespace || !comment.sameline) {\n    comment = {\n      type: \"comment\",\n      content: comment.content,\n      leadingWhitespace: true,\n      sameline: true\n    };\n  }\n  head.pop();\n  head.push(comment, ...tail.slice(1));\n}\n\n// libs/utils/wrap-significant-content.ts\n\nfunction wrapSignificantContent(content, wrapper) {\n  let hoistUntil = 0;\n  let hoistAfter = content.length;\n  for (let i = 0; i < content.length; i++) {\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespace(content[i]) || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].comment(content[i])) {\n      hoistUntil = i + 1;\n      continue;\n    }\n    break;\n  }\n  for (let j = content.length - 1; j >= 0; j--) {\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespace(content[j]) || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].comment(content[j])) {\n      hoistAfter = j;\n      continue;\n    }\n    break;\n  }\n  if (hoistUntil === 0 && hoistAfter === content.length) {\n    return ensureArray(wrapper(content));\n  }\n  const frontMatter = content.slice(0, hoistUntil);\n  const middle = content.slice(hoistUntil, hoistAfter);\n  const backMatter = content.slice(hoistAfter, content.length);\n  return frontMatter.concat(wrapper(middle), backMatter);\n}\nfunction ensureArray(x) {\n  if (!Array.isArray(x)) {\n    return [x];\n  }\n  return x;\n}\n\n// libs/utils/replace-streaming-command-in-array.ts\nfunction replaceStreamingCommandInArray(nodes, isStreamingCommand, replacer) {\n  while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {\n    nodes.pop();\n    Object(_unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__[\"trimEnd\"])(nodes);\n  }\n  const foundStreamingCommands = [];\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    const node = nodes[i];\n    if (isStreamingCommand(node)) {\n      const wrapper = (content) => replacer(content, node);\n      let tail = nodes.slice(i + 1);\n      Object(_unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__[\"trimStart\"])(tail);\n      tail = wrapSignificantContent(tail, wrapper);\n      foundStreamingCommands.push(node);\n      nodes.splice(i);\n      joinWithoutExcessWhitespace(nodes, tail);\n    }\n  }\n  return { foundStreamingCommands };\n}\n\n// libs/replace-streaming-command.ts\nfunction replaceStreamingCommandInGroup(group, isStreamingCommand, replacer, options) {\n  const content = group.content;\n  let popFromGroup = isStreamingCommand(firstSignificantNode(content));\n  let innerProcessed = replaceStreamingCommand(content, isStreamingCommand, replacer, options);\n  if (innerProcessed.length === 0) {\n    return [];\n  }\n  if (popFromGroup) {\n    return innerProcessed;\n  } else {\n    return [{ type: \"group\", content: innerProcessed }];\n  }\n}\nfunction replaceStreamingCommand(ast, isStreamingCommand, replacer, options) {\n  if (typeof isStreamingCommand !== \"function\") {\n    throw new Error(`'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`);\n  }\n  const {\n    macrosThatBreakPars = [\n      \"part\",\n      \"chapter\",\n      \"section\",\n      \"subsection\",\n      \"subsubsection\",\n      \"vspace\",\n      \"smallskip\",\n      \"medskip\",\n      \"bigskip\",\n      \"hfill\"\n    ],\n    environmentsThatDontBreakPars = []\n  } = options || {};\n  let processedContent = [];\n  if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].group(ast)) {\n    processedContent = replaceStreamingCommandInGroup(ast, isStreamingCommand, replacer);\n  }\n  if (Array.isArray(ast)) {\n    const nodes = ast;\n    let scanIndex = nodes.length;\n    let sliceIndex = scanIndex;\n    while (scanIndex > 0 && (isStreamingCommand(nodes[scanIndex - 1]) || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespace(nodes[scanIndex - 1]))) {\n      scanIndex--;\n      if (isStreamingCommand(nodes[scanIndex])) {\n        sliceIndex = scanIndex;\n      }\n    }\n    if (sliceIndex !== nodes.length) {\n      nodes.splice(sliceIndex);\n    }\n    const macroThatBreaks = _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].createMacroMatcher(macrosThatBreakPars);\n    const envThatDoesntBreak = _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].createEnvironmentMatcher(environmentsThatDontBreakPars);\n    const isPar = (node) => _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].parbreak(node) || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].macro(node, \"par\") || macroThatBreaks(node) || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].environment(node) && !envThatDoesntBreak(node) || node.type === \"displaymath\";\n    const splitByPar = Object(_unified_latex_unified_latex_util_split__WEBPACK_IMPORTED_MODULE_3__[\"splitOnCondition\"])(nodes, isPar);\n    splitByPar.separators = splitByPar.separators.map((sep) => _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].macro(sep, \"par\") ? { type: \"parbreak\" } : sep);\n    const replacers = [];\n    let segments = splitByPar.segments.map((segment) => {\n      if (segment.length === 0) {\n        return segment;\n      }\n      function applyAccumulatedReplacers(nodes2) {\n        if (replacers.length === 0) {\n          return nodes2;\n        }\n        return wrapSignificantContent(nodes2, composeReplacers(replacers));\n      }\n      const { foundStreamingCommands } = replaceStreamingCommandInArray(segment, isStreamingCommand, replacer);\n      const ret = applyAccumulatedReplacers(segment);\n      foundStreamingCommands.forEach((macro) => {\n        replacers.push((nodes2) => {\n          const ret2 = replacer(nodes2, macro);\n          if (!Array.isArray(ret2)) {\n            return [ret2];\n          }\n          return ret2;\n        });\n      });\n      return ret;\n    });\n    if (segments.length > 1) {\n      segments.forEach((segment, i) => {\n        if (i === 0) {\n          Object(_unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__[\"trimEnd\"])(segment);\n        } else if (i === segments.length - 1) {\n          Object(_unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__[\"trimStart\"])(segment);\n        } else {\n          Object(_unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__[\"trim\"])(segment);\n        }\n      });\n    }\n    processedContent = Object(_unified_latex_unified_latex_util_split__WEBPACK_IMPORTED_MODULE_3__[\"unsplitOnMacro\"])({\n      segments,\n      macros: splitByPar.separators\n    });\n  }\n  return processedContent;\n}\nfunction composeReplacers(replacers) {\n  if (replacers.length === 0) {\n    throw new Error(\"Cannot compose zero replacement functions\");\n  }\n  return (nodes) => {\n    let ret = nodes;\n    for (let i = 0; i < replacers.length; i++) {\n      const func = replacers[i];\n      ret = func(ret);\n    }\n    return ret;\n  };\n}\n\n// libs/replace-node-during-visit.ts\nfunction replaceNodeDuringVisit(replacement, info) {\n  const parent = info.parents[0];\n  if (!parent) {\n    throw new Error(`Cannot replace node: parent not found`);\n  }\n  const container = parent[info.key];\n  if (!Array.isArray(container)) {\n    throw new Error(`Cannot replace node: containing array not found`);\n  }\n  if (info.index == null) {\n    throw new Error(`Cannot replace node: node index undefined`);\n  }\n  if (!Array.isArray(replacement)) {\n    container[info.index] = replacement;\n  } else {\n    container.splice(info.index, 1, ...replacement);\n  }\n}\n\n// libs/unified-latex-streaming-command.ts\nvar unifiedLatexReplaceStreamingCommands = function unifiedLatexReplaceStreamingCommands2(options) {\n  const { replacers = {} } = options || {};\n  const isReplaceable = _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].createMacroMatcher(replacers);\n  return (tree) => {\n    Object(_unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__[\"visit\"])(tree, (group, info) => {\n      if (info.context.hasMathModeAncestor || !group.content.some(isReplaceable)) {\n        return;\n      }\n      let fixed = replaceStreamingCommand(group, isReplaceable, (content, command) => {\n        return replacers[command.content](content, command);\n      });\n      if (!info.containingArray || info.index == null) {\n        return;\n      }\n      const prevToken = info.containingArray[info.index - 1];\n      const nextToken = info.containingArray[info.index + 1];\n      if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespaceLike(prevToken) && _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespaceLike(fixed[0])) {\n        Object(_unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__[\"trimStart\"])(fixed);\n      }\n      if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespaceLike(nextToken) && _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].whitespaceLike(fixed[fixed.length - 1])) {\n        Object(_unified_latex_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__[\"trimEnd\"])(fixed);\n      }\n      replaceNodeDuringVisit(fixed, info);\n    }, { test: _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__[\"match\"].group });\n    Object(_unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__[\"visit\"])(tree, (nodes, info) => {\n      if (info.context.hasMathModeAncestor || !nodes.some(isReplaceable)) {\n        return;\n      }\n      const replaced = replaceStreamingCommand(nodes, isReplaceable, (content, command) => {\n        return replacers[command.content](content, command);\n      });\n      if (replaced !== nodes) {\n        nodes.length = 0;\n        nodes.push(...replaced);\n      }\n    }, { includeArrays: true, test: Array.isArray });\n  };\n};\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-util-replace/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-util-split/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-util-split/index.js ***!
  \***********************************************************************/
/*! exports provided: arrayJoin, splitOnCondition, splitOnMacro, unsplitOnMacro */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arrayJoin\", function() { return arrayJoin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitOnCondition\", function() { return splitOnCondition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitOnMacro\", function() { return splitOnMacro; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unsplitOnMacro\", function() { return unsplitOnMacro; });\n/* harmony import */ var _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @unified-latex/unified-latex-util-match */ \"./node_modules/@unified-latex/unified-latex-util-match/index.js\");\n// libs/split-on-macro.ts\n\n\n// libs/split-on-condition.ts\nfunction splitOnCondition(nodes, splitFunc = () => false, options) {\n  if (!Array.isArray(nodes)) {\n    throw new Error(`Can only split an Array, not ${nodes}`);\n  }\n  const { onlySplitOnFirstOccurrence = false } = options || {};\n  const splitIndices = [];\n  for (let i = 0; i < nodes.length; i++) {\n    if (splitFunc(nodes[i])) {\n      splitIndices.push(i);\n      if (onlySplitOnFirstOccurrence) {\n        break;\n      }\n    }\n  }\n  if (splitIndices.length === 0) {\n    return { segments: [nodes], separators: [] };\n  }\n  let separators = splitIndices.map((i) => nodes[i]);\n  let segments = splitIndices.map((splitEnd, i) => {\n    const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;\n    return nodes.slice(splitStart, splitEnd);\n  });\n  segments.push(nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length));\n  return { segments, separators };\n}\n\n// libs/split-on-macro.ts\nfunction splitOnMacro(ast, macroName) {\n  if (typeof macroName === \"string\") {\n    macroName = [macroName];\n  }\n  if (!Array.isArray(macroName)) {\n    throw new Error(\"Type coercion failed\");\n  }\n  const isSeparator = _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].createMacroMatcher(macroName);\n  const { segments, separators } = splitOnCondition(ast, isSeparator);\n  return { segments, macros: separators };\n}\n\n// libs/unsplit-on-macro.ts\nfunction unsplitOnMacro({\n  segments,\n  macros\n}) {\n  if (segments.length === 0) {\n    console.warn(\"Trying to join zero segments\");\n    return [];\n  }\n  if (segments.length !== macros.length + 1) {\n    console.warn(\"Mismatch between lengths of macros and segments when trying to unsplit\");\n  }\n  let ret = segments[0];\n  for (let i = 0; i < macros.length; i++) {\n    ret = ret.concat(macros[i]).concat(segments[i + 1]);\n  }\n  return ret;\n}\n\n// libs/array-join.ts\nfunction arrayJoin(array, sep) {\n  return array.flatMap((item, i) => {\n    if (i === 0) {\n      return item;\n    }\n    if (Array.isArray(sep)) {\n      return [...sep, ...item];\n    } else {\n      return [sep, ...item];\n    }\n  });\n}\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-util-split/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-util-trim/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-util-trim/index.js ***!
  \**********************************************************************/
/*! exports provided: hasWhitespaceEquivalent, trim, trimEnd, trimStart, unifiedLatexTrimEnvironmentContents, unifiedLatexTrimRoot */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasWhitespaceEquivalent\", function() { return hasWhitespaceEquivalent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trim\", function() { return trim; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trimEnd\", function() { return trimEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trimStart\", function() { return trimStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unifiedLatexTrimEnvironmentContents\", function() { return unifiedLatexTrimEnvironmentContents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unifiedLatexTrimRoot\", function() { return unifiedLatexTrimRoot; });\n/* harmony import */ var _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @unified-latex/unified-latex-util-match */ \"./node_modules/@unified-latex/unified-latex-util-match/index.js\");\n/* harmony import */ var _unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @unified-latex/unified-latex-util-visit */ \"./node_modules/@unified-latex/unified-latex-util-visit/index.js\");\n// libs/trim.ts\n\nfunction trim(nodes) {\n  if (!Array.isArray(nodes)) {\n    console.warn(\"Trying to trim a non-array ast\", nodes);\n    return nodes;\n  }\n  const { trimmedStart } = trimStart(nodes);\n  const { trimmedEnd } = trimEnd(nodes);\n  return { trimmedStart, trimmedEnd };\n}\nfunction trimStart(nodes) {\n  const { start } = amountOfLeadingAndTrailingWhitespace(nodes);\n  nodes.splice(0, start);\n  for (const leadingToken of nodes) {\n    if (!_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].comment(leadingToken)) {\n      break;\n    }\n    if (leadingToken.leadingWhitespace || leadingToken.sameline) {\n      leadingToken.leadingWhitespace = false;\n      delete leadingToken.position;\n    }\n    if (start > 0 && leadingToken.sameline) {\n      leadingToken.sameline = false;\n      delete leadingToken.position;\n    }\n  }\n  return { trimmedStart: start };\n}\nfunction trimEnd(nodes) {\n  const { end } = amountOfLeadingAndTrailingWhitespace(nodes);\n  nodes.splice(nodes.length - end, end);\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    const trailingToken = nodes[i];\n    if (!_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].comment(trailingToken)) {\n      break;\n    }\n    delete trailingToken.suffixParbreak;\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].comment(trailingToken) && trailingToken.leadingWhitespace && !trailingToken.sameline) {\n      trailingToken.leadingWhitespace = false;\n      delete trailingToken.position;\n    }\n  }\n  return { trimmedEnd: end };\n}\nfunction amountOfLeadingAndTrailingWhitespace(ast) {\n  let start = 0;\n  let end = 0;\n  for (const node of ast) {\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].whitespace(node) || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].parbreak(node)) {\n      start++;\n    } else {\n      break;\n    }\n  }\n  if (start === ast.length) {\n    return { start, end: 0 };\n  }\n  for (let i = ast.length - 1; i >= 0; i--) {\n    const node = ast[i];\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].whitespace(node) || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].parbreak(node)) {\n      end++;\n    } else {\n      break;\n    }\n  }\n  return { start, end };\n}\n\n// libs/unified-latex-trim-environment-contents.ts\n\n\nvar unifiedLatexTrimEnvironmentContents = function unifiedLatexTrimEnvironmentContents2() {\n  return (tree) => {\n    Object(_unified_latex_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__[\"visit\"])(tree, (node) => {\n      if (!(_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].math(node) || _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].anyEnvironment(node))) {\n        return;\n      }\n      let firstNode = node.content[0];\n      if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].comment(firstNode) && firstNode.sameline) {\n        firstNode.suffixParbreak = false;\n        trimEnd(node.content);\n        const { trimmedStart } = trimStart(node.content.slice(1));\n        node.content.splice(1, trimmedStart);\n      } else {\n        trim(node.content);\n      }\n    });\n  };\n};\n\n// libs/unified-latex-trim-root.ts\nvar unifiedLatexTrimRoot = function unifiedLatexTrimRoot2() {\n  return (tree) => {\n    trim(tree.content);\n  };\n};\n\n// libs/has-whitespace-equivalent.ts\n\nfunction hasWhitespaceEquivalent(nodes) {\n  let start = false;\n  let end = false;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].comment(node)) {\n      if (node.leadingWhitespace) {\n        start = true;\n        break;\n      }\n      continue;\n    }\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].whitespace(node)) {\n      start = true;\n    }\n    break;\n  }\n  for (let j = nodes.length - 1; j >= 0; j--) {\n    const node = nodes[j];\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].comment(node)) {\n      if (node.leadingWhitespace) {\n        end = true;\n        break;\n      }\n      continue;\n    }\n    if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].whitespace(node)) {\n      end = true;\n    }\n    break;\n  }\n  return { start, end };\n}\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-util-trim/index.js?");

/***/ }),

/***/ "./node_modules/@unified-latex/unified-latex-util-visit/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@unified-latex/unified-latex-util-visit/index.js ***!
  \***********************************************************************/
/*! exports provided: CONTINUE, EXIT, SKIP, visit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CONTINUE\", function() { return CONTINUE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EXIT\", function() { return EXIT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SKIP\", function() { return SKIP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"visit\", function() { return visit; });\n/* harmony import */ var _unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @unified-latex/unified-latex-util-match */ \"./node_modules/@unified-latex/unified-latex-util-match/index.js\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\n\n// libs/list-math-children.ts\n\nfunction listMathChildren(node) {\n  const NULL_RETURN = { enter: [], leave: [] };\n  if (Array.isArray(node)) {\n    return NULL_RETURN;\n  }\n  if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].math(node)) {\n    return { enter: [\"content\"], leave: [] };\n  }\n  const renderInfo = node._renderInfo || {};\n  if (renderInfo.inMathMode == null) {\n    return NULL_RETURN;\n  }\n  if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].macro(node)) {\n    if (renderInfo.inMathMode === true) {\n      return { enter: [\"args\"], leave: [] };\n    } else if (renderInfo.inMathMode === false) {\n      return { enter: [], leave: [\"args\"] };\n    }\n  }\n  if (_unified_latex_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__[\"match\"].environment(node)) {\n    if (renderInfo.inMathMode === true) {\n      return { enter: [\"content\"], leave: [] };\n    } else {\n      return { enter: [], leave: [\"content\"] };\n    }\n  }\n  return NULL_RETURN;\n}\n\n// libs/visit.ts\nvar CONTINUE = Symbol(\"continue\");\nvar SKIP = Symbol(\"skip\");\nvar EXIT = Symbol(\"exit\");\nvar DEFAULT_CONTEXT = {\n  inMathMode: false,\n  hasMathModeAncestor: false\n};\nfunction visit(tree, visitor, options) {\n  const {\n    startingContext = DEFAULT_CONTEXT,\n    test = () => true,\n    includeArrays = false\n  } = options || {};\n  let enter;\n  let leave;\n  if (typeof visitor === \"function\") {\n    enter = visitor;\n  } else if (visitor && typeof visitor === \"object\") {\n    enter = visitor.enter;\n    leave = visitor.leave;\n  }\n  walk(tree, {\n    key: void 0,\n    index: void 0,\n    parents: [],\n    containingArray: void 0,\n    context: __spreadValues({}, startingContext)\n  });\n  function walk(node, { key, index, parents, context, containingArray }) {\n    const nodePassesTest = includeArrays ? test(node, { key, index, parents, context, containingArray }) : !Array.isArray(node) && test(node, { key, index, parents, context, containingArray });\n    const result = enter && nodePassesTest ? toResult(enter(node, {\n      key,\n      index,\n      parents,\n      context,\n      containingArray\n    })) : [CONTINUE];\n    if (result[0] === EXIT) {\n      return result;\n    }\n    if (result[0] === SKIP) {\n      return leave && nodePassesTest ? toResult(leave(node, {\n        key,\n        index,\n        parents,\n        context,\n        containingArray\n      })) : result;\n    }\n    if (Array.isArray(node)) {\n      for (let index2 = 0; index2 > -1 && index2 < node.length; index2++) {\n        const item = node[index2];\n        const result2 = walk(item, {\n          key,\n          index: index2,\n          parents,\n          context,\n          containingArray: node\n        });\n        if (result2[0] === EXIT) {\n          return result2;\n        }\n        if (typeof result2[1] === \"number\") {\n          index2 = result2[1] - 1;\n        }\n      }\n    } else {\n      let childProps = [\"content\", \"args\"];\n      switch (node.type) {\n        case \"macro\":\n          childProps = [\"args\"];\n          break;\n        case \"comment\":\n        case \"string\":\n        case \"verb\":\n        case \"verbatim\":\n          childProps = [];\n          break;\n        default:\n          break;\n      }\n      const mathModeProps = listMathChildren(node);\n      for (const key2 of childProps) {\n        const value = node[key2];\n        const grandparents = [node].concat(parents);\n        if (value == null) {\n          continue;\n        }\n        const newContext = __spreadValues({}, context);\n        if (mathModeProps.enter.includes(key2)) {\n          newContext.inMathMode = true;\n          newContext.hasMathModeAncestor = true;\n        } else if (mathModeProps.leave.includes(key2)) {\n          newContext.inMathMode = false;\n        }\n        const result2 = walk(value, {\n          key: key2,\n          index: void 0,\n          parents: grandparents,\n          context: newContext,\n          containingArray: void 0\n        });\n        if (result2[0] === EXIT) {\n          return result2;\n        }\n      }\n    }\n    return leave && nodePassesTest ? toResult(leave(node, {\n      key,\n      index,\n      parents,\n      context,\n      containingArray\n    })) : result;\n  }\n}\nfunction toResult(value) {\n  if (value == null) {\n    return [CONTINUE];\n  }\n  if (Array.isArray(value)) {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return [CONTINUE, value];\n  }\n  return [value];\n}\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@unified-latex/unified-latex-util-visit/index.js?");

/***/ }),

/***/ "./node_modules/bail/index.js":
/*!************************************!*\
  !*** ./node_modules/bail/index.js ***!
  \************************************/
/*! exports provided: bail */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bail\", function() { return bail; });\n/**\n * Throw a given error.\n *\n * @param {Error|null|undefined} [error]\n *   Maybe error.\n * @returns {asserts error is null|undefined}\n */\nfunction bail(error) {\n  if (error) {\n    throw error\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/bail/index.js?");

/***/ }),

/***/ "./node_modules/color-convert/conversions.js":
/*!***************************************************!*\
  !*** ./node_modules/color-convert/conversions.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* MIT license */\n/* eslint-disable no-mixed-operators */\nconst cssKeywords = __webpack_require__(/*! color-name */ \"./node_modules/color-name/index.js\");\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nconst reverseKeywords = {};\nfor (const key of Object.keys(cssKeywords)) {\n\treverseKeywords[cssKeywords[key]] = key;\n}\n\nconst convert = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\nmodule.exports = convert;\n\n// Hide .channels and .labels properties\nfor (const model of Object.keys(convert)) {\n\tif (!('channels' in convert[model])) {\n\t\tthrow new Error('missing channels property: ' + model);\n\t}\n\n\tif (!('labels' in convert[model])) {\n\t\tthrow new Error('missing channel labels property: ' + model);\n\t}\n\n\tif (convert[model].labels.length !== convert[model].channels) {\n\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t}\n\n\tconst {channels, labels} = convert[model];\n\tdelete convert[model].channels;\n\tdelete convert[model].labels;\n\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\tObject.defineProperty(convert[model], 'labels', {value: labels});\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst min = Math.min(r, g, b);\n\tconst max = Math.max(r, g, b);\n\tconst delta = max - min;\n\tlet h;\n\tlet s;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst l = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tlet rdif;\n\tlet gdif;\n\tlet bdif;\n\tlet h;\n\tlet s;\n\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst v = Math.max(r, g, b);\n\tconst diff = v - Math.min(r, g, b);\n\tconst diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = 0;\n\t\ts = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tconst r = rgb[0];\n\tconst g = rgb[1];\n\tlet b = rgb[2];\n\tconst h = convert.rgb.hsl(rgb)[0];\n\tconst w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\n\tconst k = Math.min(1 - r, 1 - g, 1 - b);\n\tconst c = (1 - r - k) / (1 - k) || 0;\n\tconst m = (1 - g - k) / (1 - k) || 0;\n\tconst y = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\nfunction comparativeDistance(x, y) {\n\t/*\n\t\tSee https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n\t*/\n\treturn (\n\t\t((x[0] - y[0]) ** 2) +\n\t\t((x[1] - y[1]) ** 2) +\n\t\t((x[2] - y[2]) ** 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tconst reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tlet currentClosestDistance = Infinity;\n\tlet currentClosestKeyword;\n\n\tfor (const keyword of Object.keys(cssKeywords)) {\n\t\tconst value = cssKeywords[keyword];\n\n\t\t// Compute comparative distance\n\t\tconst distance = comparativeDistance(rgb, value);\n\n\t\t// Check if its less, if so set as closest\n\t\tif (distance < currentClosestDistance) {\n\t\t\tcurrentClosestDistance = distance;\n\t\t\tcurrentClosestKeyword = keyword;\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tlet r = rgb[0] / 255;\n\tlet g = rgb[1] / 255;\n\tlet b = rgb[2] / 255;\n\n\t// Assume sRGB\n\tr = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);\n\n\tconst x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tconst y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tconst z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tconst xyz = convert.rgb.xyz(rgb);\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tconst h = hsl[0] / 360;\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\tlet t2;\n\tlet t3;\n\tlet val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tconst t1 = 2 * l - t2;\n\n\tconst rgb = [0, 0, 0];\n\tfor (let i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tconst h = hsl[0];\n\tlet s = hsl[1] / 100;\n\tlet l = hsl[2] / 100;\n\tlet smin = s;\n\tconst lmin = Math.max(l, 0.01);\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tconst v = (l + s) / 2;\n\tconst sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tconst h = hsv[0] / 60;\n\tconst s = hsv[1] / 100;\n\tlet v = hsv[2] / 100;\n\tconst hi = Math.floor(h) % 6;\n\n\tconst f = h - Math.floor(h);\n\tconst p = 255 * v * (1 - s);\n\tconst q = 255 * v * (1 - (s * f));\n\tconst t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tconst h = hsv[0];\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\tconst vmin = Math.max(v, 0.01);\n\tlet sl;\n\tlet l;\n\n\tl = (2 - s) * v;\n\tconst lmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tconst h = hwb[0] / 360;\n\tlet wh = hwb[1] / 100;\n\tlet bl = hwb[2] / 100;\n\tconst ratio = wh + bl;\n\tlet f;\n\n\t// Wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\tconst i = Math.floor(6 * h);\n\tconst v = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tconst n = wh + f * (v - wh); // Linear interpolation\n\n\tlet r;\n\tlet g;\n\tlet b;\n\t/* eslint-disable max-statements-per-line,no-multi-spaces */\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v;  g = n;  b = wh; break;\n\t\tcase 1: r = n;  g = v;  b = wh; break;\n\t\tcase 2: r = wh; g = v;  b = n; break;\n\t\tcase 3: r = wh; g = n;  b = v; break;\n\t\tcase 4: r = n;  g = wh; b = v; break;\n\t\tcase 5: r = v;  g = wh; b = n; break;\n\t}\n\t/* eslint-enable max-statements-per-line,no-multi-spaces */\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tconst c = cmyk[0] / 100;\n\tconst m = cmyk[1] / 100;\n\tconst y = cmyk[2] / 100;\n\tconst k = cmyk[3] / 100;\n\n\tconst r = 1 - Math.min(1, c * (1 - k) + k);\n\tconst g = 1 - Math.min(1, m * (1 - k) + k);\n\tconst b = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tconst x = xyz[0] / 100;\n\tconst y = xyz[1] / 100;\n\tconst z = xyz[2] / 100;\n\tlet r;\n\tlet g;\n\tlet b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// Assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet x;\n\tlet y;\n\tlet z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tconst y2 = y ** 3;\n\tconst x2 = x ** 3;\n\tconst z2 = z ** 3;\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet h;\n\n\tconst hr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst c = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tconst l = lch[0];\n\tconst c = lch[1];\n\tconst h = lch[2];\n\n\tconst hr = h / 360 * 2 * Math.PI;\n\tconst a = c * Math.cos(hr);\n\tconst b = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args, saturation = null) {\n\tconst [r, g, b] = args;\n\tlet value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tlet ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// Optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tconst r = args[0];\n\tconst g = args[1];\n\tconst b = args[2];\n\n\t// We use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tconst ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tlet color = args % 10;\n\n\t// Handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tconst mult = (~~(args > 50) + 1) * 0.5;\n\tconst r = ((color & 1) * mult) * 255;\n\tconst g = (((color >> 1) & 1) * mult) * 255;\n\tconst b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// Handle greyscale\n\tif (args >= 232) {\n\t\tconst c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tlet rem;\n\tconst r = Math.floor(args / 36) / 5 * 255;\n\tconst g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tconst b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tconst integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tconst match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tlet colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(char => {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tconst integer = parseInt(colorString, 16);\n\tconst r = (integer >> 16) & 0xFF;\n\tconst g = (integer >> 8) & 0xFF;\n\tconst b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst max = Math.max(Math.max(r, g), b);\n\tconst min = Math.min(Math.min(r, g), b);\n\tconst chroma = (max - min);\n\tlet grayscale;\n\tlet hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\n\tconst c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));\n\n\tlet f = 0;\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\n\tconst c = s * v;\n\tlet f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tconst h = hcg[0] / 360;\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tconst pure = [0, 0, 0];\n\tconst hi = (h % 1) * 6;\n\tconst v = hi % 1;\n\tconst w = 1 - v;\n\tlet mg = 0;\n\n\t/* eslint-disable max-statements-per-line */\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\t/* eslint-enable max-statements-per-line */\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst v = c + g * (1.0 - c);\n\tlet f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst l = g * (1.0 - c) + 0.5 * c;\n\tlet s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\tconst v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tconst w = hwb[1] / 100;\n\tconst b = hwb[2] / 100;\n\tconst v = 1 - b;\n\tconst c = v - w;\n\tlet g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hsv = convert.gray.hsl;\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tconst val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tconst integer = (val << 16) + (val << 8) + val;\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tconst val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n\n\n//# sourceURL=webpack:///./node_modules/color-convert/conversions.js?");

/***/ }),

/***/ "./node_modules/color-convert/index.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const conversions = __webpack_require__(/*! ./conversions */ \"./node_modules/color-convert/conversions.js\");\nconst route = __webpack_require__(/*! ./route */ \"./node_modules/color-convert/route.js\");\n\nconst convert = {};\n\nconst models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\tconst result = fn(args);\n\n\t\t// We're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(fromModel => {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tconst routes = route(fromModel);\n\tconst routeModels = Object.keys(routes);\n\n\trouteModels.forEach(toModel => {\n\t\tconst fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n\n\n//# sourceURL=webpack:///./node_modules/color-convert/index.js?");

/***/ }),

/***/ "./node_modules/color-convert/route.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/route.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const conversions = __webpack_require__(/*! ./conversions */ \"./node_modules/color-convert/conversions.js\");\n\n/*\n\tThis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tconst graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tconst models = Object.keys(conversions);\n\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tconst graph = buildGraph();\n\tconst queue = [fromModel]; // Unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tconst current = queue.pop();\n\t\tconst adjacents = Object.keys(conversions[current]);\n\n\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tconst adjacent = adjacents[i];\n\t\t\tconst node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tconst path = [graph[toModel].parent, toModel];\n\tlet fn = conversions[graph[toModel].parent][toModel];\n\n\tlet cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tconst graph = deriveBFS(fromModel);\n\tconst conversion = {};\n\n\tconst models = Object.keys(graph);\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tconst toModel = models[i];\n\t\tconst node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// No possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/color-convert/route.js?");

/***/ }),

/***/ "./node_modules/color-name/index.js":
/*!******************************************!*\
  !*** ./node_modules/color-name/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/color-name/index.js?");

/***/ }),

/***/ "./node_modules/color-string/index.js":
/*!********************************************!*\
  !*** ./node_modules/color-string/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* MIT license */\nvar colorNames = __webpack_require__(/*! color-name */ \"./node_modules/color-name/index.js\");\nvar swizzle = __webpack_require__(/*! simple-swizzle */ \"./node_modules/simple-swizzle/index.js\");\nvar hasOwnProperty = Object.hasOwnProperty;\n\nvar reverseNames = Object.create(null);\n\n// create a list of reverse color names\nfor (var name in colorNames) {\n\tif (hasOwnProperty.call(colorNames, name)) {\n\t\treverseNames[colorNames[name]] = name;\n\t}\n}\n\nvar cs = module.exports = {\n\tto: {},\n\tget: {}\n};\n\ncs.get = function (string) {\n\tvar prefix = string.substring(0, 3).toLowerCase();\n\tvar val;\n\tvar model;\n\tswitch (prefix) {\n\t\tcase 'hsl':\n\t\t\tval = cs.get.hsl(string);\n\t\t\tmodel = 'hsl';\n\t\t\tbreak;\n\t\tcase 'hwb':\n\t\t\tval = cs.get.hwb(string);\n\t\t\tmodel = 'hwb';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval = cs.get.rgb(string);\n\t\t\tmodel = 'rgb';\n\t\t\tbreak;\n\t}\n\n\tif (!val) {\n\t\treturn null;\n\t}\n\n\treturn {model: model, value: val};\n};\n\ncs.get.rgb = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar abbr = /^#([a-f0-9]{3,4})$/i;\n\tvar hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;\n\tvar rgba = /^rgba?\\(\\s*([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/;\n\tvar per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/;\n\tvar keyword = /^(\\w+)$/;\n\n\tvar rgb = [0, 0, 0, 1];\n\tvar match;\n\tvar i;\n\tvar hexAlpha;\n\n\tif (match = string.match(hex)) {\n\t\thexAlpha = match[2];\n\t\tmatch = match[1];\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\t// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19\n\t\t\tvar i2 = i * 2;\n\t\t\trgb[i] = parseInt(match.slice(i2, i2 + 2), 16);\n\t\t}\n\n\t\tif (hexAlpha) {\n\t\t\trgb[3] = parseInt(hexAlpha, 16) / 255;\n\t\t}\n\t} else if (match = string.match(abbr)) {\n\t\tmatch = match[1];\n\t\thexAlpha = match[3];\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = parseInt(match[i] + match[i], 16);\n\t\t}\n\n\t\tif (hexAlpha) {\n\t\t\trgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;\n\t\t}\n\t} else if (match = string.match(rgba)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = parseInt(match[i + 1], 0);\n\t\t}\n\n\t\tif (match[4]) {\n\t\t\tif (match[5]) {\n\t\t\t\trgb[3] = parseFloat(match[4]) * 0.01;\n\t\t\t} else {\n\t\t\t\trgb[3] = parseFloat(match[4]);\n\t\t\t}\n\t\t}\n\t} else if (match = string.match(per)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n\t\t}\n\n\t\tif (match[4]) {\n\t\t\tif (match[5]) {\n\t\t\t\trgb[3] = parseFloat(match[4]) * 0.01;\n\t\t\t} else {\n\t\t\t\trgb[3] = parseFloat(match[4]);\n\t\t\t}\n\t\t}\n\t} else if (match = string.match(keyword)) {\n\t\tif (match[1] === 'transparent') {\n\t\t\treturn [0, 0, 0, 0];\n\t\t}\n\n\t\tif (!hasOwnProperty.call(colorNames, match[1])) {\n\t\t\treturn null;\n\t\t}\n\n\t\trgb = colorNames[match[1]];\n\t\trgb[3] = 1;\n\n\t\treturn rgb;\n\t} else {\n\t\treturn null;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\trgb[i] = clamp(rgb[i], 0, 255);\n\t}\n\trgb[3] = clamp(rgb[3], 0, 1);\n\n\treturn rgb;\n};\n\ncs.get.hsl = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar hsl = /^hsla?\\(\\s*([+-]?(?:\\d{0,3}\\.)?\\d+)(?:deg)?\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*(?:[,|\\/]\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/;\n\tvar match = string.match(hsl);\n\n\tif (match) {\n\t\tvar alpha = parseFloat(match[4]);\n\t\tvar h = ((parseFloat(match[1]) % 360) + 360) % 360;\n\t\tvar s = clamp(parseFloat(match[2]), 0, 100);\n\t\tvar l = clamp(parseFloat(match[3]), 0, 100);\n\t\tvar a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);\n\n\t\treturn [h, s, l, a];\n\t}\n\n\treturn null;\n};\n\ncs.get.hwb = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar hwb = /^hwb\\(\\s*([+-]?\\d{0,3}(?:\\.\\d+)?)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/;\n\tvar match = string.match(hwb);\n\n\tif (match) {\n\t\tvar alpha = parseFloat(match[4]);\n\t\tvar h = ((parseFloat(match[1]) % 360) + 360) % 360;\n\t\tvar w = clamp(parseFloat(match[2]), 0, 100);\n\t\tvar b = clamp(parseFloat(match[3]), 0, 100);\n\t\tvar a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);\n\t\treturn [h, w, b, a];\n\t}\n\n\treturn null;\n};\n\ncs.to.hex = function () {\n\tvar rgba = swizzle(arguments);\n\n\treturn (\n\t\t'#' +\n\t\thexDouble(rgba[0]) +\n\t\thexDouble(rgba[1]) +\n\t\thexDouble(rgba[2]) +\n\t\t(rgba[3] < 1\n\t\t\t? (hexDouble(Math.round(rgba[3] * 255)))\n\t\t\t: '')\n\t);\n};\n\ncs.to.rgb = function () {\n\tvar rgba = swizzle(arguments);\n\n\treturn rgba.length < 4 || rgba[3] === 1\n\t\t? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'\n\t\t: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';\n};\n\ncs.to.rgb.percent = function () {\n\tvar rgba = swizzle(arguments);\n\n\tvar r = Math.round(rgba[0] / 255 * 100);\n\tvar g = Math.round(rgba[1] / 255 * 100);\n\tvar b = Math.round(rgba[2] / 255 * 100);\n\n\treturn rgba.length < 4 || rgba[3] === 1\n\t\t? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'\n\t\t: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';\n};\n\ncs.to.hsl = function () {\n\tvar hsla = swizzle(arguments);\n\treturn hsla.length < 4 || hsla[3] === 1\n\t\t? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'\n\t\t: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';\n};\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\ncs.to.hwb = function () {\n\tvar hwba = swizzle(arguments);\n\n\tvar a = '';\n\tif (hwba.length >= 4 && hwba[3] !== 1) {\n\t\ta = ', ' + hwba[3];\n\t}\n\n\treturn 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';\n};\n\ncs.to.keyword = function (rgb) {\n\treturn reverseNames[rgb.slice(0, 3)];\n};\n\n// helpers\nfunction clamp(num, min, max) {\n\treturn Math.min(Math.max(min, num), max);\n}\n\nfunction hexDouble(num) {\n\tvar str = Math.round(num).toString(16).toUpperCase();\n\treturn (str.length < 2) ? '0' + str : str;\n}\n\n\n//# sourceURL=webpack:///./node_modules/color-string/index.js?");

/***/ }),

/***/ "./node_modules/color/index.js":
/*!*************************************!*\
  !*** ./node_modules/color/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const colorString = __webpack_require__(/*! color-string */ \"./node_modules/color-string/index.js\");\nconst convert = __webpack_require__(/*! color-convert */ \"./node_modules/color-convert/index.js\");\n\nconst skippedModels = [\n\t// To be honest, I don't really feel like keyword belongs in color convert, but eh.\n\t'keyword',\n\n\t// Gray conflicts with some method names, and has its own method defined.\n\t'gray',\n\n\t// Shouldn't really be in color-convert either...\n\t'hex',\n];\n\nconst hashedModelKeys = {};\nfor (const model of Object.keys(convert)) {\n\thashedModelKeys[[...convert[model].labels].sort().join('')] = model;\n}\n\nconst limiters = {};\n\nfunction Color(object, model) {\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(object, model);\n\t}\n\n\tif (model && model in skippedModels) {\n\t\tmodel = null;\n\t}\n\n\tif (model && !(model in convert)) {\n\t\tthrow new Error('Unknown model: ' + model);\n\t}\n\n\tlet i;\n\tlet channels;\n\n\tif (object == null) { // eslint-disable-line no-eq-null,eqeqeq\n\t\tthis.model = 'rgb';\n\t\tthis.color = [0, 0, 0];\n\t\tthis.valpha = 1;\n\t} else if (object instanceof Color) {\n\t\tthis.model = object.model;\n\t\tthis.color = [...object.color];\n\t\tthis.valpha = object.valpha;\n\t} else if (typeof object === 'string') {\n\t\tconst result = colorString.get(object);\n\t\tif (result === null) {\n\t\t\tthrow new Error('Unable to parse color from string: ' + object);\n\t\t}\n\n\t\tthis.model = result.model;\n\t\tchannels = convert[this.model].channels;\n\t\tthis.color = result.value.slice(0, channels);\n\t\tthis.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;\n\t} else if (object.length > 0) {\n\t\tthis.model = model || 'rgb';\n\t\tchannels = convert[this.model].channels;\n\t\tconst newArray = Array.prototype.slice.call(object, 0, channels);\n\t\tthis.color = zeroArray(newArray, channels);\n\t\tthis.valpha = typeof object[channels] === 'number' ? object[channels] : 1;\n\t} else if (typeof object === 'number') {\n\t\t// This is always RGB - can be converted later on.\n\t\tthis.model = 'rgb';\n\t\tthis.color = [\n\t\t\t(object >> 16) & 0xFF,\n\t\t\t(object >> 8) & 0xFF,\n\t\t\tobject & 0xFF,\n\t\t];\n\t\tthis.valpha = 1;\n\t} else {\n\t\tthis.valpha = 1;\n\n\t\tconst keys = Object.keys(object);\n\t\tif ('alpha' in object) {\n\t\t\tkeys.splice(keys.indexOf('alpha'), 1);\n\t\t\tthis.valpha = typeof object.alpha === 'number' ? object.alpha : 0;\n\t\t}\n\n\t\tconst hashedKeys = keys.sort().join('');\n\t\tif (!(hashedKeys in hashedModelKeys)) {\n\t\t\tthrow new Error('Unable to parse color from object: ' + JSON.stringify(object));\n\t\t}\n\n\t\tthis.model = hashedModelKeys[hashedKeys];\n\n\t\tconst {labels} = convert[this.model];\n\t\tconst color = [];\n\t\tfor (i = 0; i < labels.length; i++) {\n\t\t\tcolor.push(object[labels[i]]);\n\t\t}\n\n\t\tthis.color = zeroArray(color);\n\t}\n\n\t// Perform limitations (clamping, etc.)\n\tif (limiters[this.model]) {\n\t\tchannels = convert[this.model].channels;\n\t\tfor (i = 0; i < channels; i++) {\n\t\t\tconst limit = limiters[this.model][i];\n\t\t\tif (limit) {\n\t\t\t\tthis.color[i] = limit(this.color[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.valpha = Math.max(0, Math.min(1, this.valpha));\n\n\tif (Object.freeze) {\n\t\tObject.freeze(this);\n\t}\n}\n\nColor.prototype = {\n\ttoString() {\n\t\treturn this.string();\n\t},\n\n\ttoJSON() {\n\t\treturn this[this.model]();\n\t},\n\n\tstring(places) {\n\t\tlet self = this.model in colorString.to ? this : this.rgb();\n\t\tself = self.round(typeof places === 'number' ? places : 1);\n\t\tconst args = self.valpha === 1 ? self.color : [...self.color, this.valpha];\n\t\treturn colorString.to[self.model](args);\n\t},\n\n\tpercentString(places) {\n\t\tconst self = this.rgb().round(typeof places === 'number' ? places : 1);\n\t\tconst args = self.valpha === 1 ? self.color : [...self.color, this.valpha];\n\t\treturn colorString.to.rgb.percent(args);\n\t},\n\n\tarray() {\n\t\treturn this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];\n\t},\n\n\tobject() {\n\t\tconst result = {};\n\t\tconst {channels} = convert[this.model];\n\t\tconst {labels} = convert[this.model];\n\n\t\tfor (let i = 0; i < channels; i++) {\n\t\t\tresult[labels[i]] = this.color[i];\n\t\t}\n\n\t\tif (this.valpha !== 1) {\n\t\t\tresult.alpha = this.valpha;\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tunitArray() {\n\t\tconst rgb = this.rgb().color;\n\t\trgb[0] /= 255;\n\t\trgb[1] /= 255;\n\t\trgb[2] /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.push(this.valpha);\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tunitObject() {\n\t\tconst rgb = this.rgb().object();\n\t\trgb.r /= 255;\n\t\trgb.g /= 255;\n\t\trgb.b /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.alpha = this.valpha;\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tround(places) {\n\t\tplaces = Math.max(places || 0, 0);\n\t\treturn new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);\n\t},\n\n\talpha(value) {\n\t\tif (value !== undefined) {\n\t\t\treturn new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);\n\t\t}\n\n\t\treturn this.valpha;\n\t},\n\n\t// Rgb\n\tred: getset('rgb', 0, maxfn(255)),\n\tgreen: getset('rgb', 1, maxfn(255)),\n\tblue: getset('rgb', 2, maxfn(255)),\n\n\thue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, value => ((value % 360) + 360) % 360),\n\n\tsaturationl: getset('hsl', 1, maxfn(100)),\n\tlightness: getset('hsl', 2, maxfn(100)),\n\n\tsaturationv: getset('hsv', 1, maxfn(100)),\n\tvalue: getset('hsv', 2, maxfn(100)),\n\n\tchroma: getset('hcg', 1, maxfn(100)),\n\tgray: getset('hcg', 2, maxfn(100)),\n\n\twhite: getset('hwb', 1, maxfn(100)),\n\twblack: getset('hwb', 2, maxfn(100)),\n\n\tcyan: getset('cmyk', 0, maxfn(100)),\n\tmagenta: getset('cmyk', 1, maxfn(100)),\n\tyellow: getset('cmyk', 2, maxfn(100)),\n\tblack: getset('cmyk', 3, maxfn(100)),\n\n\tx: getset('xyz', 0, maxfn(95.047)),\n\ty: getset('xyz', 1, maxfn(100)),\n\tz: getset('xyz', 2, maxfn(108.833)),\n\n\tl: getset('lab', 0, maxfn(100)),\n\ta: getset('lab', 1),\n\tb: getset('lab', 2),\n\n\tkeyword(value) {\n\t\tif (value !== undefined) {\n\t\t\treturn new Color(value);\n\t\t}\n\n\t\treturn convert[this.model].keyword(this.color);\n\t},\n\n\thex(value) {\n\t\tif (value !== undefined) {\n\t\t\treturn new Color(value);\n\t\t}\n\n\t\treturn colorString.to.hex(this.rgb().round().color);\n\t},\n\n\thexa(value) {\n\t\tif (value !== undefined) {\n\t\t\treturn new Color(value);\n\t\t}\n\n\t\tconst rgbArray = this.rgb().round().color;\n\n\t\tlet alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();\n\t\tif (alphaHex.length === 1) {\n\t\t\talphaHex = '0' + alphaHex;\n\t\t}\n\n\t\treturn colorString.to.hex(rgbArray) + alphaHex;\n\t},\n\n\trgbNumber() {\n\t\tconst rgb = this.rgb().color;\n\t\treturn ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);\n\t},\n\n\tluminosity() {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tconst rgb = this.rgb().color;\n\n\t\tconst lum = [];\n\t\tfor (const [i, element] of rgb.entries()) {\n\t\t\tconst chan = element / 255;\n\t\t\tlum[i] = (chan <= 0.04045) ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;\n\t\t}\n\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast(color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tconst lum1 = this.luminosity();\n\t\tconst lum2 = color2.luminosity();\n\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel(color2) {\n\t\t// https://www.w3.org/TR/WCAG/#contrast-enhanced\n\t\tconst contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tisDark() {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tconst rgb = this.rgb().color;\n\t\tconst yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 10000;\n\t\treturn yiq < 128;\n\t},\n\n\tisLight() {\n\t\treturn !this.isDark();\n\t},\n\n\tnegate() {\n\t\tconst rgb = this.rgb();\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\trgb.color[i] = 255 - rgb.color[i];\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tlighten(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[2] += hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdarken(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[2] -= hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tsaturate(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[1] += hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdesaturate(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[1] -= hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\twhiten(ratio) {\n\t\tconst hwb = this.hwb();\n\t\thwb.color[1] += hwb.color[1] * ratio;\n\t\treturn hwb;\n\t},\n\n\tblacken(ratio) {\n\t\tconst hwb = this.hwb();\n\t\thwb.color[2] += hwb.color[2] * ratio;\n\t\treturn hwb;\n\t},\n\n\tgrayscale() {\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tconst rgb = this.rgb().color;\n\t\tconst value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\treturn Color.rgb(value, value, value);\n\t},\n\n\tfade(ratio) {\n\t\treturn this.alpha(this.valpha - (this.valpha * ratio));\n\t},\n\n\topaquer(ratio) {\n\t\treturn this.alpha(this.valpha + (this.valpha * ratio));\n\t},\n\n\trotate(degrees) {\n\t\tconst hsl = this.hsl();\n\t\tlet hue = hsl.color[0];\n\t\thue = (hue + degrees) % 360;\n\t\thue = hue < 0 ? 360 + hue : hue;\n\t\thsl.color[0] = hue;\n\t\treturn hsl;\n\t},\n\n\tmix(mixinColor, weight) {\n\t\t// Ported from sass implementation in C\n\t\t// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t\tif (!mixinColor || !mixinColor.rgb) {\n\t\t\tthrow new Error('Argument to \"mix\" was not a Color instance, but rather an instance of ' + typeof mixinColor);\n\t\t}\n\n\t\tconst color1 = mixinColor.rgb();\n\t\tconst color2 = this.rgb();\n\t\tconst p = weight === undefined ? 0.5 : weight;\n\n\t\tconst w = 2 * p - 1;\n\t\tconst a = color1.alpha() - color2.alpha();\n\n\t\tconst w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2;\n\t\tconst w2 = 1 - w1;\n\n\t\treturn Color.rgb(\n\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\tw1 * color1.blue() + w2 * color2.blue(),\n\t\t\tcolor1.alpha() * p + color2.alpha() * (1 - p));\n\t},\n};\n\n// Model conversion methods and static constructors\nfor (const model of Object.keys(convert)) {\n\tif (skippedModels.includes(model)) {\n\t\tcontinue;\n\t}\n\n\tconst {channels} = convert[model];\n\n\t// Conversion methods\n\tColor.prototype[model] = function (...args) {\n\t\tif (this.model === model) {\n\t\t\treturn new Color(this);\n\t\t}\n\n\t\tif (args.length > 0) {\n\t\t\treturn new Color(args, model);\n\t\t}\n\n\t\treturn new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);\n\t};\n\n\t// 'static' construction methods\n\tColor[model] = function (...args) {\n\t\tlet color = args[0];\n\t\tif (typeof color === 'number') {\n\t\t\tcolor = zeroArray(args, channels);\n\t\t}\n\n\t\treturn new Color(color, model);\n\t};\n}\n\nfunction roundTo(number, places) {\n\treturn Number(number.toFixed(places));\n}\n\nfunction roundToPlace(places) {\n\treturn function (number) {\n\t\treturn roundTo(number, places);\n\t};\n}\n\nfunction getset(model, channel, modifier) {\n\tmodel = Array.isArray(model) ? model : [model];\n\n\tfor (const m of model) {\n\t\t(limiters[m] || (limiters[m] = []))[channel] = modifier;\n\t}\n\n\tmodel = model[0];\n\n\treturn function (value) {\n\t\tlet result;\n\n\t\tif (value !== undefined) {\n\t\t\tif (modifier) {\n\t\t\t\tvalue = modifier(value);\n\t\t\t}\n\n\t\t\tresult = this[model]();\n\t\t\tresult.color[channel] = value;\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = this[model]().color[channel];\n\t\tif (modifier) {\n\t\t\tresult = modifier(result);\n\t\t}\n\n\t\treturn result;\n\t};\n}\n\nfunction maxfn(max) {\n\treturn function (v) {\n\t\treturn Math.max(0, Math.min(max, v));\n\t};\n}\n\nfunction assertArray(value) {\n\treturn Array.isArray(value) ? value : [value];\n}\n\nfunction zeroArray(array, length) {\n\tfor (let i = 0; i < length; i++) {\n\t\tif (typeof array[i] !== 'number') {\n\t\t\tarray[i] = 0;\n\t\t}\n\t}\n\n\treturn array;\n}\n\nmodule.exports = Color;\n\n\n//# sourceURL=webpack:///./node_modules/color/index.js?");

/***/ }),

/***/ "./node_modules/extend/index.js":
/*!**************************************!*\
  !*** ./node_modules/extend/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n//# sourceURL=webpack:///./node_modules/extend/index.js?");

/***/ }),

/***/ "./node_modules/is-arrayish/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-arrayish/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function isArrayish(obj) {\n\tif (!obj) {\n\t\treturn false;\n\t}\n\n\treturn obj instanceof Array || Array.isArray(obj) ||\n\t\t(obj.length >= 0 && obj.splice instanceof Function);\n};\n\n\n//# sourceURL=webpack:///./node_modules/is-arrayish/index.js?");

/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n\n//# sourceURL=webpack:///./node_modules/is-buffer/index.js?");

/***/ }),

/***/ "./node_modules/is-plain-obj/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-plain-obj/index.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return isPlainObject; });\nfunction isPlainObject(value) {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n}\n\n\n//# sourceURL=webpack:///./node_modules/is-plain-obj/index.js?");

/***/ }),

/***/ "./node_modules/simple-swizzle/index.js":
/*!**********************************************!*\
  !*** ./node_modules/simple-swizzle/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isArrayish = __webpack_require__(/*! is-arrayish */ \"./node_modules/is-arrayish/index.js\");\n\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\n\nvar swizzle = module.exports = function swizzle(args) {\n\tvar results = [];\n\n\tfor (var i = 0, len = args.length; i < len; i++) {\n\t\tvar arg = args[i];\n\n\t\tif (isArrayish(arg)) {\n\t\t\t// http://jsperf.com/javascript-array-concat-vs-push/98\n\t\t\tresults = concat.call(results, slice.call(arg));\n\t\t} else {\n\t\t\tresults.push(arg);\n\t\t}\n\t}\n\n\treturn results;\n};\n\nswizzle.wrap = function (fn) {\n\treturn function () {\n\t\treturn fn(swizzle(arguments));\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/simple-swizzle/index.js?");

/***/ }),

/***/ "./node_modules/trough/index.js":
/*!**************************************!*\
  !*** ./node_modules/trough/index.js ***!
  \**************************************/
/*! exports provided: trough, wrap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trough\", function() { return trough; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wrap\", function() { return wrap; });\n/**\n * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback\n * @typedef {(...input: Array<any>) => any} Middleware\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add `fn` (middleware) to the list.\n * @typedef {{run: Run, use: Use}} Pipeline\n *   Middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n */\nfunction trough() {\n  /** @type {Array<Middleware>} */\n  const fns = []\n  /** @type {Pipeline} */\n  const pipeline = {run, use}\n\n  return pipeline\n\n  /** @type {Run} */\n  function run(...values) {\n    let middlewareIndex = -1\n    /** @type {Callback} */\n    const callback = values.pop()\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback)\n    }\n\n    next(null, ...values)\n\n    /**\n     * Run the next `fn`, or we’re done.\n     *\n     * @param {Error|null|undefined} error\n     * @param {Array<any>} output\n     */\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex]\n      let index = -1\n\n      if (error) {\n        callback(error)\n        return\n      }\n\n      // Copy non-nullish input into values.\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index]\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output)\n      } else {\n        callback(null, ...output)\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError(\n        'Expected `middelware` to be a function, not ' + middelware\n      )\n    }\n\n    fns.push(middelware)\n    return pipeline\n  }\n}\n\n/**\n * Wrap `middleware`.\n * Can be sync or async; return a promise, receive a callback, or return new\n * values and errors.\n *\n * @param {Middleware} middleware\n * @param {Callback} callback\n */\nfunction wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called\n\n  return wrapped\n\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length\n    /** @type {any} */\n    let result\n\n    if (fnExpectsCallback) {\n      parameters.push(done)\n    }\n\n    try {\n      result = middleware.apply(this, parameters)\n    } catch (error) {\n      const exception = /** @type {Error} */ (error)\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception\n      }\n\n      return done(exception)\n    }\n\n    if (!fnExpectsCallback) {\n      if (result instanceof Promise) {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /**\n   * Call `callback`, only once.\n   * @type {Callback}\n   */\n  function done(error, ...output) {\n    if (!called) {\n      called = true\n      callback(error, ...output)\n    }\n  }\n\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n  function then(value) {\n    done(null, value)\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/trough/index.js?");

/***/ }),

/***/ "./node_modules/unified/index.js":
/*!***************************************!*\
  !*** ./node_modules/unified/index.js ***!
  \***************************************/
/*! exports provided: unified */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/index.js */ \"./node_modules/unified/lib/index.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"unified\", function() { return _lib_index_js__WEBPACK_IMPORTED_MODULE_0__[\"unified\"]; });\n\n\n\n\n//# sourceURL=webpack:///./node_modules/unified/index.js?");

/***/ }),

/***/ "./node_modules/unified/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/unified/lib/index.js ***!
  \*******************************************/
/*! exports provided: unified */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unified\", function() { return unified; });\n/* harmony import */ var bail__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bail */ \"./node_modules/bail/index.js\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(is_buffer__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var extend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\");\n/* harmony import */ var extend__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(extend__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var is_plain_obj__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! is-plain-obj */ \"./node_modules/is-plain-obj/index.js\");\n/* harmony import */ var trough__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! trough */ \"./node_modules/trough/index.js\");\n/* harmony import */ var vfile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vfile */ \"./node_modules/vfile/index.js\");\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */\n\n\n\n\n\n\n\n\n// Expose a frozen processor.\nconst unified = base().freeze()\n\nconst own = {}.hasOwnProperty\n\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */\nfunction base() {\n  const transformers = Object(trough__WEBPACK_IMPORTED_MODULE_4__[\"trough\"])()\n  /** @type {Processor['attachers']} */\n  const attachers = []\n  /** @type {Record<string, unknown>} */\n  let namespace = {}\n  /** @type {boolean|undefined} */\n  let frozen\n  let freezeIndex = -1\n\n  // Data management.\n  // @ts-expect-error: overloads are handled.\n  processor.data = data\n  processor.Parser = undefined\n  processor.Compiler = undefined\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  // @ts-expect-error: overloads are handled.\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  // @ts-expect-error: overloads are handled.\n  processor.run = run\n  processor.runSync = runSync\n  // @ts-expect-error: overloads are handled.\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  /** @type {Processor} */\n  function processor() {\n    const destination = base()\n    let index = -1\n\n    while (++index < attachers.length) {\n      destination.use(...attachers[index])\n    }\n\n    destination.data(extend__WEBPACK_IMPORTED_MODULE_2___default()(true, {}, namespace))\n\n    return destination\n  }\n\n  /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n        namespace[key] = value\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  /** @type {Processor['freeze']} */\n  function freeze() {\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      const [attacher, ...options] = attachers[freezeIndex]\n\n      if (options[0] === false) {\n        continue\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined\n      }\n\n      /** @type {Transformer|void} */\n      const transformer = attacher.call(processor, ...options)\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Number.POSITIVE_INFINITY\n\n    return processor\n  }\n\n  /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */\n  function use(value, ...options) {\n    /** @type {Record<string, unknown>|undefined} */\n    let settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, ...options)\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...options] = value\n          addPlugin(plugin, ...options)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    /**\n     * @param {Preset} result\n     * @returns {void}\n     */\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings)\n      }\n    }\n\n    /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */\n    function addList(plugins) {\n      let index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index]\n          add(thing)\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */\n    function addPlugin(plugin, value) {\n      let index = -1\n      /** @type {Processor['attachers'][number]|undefined} */\n      let entry\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index]\n          break\n        }\n      }\n\n      if (entry) {\n        if (Object(is_plain_obj__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(entry[1]) && Object(is_plain_obj__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(value)) {\n          value = extend__WEBPACK_IMPORTED_MODULE_2___default()(true, entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push([...arguments])\n      }\n    }\n  }\n\n  /** @type {Processor['parse']} */\n  function parse(doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  /** @type {Processor['stringify']} */\n  function stringify(node, doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */\n  function run(node, doc, callback) {\n    assertNode(node)\n    processor.freeze()\n\n    if (!callback && typeof doc === 'function') {\n      callback = doc\n      doc = undefined\n    }\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` can’t be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done)\n\n      /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */\n      function done(error, tree, file) {\n        tree = tree || node\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['runSync']} */\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    let result\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    // @ts-expect-error: we either bailed on an error or have a tree.\n    return result\n\n    /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */\n    function done(error, tree) {\n      Object(bail__WEBPACK_IMPORTED_MODULE_0__[\"bail\"])(error)\n      result = tree\n      complete = true\n    }\n  }\n\n  /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */\n  function process(doc, callback) {\n    processor.freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      const file = vfile(doc)\n\n      processor.run(processor.parse(file), file, (error, tree, file) => {\n        if (error || !tree || !file) {\n          done(error)\n        } else {\n          /** @type {unknown} */\n          const result = processor.stringify(tree, file)\n\n          if (result === undefined || result === null) {\n            // Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result\n          } else {\n            file.result = result\n          }\n\n          done(error, file)\n        }\n      })\n\n      /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */\n      function done(error, file) {\n        if (error || !file) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['processSync']} */\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n\n    const file = vfile(doc)\n\n    processor.process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */\n    function done(error) {\n      complete = true\n      Object(bail__WEBPACK_IMPORTED_MODULE_0__[\"bail\"])(error)\n    }\n  }\n}\n\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes’ prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */\nfunction keys(value) {\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot call `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!Object(is_plain_obj__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`')\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new vfile__WEBPACK_IMPORTED_MODULE_5__[\"VFile\"](value)\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || is_buffer__WEBPACK_IMPORTED_MODULE_1___default()(value)\n}\n\n\n//# sourceURL=webpack:///./node_modules/unified/lib/index.js?");

/***/ }),

/***/ "./node_modules/unist-util-stringify-position/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/unist-util-stringify-position/index.js ***!
  \*************************************************************/
/*! exports provided: stringifyPosition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringifyPosition\", function() { return stringifyPosition; });\n/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {object & {type: string, position?: Position|undefined}} NodeLike\n */\n\n/**\n * Stringify one point, a position (start and end points), or a node’s\n * positional information.\n *\n * @param {Node|NodeLike|Position|Point|null} [value]\n * @returns {string}\n */\nfunction stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point|undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position|undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number|undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n\n\n//# sourceURL=webpack:///./node_modules/unist-util-stringify-position/index.js?");

/***/ }),

/***/ "./node_modules/vfile-message/index.js":
/*!*********************************************!*\
  !*** ./node_modules/vfile-message/index.js ***!
  \*********************************************/
/*! exports provided: VFileMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VFileMessage\", function() { return VFileMessage; });\n/* harmony import */ var unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-stringify-position */ \"./node_modules/unist-util-stringify-position/index.js\");\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {object & {type: string, position?: Position|undefined}} NodeLike\n */\n\n\n\nclass VFileMessage extends Error {\n  /**\n   * Constructor of a message for `reason` at `place` from `origin`.\n   * When an error is passed in as `reason`, copies the `stack`.\n   *\n   * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).\n   * @param {string} [origin] Place in code the message originates from (`string`, optional).\n   */\n  constructor(reason, place, origin) {\n    /** @type {[string|null, string|null]} */\n    const parts = [null, null]\n    /** @type {Position} */\n    let position = {\n      // @ts-expect-error: we always follows the structure of `position`.\n      start: {line: null, column: null},\n      // @ts-expect-error: \"\n      end: {line: null, column: null}\n    }\n\n    super()\n\n    if (typeof place === 'string') {\n      origin = place\n      place = undefined\n    }\n\n    if (typeof origin === 'string') {\n      const index = origin.indexOf(':')\n\n      if (index === -1) {\n        parts[1] = origin\n      } else {\n        parts[0] = origin.slice(0, index)\n        parts[1] = origin.slice(index + 1)\n      }\n    }\n\n    if (place) {\n      // Node.\n      if ('type' in place || 'position' in place) {\n        if (place.position) {\n          position = place.position\n        }\n      }\n      // Position.\n      else if ('start' in place || 'end' in place) {\n        position = place\n      }\n      // Point.\n      else if ('line' in place || 'column' in place) {\n        position.start = place\n      }\n    }\n\n    // Fields from `Error`\n    this.name = Object(unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_0__[\"stringifyPosition\"])(place) || '1:1'\n    this.message = typeof reason === 'object' ? reason.message : reason\n    this.stack = typeof reason === 'object' ? reason.stack : ''\n\n    /**\n     * Reason for message.\n     * @type {string}\n     */\n    this.reason = this.message\n    /**\n     * If true, marks associated file as no longer processable.\n     * @type {boolean?}\n     */\n    // eslint-disable-next-line no-unused-expressions\n    this.fatal\n    /**\n     * Starting line of error.\n     * @type {number?}\n     */\n    this.line = position.start.line\n    /**\n     * Starting column of error.\n     * @type {number?}\n     */\n    this.column = position.start.column\n    /**\n     * Namespace of warning.\n     * @type {string?}\n     */\n    this.source = parts[0]\n    /**\n     * Category of message.\n     * @type {string?}\n     */\n    this.ruleId = parts[1]\n    /**\n     * Full range information, when available.\n     * Has start and end properties, both set to an object with line and column, set to number?.\n     * @type {Position?}\n     */\n    this.position = position\n\n    // The following fields are “well known”.\n    // Not standard.\n    // Feel free to add other non-standard fields to your messages.\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * You can use this to specify the source value that’s being reported, which\n     * is deemed incorrect.\n     * @type {string?}\n     */\n    this.actual\n    /**\n     * You can use this to suggest values that should be used instead of\n     * `actual`, one or more values that are deemed as acceptable.\n     * @type {Array<string>?}\n     */\n    this.expected\n    /**\n     * You may add a file property with a path of a file (used throughout the VFile ecosystem).\n     * @type {string?}\n     */\n    this.file\n    /**\n     * You may add a url property with a link to documentation for the message.\n     * @type {string?}\n     */\n    this.url\n    /**\n     * You may add a note property with a long form description of the message (supported by vfile-reporter).\n     * @type {string?}\n     */\n    this.note\n    /* eslint-enable no-unused-expressions */\n  }\n}\n\nVFileMessage.prototype.file = ''\nVFileMessage.prototype.name = ''\nVFileMessage.prototype.reason = ''\nVFileMessage.prototype.message = ''\nVFileMessage.prototype.stack = ''\nVFileMessage.prototype.fatal = null\nVFileMessage.prototype.column = null\nVFileMessage.prototype.line = null\nVFileMessage.prototype.source = null\nVFileMessage.prototype.ruleId = null\nVFileMessage.prototype.position = null\n\n\n//# sourceURL=webpack:///./node_modules/vfile-message/index.js?");

/***/ }),

/***/ "./node_modules/vfile/index.js":
/*!*************************************!*\
  !*** ./node_modules/vfile/index.js ***!
  \*************************************/
/*! exports provided: VFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/index.js */ \"./node_modules/vfile/lib/index.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VFile\", function() { return _lib_index_js__WEBPACK_IMPORTED_MODULE_0__[\"VFile\"]; });\n\n\n\n\n//# sourceURL=webpack:///./node_modules/vfile/index.js?");

/***/ }),

/***/ "./node_modules/vfile/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/vfile/lib/index.js ***!
  \*****************************************/
/*! exports provided: VFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VFile\", function() { return VFile; });\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(is_buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vfile-message */ \"./node_modules/vfile-message/index.js\");\n/* harmony import */ var _minpath_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./minpath.js */ \"./node_modules/vfile/lib/minpath.browser.js\");\n/* harmony import */ var _minproc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./minproc.js */ \"./node_modules/vfile/lib/minproc.browser.js\");\n/* harmony import */ var _minurl_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./minurl.js */ \"./node_modules/vfile/lib/minurl.browser.js\");\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {Record<string, unknown> & {type: string, position?: Position|undefined}} NodeLike\n * @typedef {import('./minurl.shared.js').URL} URL\n * @typedef {import('..').VFileData} VFileData\n * @typedef {import('..').VFileValue} VFileValue\n *\n * @typedef {'ascii'|'utf8'|'utf-8'|'utf16le'|'ucs2'|'ucs-2'|'base64'|'base64url'|'latin1'|'binary'|'hex'} BufferEncoding\n *   Encodings supported by the buffer class.\n *   This is a copy of the typing from Node, copied to prevent Node globals from\n *   being needed.\n *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>\n *\n * @typedef {VFileValue|VFileOptions|VFile|URL} VFileCompatible\n *   Things that can be passed to the constructor.\n *\n * @typedef VFileCoreOptions\n * @property {VFileValue} [value]\n * @property {string} [cwd]\n * @property {Array<string>} [history]\n * @property {string|URL} [path]\n * @property {string} [basename]\n * @property {string} [stem]\n * @property {string} [extname]\n * @property {string} [dirname]\n * @property {VFileData} [data]\n *\n * @typedef Map\n *   Raw source map, see:\n *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.\n * @property {number} version\n * @property {Array<string>} sources\n * @property {Array<string>} names\n * @property {string|undefined} [sourceRoot]\n * @property {Array<string>|undefined} [sourcesContent]\n * @property {string} mappings\n * @property {string} file\n *\n * @typedef {{[key: string]: unknown} & VFileCoreOptions} VFileOptions\n *   Configuration: a bunch of keys that will be shallow copied over to the new\n *   file.\n *\n * @typedef {Record<string, unknown>} VFileReporterSettings\n * @typedef {<T = VFileReporterSettings>(files: Array<VFile>, options: T) => string} VFileReporter\n */\n\n\n\n\n\n\n\n// Order of setting (least specific to most), we need this because otherwise\n// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n// stem can be set.\nconst order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nclass VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * If `options` is `string` or `Buffer`, treats it as `{value: options}`.\n   * If `options` is a `VFile`, shallow copies its data over to the new file.\n   * All other given fields are set on the newly created `VFile`.\n   *\n   * Path related properties are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * It’s not possible to set either `dirname` or `extname` without setting\n   * either `history`, `path`, `basename`, or `stem` as well.\n   *\n   * @param {VFileCompatible} [value]\n   */\n  constructor(value) {\n    /** @type {VFileOptions} */\n    let options\n\n    if (!value) {\n      options = {}\n    } else if (typeof value === 'string' || is_buffer__WEBPACK_IMPORTED_MODULE_0___default()(value)) {\n      // @ts-expect-error Looks like a buffer.\n      options = {value}\n    } else if (Object(_minurl_js__WEBPACK_IMPORTED_MODULE_4__[\"isUrl\"])(value)) {\n      options = {path: value}\n    } else {\n      // @ts-expect-error Looks like file or options.\n      options = value\n    }\n\n    /**\n     * Place to store custom information.\n     * It’s OK to store custom data directly on the file, moving it to `data`\n     * gives a little more privacy.\n     * @type {VFileData}\n     */\n    this.data = {}\n\n    /**\n     * List of messages associated with the file.\n     * @type {Array<VFileMessage>}\n     */\n    this.messages = []\n\n    /**\n     * List of file paths the file moved between.\n     * @type {Array<string>}\n     */\n    this.history = []\n\n    /**\n     * Base of `path`.\n     * Defaults to `process.cwd()` (`/` in browsers).\n     * @type {string}\n     */\n    this.cwd = _minproc_js__WEBPACK_IMPORTED_MODULE_3__[\"proc\"].cwd()\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Raw value.\n     * @type {VFileValue}\n     */\n    this.value\n\n    // The below are non-standard, they are “well-known”.\n    // As in, used in several tools.\n\n    /**\n     * Whether a file was saved to disk.\n     * This is used by vfile reporters.\n     * @type {boolean}\n     */\n    this.stored\n\n    /**\n     * Sometimes files have a non-string representation.\n     * This can be stored in the `result` field.\n     * One example is when turning markdown into React nodes.\n     * This is used by unified to store non-string results.\n     * @type {unknown}\n     */\n    this.result\n\n    /**\n     * Sometimes files have a source map associated with them.\n     * This can be stored in the `map` field.\n     * This should be a `RawSourceMap` type from the `source-map` module.\n     * @type {Map|undefined}\n     */\n    this.map\n    /* eslint-enable no-unused-expressions */\n\n    // Set path related properties in the correct order.\n    let index = -1\n\n    while (++index < order.length) {\n      const prop = order[index]\n\n      // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n      if (prop in options && options[prop] !== undefined) {\n        // @ts-expect-error: TS is confused by the different types for `history`.\n        this[prop] = prop === 'history' ? [...options[prop]] : options[prop]\n      }\n    }\n\n    /** @type {string} */\n    let prop\n\n    // Set non-path related properties.\n    for (prop in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(prop)) this[prop] = options[prop]\n    }\n  }\n\n  /**\n   * Access full path (`~/index.min.js`).\n   *\n   * @returns {string}\n   */\n  get path() {\n    return this.history[this.history.length - 1]\n  }\n\n  /**\n   * Set full path (`~/index.min.js`).\n   * Cannot be nullified.\n   *\n   * @param {string|URL} path\n   */\n  set path(path) {\n    if (Object(_minurl_js__WEBPACK_IMPORTED_MODULE_4__[\"isUrl\"])(path)) {\n      path = Object(_minurl_js__WEBPACK_IMPORTED_MODULE_4__[\"urlToPath\"])(path)\n    }\n\n    assertNonEmpty(path, 'path')\n\n    if (this.path !== path) {\n      this.history.push(path)\n    }\n  }\n\n  /**\n   * Access parent path (`~`).\n   */\n  get dirname() {\n    return typeof this.path === 'string' ? _minpath_js__WEBPACK_IMPORTED_MODULE_2__[\"path\"].dirname(this.path) : undefined\n  }\n\n  /**\n   * Set parent path (`~`).\n   * Cannot be set if there's no `path` yet.\n   */\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname')\n    this.path = _minpath_js__WEBPACK_IMPORTED_MODULE_2__[\"path\"].join(dirname || '', this.basename)\n  }\n\n  /**\n   * Access basename (including extname) (`index.min.js`).\n   */\n  get basename() {\n    return typeof this.path === 'string' ? _minpath_js__WEBPACK_IMPORTED_MODULE_2__[\"path\"].basename(this.path) : undefined\n  }\n\n  /**\n   * Set basename (`index.min.js`).\n   * Cannot contain path separators.\n   * Cannot be nullified either (use `file.path = file.dirname` instead).\n   */\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename')\n    assertPart(basename, 'basename')\n    this.path = _minpath_js__WEBPACK_IMPORTED_MODULE_2__[\"path\"].join(this.dirname || '', basename)\n  }\n\n  /**\n   * Access extname (including dot) (`.js`).\n   */\n  get extname() {\n    return typeof this.path === 'string' ? _minpath_js__WEBPACK_IMPORTED_MODULE_2__[\"path\"].extname(this.path) : undefined\n  }\n\n  /**\n   * Set extname (including dot) (`.js`).\n   * Cannot be set if there's no `path` yet and cannot contain path separators.\n   */\n  set extname(extname) {\n    assertPart(extname, 'extname')\n    assertPath(this.dirname, 'extname')\n\n    if (extname) {\n      if (extname.charCodeAt(0) !== 46 /* `.` */) {\n        throw new Error('`extname` must start with `.`')\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots')\n      }\n    }\n\n    this.path = _minpath_js__WEBPACK_IMPORTED_MODULE_2__[\"path\"].join(this.dirname, this.stem + (extname || ''))\n  }\n\n  /**\n   * Access stem (w/o extname) (`index.min`).\n   */\n  get stem() {\n    return typeof this.path === 'string'\n      ? _minpath_js__WEBPACK_IMPORTED_MODULE_2__[\"path\"].basename(this.path, this.extname)\n      : undefined\n  }\n\n  /**\n   * Set stem (w/o extname) (`index.min`).\n   * Cannot be nullified, and cannot contain path separators.\n   */\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem')\n    assertPart(stem, 'stem')\n    this.path = _minpath_js__WEBPACK_IMPORTED_MODULE_2__[\"path\"].join(this.dirname || '', stem + (this.extname || ''))\n  }\n\n  /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding} [encoding='utf8'] If `file.value` is a buffer, `encoding` is used to serialize buffers.\n   * @returns {string}\n   */\n  toString(encoding) {\n    return (this.value || '').toString(encoding)\n  }\n\n  /**\n   * Create a message and associates it w/ the file.\n   *\n   * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).\n   * @param {string} [origin] Place in code the message originates from (`string`, optional).\n   * @returns {VFileMessage}\n   */\n  message(reason, place, origin) {\n    const message = new vfile_message__WEBPACK_IMPORTED_MODULE_1__[\"VFileMessage\"](reason, place, origin)\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name\n      message.file = this.path\n    }\n\n    message.fatal = false\n\n    this.messages.push(message)\n\n    return message\n  }\n\n  /**\n   * Info: create a message, associate it with the file, and mark the fatality\n   * as `null`.\n   * Calls `message()` internally.\n   *\n   * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).\n   * @param {string} [origin] Place in code the message originates from (`string`, optional).\n   * @returns {VFileMessage}\n   */\n  info(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = null\n\n    return message\n  }\n\n  /**\n   * Fail: create a message, associate it with the file, mark the fatality as\n   * `true`.\n   * Note: fatal errors mean a file is no longer processable.\n   * Calls `message()` internally.\n   *\n   * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).\n   * @param {string} [origin] Place in code the message originates from (`string`, optional).\n   * @returns {never}\n   */\n  fail(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = true\n\n    throw message\n  }\n}\n\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string|undefined} part\n * @param {string} name\n * @returns {void}\n */\nfunction assertPart(part, name) {\n  if (part && part.includes(_minpath_js__WEBPACK_IMPORTED_MODULE_2__[\"path\"].sep)) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + _minpath_js__WEBPACK_IMPORTED_MODULE_2__[\"path\"].sep + '`'\n    )\n  }\n}\n\n/**\n * Assert that `part` is not empty.\n *\n * @param {string|undefined} part\n * @param {string} name\n * @returns {asserts part is string}\n */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n/**\n * Assert `path` exists.\n *\n * @param {string|undefined} path\n * @param {string} name\n * @returns {asserts path is string}\n */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/vfile/lib/index.js?");

/***/ }),

/***/ "./node_modules/vfile/lib/minpath.browser.js":
/*!***************************************************!*\
  !*** ./node_modules/vfile/lib/minpath.browser.js ***!
  \***************************************************/
/*! exports provided: path */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"path\", function() { return path; });\n// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node’s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst path = {basename, dirname, extname, join, sep: '/'}\n\n/* eslint-disable max-depth, complexity */\n\n/**\n * @param {string} path\n * @param {string} [ext]\n * @returns {string}\n */\nfunction basename(path, ext) {\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  let start = 0\n  let end = -1\n  let index = path.length\n  /** @type {boolean|undefined} */\n  let seenNonSlash\n\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  let firstNonSlashEnd = -1\n  let extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\n/**\n * @param {string} path\n * @returns {string}\n */\nfunction dirname(path) {\n  assertPath(path)\n\n  if (path.length === 0) {\n    return '.'\n  }\n\n  let end = -1\n  let index = path.length\n  /** @type {boolean|undefined} */\n  let unmatchedSlash\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.charCodeAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.charCodeAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\n/**\n * @param {string} path\n * @returns {string}\n */\nfunction extname(path) {\n  assertPath(path)\n\n  let index = path.length\n\n  let end = -1\n  let startPart = 0\n  let startDot = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  let preDotState = 0\n  /** @type {boolean|undefined} */\n  let unmatchedSlash\n\n  while (index--) {\n    const code = path.charCodeAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\n/**\n * @param {Array<string>} segments\n * @returns {string}\n */\nfunction join(...segments) {\n  let index = -1\n  /** @type {string|undefined} */\n  let joined\n\n  while (++index < segments.length) {\n    assertPath(segments[index])\n\n    if (segments[index]) {\n      joined =\n        joined === undefined ? segments[index] : joined + '/' + segments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n/**\n * Note: `normalize` is not exposed as `path.normalize`, so some code is\n * manually removed from it.\n *\n * @param {string} path\n * @returns {string}\n */\nfunction normalize(path) {\n  assertPath(path)\n\n  const absolute = path.charCodeAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  let value = normalizeString(path, !absolute)\n\n  if (value.length === 0 && !absolute) {\n    value = '.'\n  }\n\n  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n * @param {boolean} allowAboveRoot\n * @returns {string}\n */\nfunction normalizeString(path, allowAboveRoot) {\n  let result = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let index = -1\n  /** @type {number|undefined} */\n  let code\n  /** @type {number} */\n  let lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||\n          result.charCodeAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length > 0) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {string} path\n */\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n\n/* eslint-enable max-depth, complexity */\n\n\n//# sourceURL=webpack:///./node_modules/vfile/lib/minpath.browser.js?");

/***/ }),

/***/ "./node_modules/vfile/lib/minproc.browser.js":
/*!***************************************************!*\
  !*** ./node_modules/vfile/lib/minproc.browser.js ***!
  \***************************************************/
/*! exports provided: proc */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"proc\", function() { return proc; });\n// Somewhat based on:\n// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.\n// But I don’t think one tiny line of code can be copyrighted. 😅\nconst proc = {cwd}\n\nfunction cwd() {\n  return '/'\n}\n\n\n//# sourceURL=webpack:///./node_modules/vfile/lib/minproc.browser.js?");

/***/ }),

/***/ "./node_modules/vfile/lib/minurl.browser.js":
/*!**************************************************!*\
  !*** ./node_modules/vfile/lib/minurl.browser.js ***!
  \**************************************************/
/*! exports provided: urlToPath, isUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"urlToPath\", function() { return urlToPath; });\n/* harmony import */ var _minurl_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./minurl.shared.js */ \"./node_modules/vfile/lib/minurl.shared.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isUrl\", function() { return _minurl_shared_js__WEBPACK_IMPORTED_MODULE_0__[\"isUrl\"]; });\n\n/// <reference lib=\"dom\" />\n\n\n\n// See: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js>\n\n/**\n * @param {string|URL} path\n */\nfunction urlToPath(path) {\n  if (typeof path === 'string') {\n    path = new URL(path)\n  } else if (!Object(_minurl_shared_js__WEBPACK_IMPORTED_MODULE_0__[\"isUrl\"])(path)) {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'The \"path\" argument must be of type string or an instance of URL. Received `' +\n        path +\n        '`'\n    )\n    error.code = 'ERR_INVALID_ARG_TYPE'\n    throw error\n  }\n\n  if (path.protocol !== 'file:') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError('The URL must be of scheme file')\n    error.code = 'ERR_INVALID_URL_SCHEME'\n    throw error\n  }\n\n  return getPathFromURLPosix(path)\n}\n\n/**\n * @param {URL} url\n */\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'File URL host must be \"localhost\" or empty on darwin'\n    )\n    error.code = 'ERR_INVALID_FILE_URL_HOST'\n    throw error\n  }\n\n  const pathname = url.pathname\n  let index = -1\n\n  while (++index < pathname.length) {\n    if (\n      pathname.charCodeAt(index) === 37 /* `%` */ &&\n      pathname.charCodeAt(index + 1) === 50 /* `2` */\n    ) {\n      const third = pathname.charCodeAt(index + 2)\n      if (third === 70 /* `F` */ || third === 102 /* `f` */) {\n        /** @type {NodeJS.ErrnoException} */\n        const error = new TypeError(\n          'File URL path must not include encoded / characters'\n        )\n        error.code = 'ERR_INVALID_FILE_URL_PATH'\n        throw error\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname)\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/vfile/lib/minurl.browser.js?");

/***/ }),

/***/ "./node_modules/vfile/lib/minurl.shared.js":
/*!*************************************************!*\
  !*** ./node_modules/vfile/lib/minurl.shared.js ***!
  \*************************************************/
/*! exports provided: isUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isUrl\", function() { return isUrl; });\n/**\n * @typedef URL\n * @property {string} hash\n * @property {string} host\n * @property {string} hostname\n * @property {string} href\n * @property {string} origin\n * @property {string} password\n * @property {string} pathname\n * @property {string} port\n * @property {string} protocol\n * @property {string} search\n * @property {any} searchParams\n * @property {string} username\n * @property {() => string} toString\n * @property {() => string} toJSON\n */\n\n/**\n * @param {unknown} fileURLOrPath\n * @returns {fileURLOrPath is URL}\n */\n// From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>\nfunction isUrl(fileURLOrPath) {\n  return (\n    fileURLOrPath !== null &&\n    typeof fileURLOrPath === 'object' &&\n    // @ts-expect-error: indexable.\n    fileURLOrPath.href &&\n    // @ts-expect-error: indexable.\n    fileURLOrPath.origin\n  )\n}\n\n\n//# sourceURL=webpack:///./node_modules/vfile/lib/minurl.shared.js?");

/***/ }),

/***/ "./src/common/libs.ts":
/*!****************************!*\
  !*** ./src/common/libs.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.wait = exports.getWindow = exports.loadScriptIfNeeded = exports.loadScript = exports.exportToNamespace = void 0;\r\nfunction exportToNamespace(root, ns, api) {\r\n    var namespace = ns.split(\".\").reduce(function (prev, key) {\r\n        prev[key] = prev[key] || {};\r\n        return prev[key];\r\n    }, root);\r\n    Object.assign(namespace, api);\r\n}\r\nexports.exportToNamespace = exportToNamespace;\r\nfunction loadScript(src) {\r\n    return new Promise(function (resolve, reject) {\r\n        var $script = document.createElement(\"script\");\r\n        $script.onload = function () { return resolve($script); };\r\n        $script.onerror = function () { return reject(new Error(\"Failed to load\")); };\r\n        $script.src = src;\r\n        document.body.appendChild($script);\r\n    });\r\n}\r\nexports.loadScript = loadScript;\r\nexports.loadScriptIfNeeded = (function () {\r\n    var cache = {};\r\n    return function (src) {\r\n        if (cache[src])\r\n            return cache[src];\r\n        var p = loadScript(src);\r\n        cache[src] = p;\r\n        return p;\r\n    };\r\n})();\r\nfunction getWindow(el) {\r\n    if (document == el.ownerDocument) {\r\n        return window;\r\n    }\r\n    var doc = el.ownerDocument || document;\r\n    return doc.defaultView || doc.parentWindow;\r\n}\r\nexports.getWindow = getWindow;\r\nfunction wait(milliseconds) {\r\n    return new Promise(function (resolve) {\r\n        setTimeout(function () {\r\n            resolve(true);\r\n        }, milliseconds);\r\n    });\r\n}\r\nexports.wait = wait;\r\n\n\n//# sourceURL=webpack:///./src/common/libs.ts?");

/***/ }),

/***/ "./src/latex-parser.ts":
/*!*****************************!*\
  !*** ./src/latex-parser.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.parseLatex = void 0;\r\nvar unified_latex_util_parse_1 = __webpack_require__(/*! @unified-latex/unified-latex-util-parse */ \"./node_modules/@unified-latex/unified-latex-util-parse/index.js\");\r\nvar libs_1 = __webpack_require__(/*! ./common/libs */ \"./src/common/libs.ts\");\r\nfunction parseLatex(source) {\r\n    var root = (0, unified_latex_util_parse_1.parse)(source);\r\n    console.log(root);\r\n    var info = {\r\n        pos: 0,\r\n        mappings: []\r\n    };\r\n    var text = evaluate(root, info);\r\n    return {\r\n        text: text,\r\n        mappings: info.mappings\r\n    };\r\n}\r\nexports.parseLatex = parseLatex;\r\n;\r\nfunction evaluate(node, info) {\r\n    var result = '';\r\n    switch (node.type) {\r\n        case \"string\":\r\n        case \"comment\":\r\n            {\r\n                var content = node.content;\r\n                info.mappings.push(createMapping(node, info.pos, content));\r\n                info.pos += content.length;\r\n                return content;\r\n            }\r\n        case \"whitespace\":\r\n            {\r\n                info.mappings.push(createMapping(node, info.pos, \" \"));\r\n                info.pos += 1;\r\n                return \" \";\r\n            }\r\n        case \"parbreak\":\r\n            info.mappings.push(createMapping(node, info.pos, \"\\n\"));\r\n            info.pos += 1;\r\n            return \"\\n\";\r\n        case \"macro\": {\r\n            var macro = node;\r\n            if (macro.args) {\r\n                for (var _i = 0, _a = macro.args; _i < _a.length; _i++) {\r\n                    var arg = _a[_i];\r\n                    for (var _b = 0, _c = arg.content; _b < _c.length; _b++) {\r\n                        var content = _c[_b];\r\n                        result += evaluate(content, info);\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        case \"root\": {\r\n            var nodes = node.content;\r\n            for (var _d = 0, nodes_1 = nodes; _d < nodes_1.length; _d++) {\r\n                var node_1 = nodes_1[_d];\r\n                result += evaluate(node_1, info);\r\n            }\r\n            break;\r\n        }\r\n        case \"environment\": {\r\n            var env = node;\r\n            for (var _e = 0, _f = env.content; _e < _f.length; _e++) {\r\n                var content = _f[_e];\r\n                result += evaluate(content, info);\r\n            }\r\n            break;\r\n        }\r\n        case \"group\": {\r\n            var group = node;\r\n            for (var _g = 0, _h = group.content; _g < _h.length; _g++) {\r\n                var node_2 = _h[_g];\r\n                result += evaluate(node_2, info);\r\n            }\r\n            break;\r\n        }\r\n        case \"inlinemath\": {\r\n            var math = node;\r\n            for (var _j = 0, _k = math.content; _j < _k.length; _j++) {\r\n                var node_3 = _k[_j];\r\n                result += evaluate(node_3, info);\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction createMapping(node, pos, content) {\r\n    var _a, _b;\r\n    var mapping = {\r\n        originPosition: {\r\n            start: (_a = node.position) === null || _a === void 0 ? void 0 : _a.start.offset,\r\n            end: ((_b = node.position) === null || _b === void 0 ? void 0 : _b.end.offset) - 1\r\n        },\r\n        newPosition: {\r\n            start: pos,\r\n            end: pos + content.length - 1\r\n        },\r\n        content: content\r\n    };\r\n    return mapping;\r\n}\r\nfunction exportAll() {\r\n    (0, libs_1.exportToNamespace)(window, 'latex', {\r\n        parseLatex: parseLatex\r\n    });\r\n}\r\nexportAll();\r\n\n\n//# sourceURL=webpack:///./src/latex-parser.ts?");

/***/ })

/******/ });